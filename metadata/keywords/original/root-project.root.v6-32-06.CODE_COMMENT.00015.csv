id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:214,Modifiability,variab,variable,214,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:60,Integrability,depend,dependent,60,"// FIXME: Teach the constant evaluator to deal with the non-dependent parts; // of value-dependent expressions, and use it here to determine whether the; // initializer is a potential constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:89,Integrability,depend,dependent,89,"// FIXME: Teach the constant evaluator to deal with the non-dependent parts; // of value-dependent expressions, and use it here to determine whether the; // initializer is a potential constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:272,Modifiability,variab,variables,272,"/// Check if the current lambda has any potential captures; /// that must be captured by any of its enclosing lambdas that are ready to; /// capture. If there is a lambda that can capture a nested; /// potential-capture, go ahead and do so. Also, check to see if any; /// variables are uncaptureable or do not involve an odr-use so do not; /// need to be captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:181,Integrability,depend,dependent,181,"// All the potentially captureable variables in the current nested; // lambda (within a generic outer lambda), must be captured by an; // outer lambda that is enclosed within a non-dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,Modifiability,variab,variables,35,"// All the potentially captureable variables in the current nested; // lambda (within a generic outer lambda), must be captured by an; // outer lambda that is enclosed within a non-dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Integrability,depend,dependent,106,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:10,Modifiability,variab,variable,10,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:282,Testability,test,test,282,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:22,Usability,clear,clearly,22,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,Modifiability,variab,variable,47,"// If we have a capture-capable lambda for the variable, go ahead and; // capture the variable in that lambda (and all its enclosing lambdas).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:86,Modifiability,variab,variable,86,"// If we have a capture-capable lambda for the variable, go ahead and; // capture the variable in that lambda (and all its enclosing lambdas).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:283,Availability,error,errors,283,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:317,Availability,error,error,317,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,Integrability,depend,dependent,45,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:62,Modifiability,variab,variable,62,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:139,Modifiability,variab,variable,139,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:221,Modifiability,variab,variable,221,"// This full expression is not instantiation dependent or the variable; // can not be used in a constant expression - which means; // this variable must be odr-used here, so diagnose a; // capture violation early, if the variable is un-captureable.; // This is purely for diagnosing errors early. Otherwise, this; // error would get diagnosed when the lambda becomes capture ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:41,Modifiability,variab,variable,41,"// We will never be able to capture this variable, and we need; // to be able to in any and all instantiations, so diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Safety,Detect,Detect,3,// Detect and handle the case where the decl might be an implicit; // member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:13,Safety,avoid,avoid,13,// A decl to avoid as a correction because it is in the; // process of being initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:163,Usability,clear,clear,163,"// Recursive corrections didn't work, wipe them away and don't add; // them to the TypoExprs set. Remove them from Sema's TypoExpr list; // since we don't want to clear them twice. Note: it's possible the; // TypoExprs were created recursively and thus won't be in our; // Sema's TypoExprs - they were created in our `RecursiveTransformLoop`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:58,Performance,cache,cache,58,// Fetch the next correction by erasing the typo from the cache and calling; // `TryTransform` which will iterate through corrections in; // `TransformTypoExpr`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:80,Usability,clear,clear,80,"// Wipe away any newly created TypoExprs that we don't know about. Since we; // clear any invalid TypoExprs in `CheckForRecursiveTypos`, this is only; // possible if a `TypoExpr` is created during a transformation but then; // fails before we can discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:81,Performance,cache,cached,81,"// If the TypoExpr hasn't been seen before, record it. Otherwise, return the; // cached transformation result if there is one and the TypoExpr isn't the; // first one that was encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,Availability,error,errors,106,"// FIXME: If we would typo-correct to an invalid declaration, it's; // probably best to just suppress all errors from this typo correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:25,Integrability,depend,dependent,25,"// If the name itself is dependent, then the result is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:55,Integrability,depend,dependent,55,"// If the name itself is dependent, then the result is dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:429,Security,access,access,429,"//===--- SemaExprMember.cpp - Semantic Analysis for Expressions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis member access expressions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:55,Security,access,access,55,/// The reference is definitely not an instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:53,Security,access,access,53,/// The reference may be an implicit instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:60,Security,access,access,60,/// The reference is definitely an implicit instance member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:336,Availability,error,errors,336,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:249,Integrability,depend,dependent,249,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:128,Security,access,access,128,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:348,Usability,simpl,simply,348,"/// The given lookup names class member(s) and is not being used for; /// an address-of-member expression. Classify the type of access; /// according to whether it's possible that this reference names an; /// instance member. This is best-effort in dependent contexts; it is okay to; /// conservatively answer ""yes"", in which case some errors will simply; /// not be caught until template-instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:285,Security,access,access,285,"// [class.mfct.non-static]p3:; // ...is used in the body of a non-static member function of class X,; // if name lookup (3.4.1) resolves the name in the id-expression to a; // non-static non-type member of some class C [...]; // ...if C is not X or a base class of X, the class member access expression; // is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:159,Availability,error,error,159,"// If we can prove that the current context is unrelated to all the; // declaring classes, it can't be an implicit member reference (in; // which case it's an error if any of those members are selected).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:51,Availability,avail,available,51,/// Diagnose a reference to a field with no object available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:34,Security,access,access,34,/// Check an ext-vector component access expression.; ///; /// VK should be set in advance to the value kind of the base; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:16,Testability,log,logic,16,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:117,Testability,log,logic,117,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:138,Usability,simpl,simplified,138,"// FIXME: Share logic with ExtVectorElementExpr::containsDuplicateElements,; // see FIXME there.; //; // FIXME: This logic can be greatly simplified by splitting it along; // halving/not halving and reworking the component checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:14,Security,access,accessor,14,// The vector accessor can't exceed the number of elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:23,Security,access,accessor,23,// Ensure no component accessor exceeds the width of the vector type it; // operates on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Security,access,accessor,17,"// The component accessor looks fine - now we need to compute the actual type.; // The vector type is implied by the component accessor. For example,; // vec4.b is a float, vec4.xy is a vec2, vec4.rgb is a vec3, etc.; // vec4.s0 is a float, vec4.s23 is a vec3, etc.; // vec4.hi, vec4.lo, vec4.e, and vec4.o all return vec2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:127,Security,access,accessor,127,"// The component accessor looks fine - now we need to compute the actual type.; // The vector type is implied by the component accessor. For example,; // vec4.b is a float, vec4.xy is a vec2, vec4.rgb is a vec3, etc.; // vec4.s0 is a float, vec4.s23 is a vec3, etc.; // vec4.hi, vec4.lo, vec4.e, and vec4.o all return vec2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:100,Modifiability,extend,extended,100,"// Now look up the TypeDefDecl from the vector type. Without this,; // diagostics look bad. We want extended vector types to appear built-in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Integrability,protocol,protocol-qualifier,17,// Search in the protocol-qualifier list of current protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:52,Integrability,protocol,protocol,52,// Search in the protocol-qualifier list of current protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:320,Availability,error,error,320,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:11,Integrability,depend,dependent,11,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:251,Integrability,interface,interface,251,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:207,Security,access,accessing,207,"// Even in dependent contexts, try to diagnose base expressions with; // obviously wrong types, e.g.:; //; // T* t;; // t.f;; //; // In Obj-C++, however, the above expression is valid, since it could be; // accessing the 'f' property if T is an Obj-C interface. The extra check; // allows this, while still reporting an error if T is a struct pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:22,Security,access,accessed,22,"// Get the type being accessed in BaseType. If this is an arrow, the BaseExpr; // must have pointer type, and the accessed type is the pointee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:114,Security,access,accessed,114,"// Get the type being accessed in BaseType. If this is an arrow, the BaseExpr; // must have pointer type, and the accessed type is the pointee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:33,Security,access,access,33,"// If this is an implicit member access, use a different set of; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,Integrability,depend,dependent,62,// We can't check this yet because the base type is still; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:94,Availability,error,error,94,"// If this is an implicit member reference and we find a; // non-instance member, it's not an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:75,Security,validat,validation,75,// Don't add bare keywords to the consumer since they will always fail; // validation by virtue of not being associated with any decls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:75,Modifiability,variab,variables,75,"// Don't accept candidates that cannot be member functions, constants,; // variables, or templates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,accesses,19,// Implicit member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,accesses,19,// Explicit member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,Security,access,access,39,"// In principle we could have a member access expression that; // accesses an anonymous struct/union that's a static member of; // the base object's class. However, under the current standard,; // static data members cannot be anonymous structs or unions.; // Supporting this is as easy as building a MemberExpr here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:66,Security,access,accesses,66,"// In principle we could have a member access expression that; // accesses an anonymous struct/union that's a static member of; // the base object's class. However, under the current standard,; // static data members cannot be anonymous structs or unions.; // Supporting this is as easy as building a MemberExpr here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:26,Security,access,access,26,// Build the first member access in the chain with full information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Usability,simpl,simple,29,// Property names are always simple identifiers and therefore never; // require any interesting additional storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:99,Availability,error,error,99,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:116,Availability,error,error,116,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:169,Availability,error,error,169,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:208,Availability,error,error,208,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:188,Safety,avoid,avoid,188,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:30,Security,access,access,30,// Handle the implicit-member-access case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,Security,access,access,62,"// If this is not an instance member, convert to a non-member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Modifiability,variab,variable,19,// We might have a variable template specialization (or maybe one day a; // member concept-id).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:7,Integrability,depend,dependent,7,"// Non-dependent member, but dependent template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Integrability,depend,dependent,29,"// Non-dependent member, but dependent template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,Security,access,access,29,"/// Given that normal member access failed on the given expression,; /// and given that the expression's type involves builtin-id or; /// builtin-Class, decide whether substituting in the redefinition; /// types would be profitable. The redefinition type is whatever; /// this translation unit tried to typedef to id/Class; we store; /// it to the side and then re-use it in places like this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:4,Performance,Perform,Perform,4,/// Perform conversions on the LHS of a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:47,Security,access,access,47,/// Perform conversions on the LHS of a member access expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:51,Integrability,depend,dependent,51,"/// Look up the given member of the given non-type-dependent; /// expression. This can return in one of two ways:; /// * If it returns a sentinel null-but-valid result, the caller will; /// assume that lookup was performed and the results written into; /// the provided structure. It will take over from there.; /// * Otherwise, the returned expression will be produced in place of; /// an ordinary member expression.; ///; /// The ObjCImpDecl bit is a gross hack that will need to be properly; /// fixed for ObjC++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:213,Performance,perform,performed,213,"/// Look up the given member of the given non-type-dependent; /// expression. This can return in one of two ways:; /// * If it returns a sentinel null-but-valid result, the caller will; /// assume that lookup was performed and the results written into; /// the provided structure. It will take over from there.; /// * Otherwise, the returned expression will be produced in place of; /// an ordinary member expression.; ///; /// The ObjCImpDecl bit is a gross hack that will need to be properly; /// fixed for ObjC++.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Performance,Perform,Perform,3,// Perform default conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:48,Security,access,accesses,48,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:70,Security,access,accesses,70,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:89,Security,access,access,89,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:189,Security,access,accesses,189,"// For later type-checking purposes, turn arrow accesses into dot; // accesses. The only access type we support that doesn't follow; // the C equivalence ""a->b === (*a).b"" is ObjC property accesses,; // and those never use arrows, so this is unaffected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Recover,Recover,3,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:238,Integrability,message,message,238,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Safety,Recover,Recover,3,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:22,Security,access,accesses,22,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:126,Availability,error,error,126,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:174,Availability,recover,recover,174,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:333,Availability,error,error,333,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:174,Safety,recover,recover,174,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:271,Safety,unsafe,unsafe,271,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:44,Security,access,access,44,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:16,Security,access,access,16,// Handle field access to simple records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:26,Usability,simpl,simple,26,// Handle field access to simple records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:185,Usability,clear,cleared--that,185,"// Returning valid-but-null is how we indicate to the caller that; // the lookup result was filled in. If typo correction was attempted and; // failed, the lookup result will have been cleared--that combined with the; // valid-but-null ExprResult will trigger the appropriate diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:15,Security,access,access,15,// Handle ivar access to Objective-C objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:144,Integrability,interface,interface,144,// There are three cases for the base type:; // - builtin id (qualified or unqualified); // - builtin Class (qualified or unqualified); // - an interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,Availability,error,error,39,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:56,Availability,error,error,56,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:109,Availability,error,error,109,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:148,Availability,error,error,148,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:128,Safety,avoid,avoid,128,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:181,Availability,avail,available,181,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:207,Availability,down,down,207,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:294,Availability,down,down,294,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:244,Integrability,rout,routine,244,"// Case of a c-function declared inside an objc implementation.; // FIXME: For a c-style function nested inside an objc implementation; // class, there is no implementation context available, so we pass; // down the context as argument to this routine. Ideally, this context; // need be passed down in the AST node and somehow calculated from the; // AST for a function decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:24,Security,access,access,24,// Objective-C property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,Security,access,access,19,// Normal property access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:23,Security,access,access,23,// We disallow element access for ext_vector_type bool. There is no way to; // materialize a reference to a vector element as a pointer (each element is; // one bit in the vector).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,Security,access,access,17,"// Handle 'field access' to vectors, such as 'V.xx'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Failure,Failure,3,// Failure cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Availability,Recover,Recover,3,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Safety,Recover,Recover,3,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,Security,access,accesses,20,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,Security,access,access,20,// Recurse as an -> access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:10,Security,access,accesses,10,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:164,Security,access,access,164,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:305,Security,access,access,305,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:30,Security,access,access,30,"/// Builds an implicit member access expression. The current context; /// is known to be an instance method, and the given unqualified lookup; /// set is known to contain only instance members, at least one of which; /// is from an appropriate type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:38,Security,access,access,38,"// If this is known to be an instance access, go ahead and build an; // implicit 'this' expression now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:27,Security,access,access,27,// null signifies implicit access,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Integrability,interface,interface,34,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:82,Integrability,interface,interface,82,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:209,Integrability,interface,interface,209,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:76,Availability,error,error,76,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:86,Availability,recover,recover,86,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,interface,interface,35,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:86,Safety,recover,recover,86,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,interface,interface,27,"// If there is no NSString interface defined, implicitly declare; // a @class NSString; and use that instead. This is to make sure; // type of an NSString literal is represented correctly, instead of; // being an 'id' type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Availability,error,error,13,"/// Emits an error if the given method does not exist, or if the return; /// type is not an Objective-C object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Safety,avoid,avoid,35,// FIXME: Is there a better way to avoid quotes than using getName()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:32,Availability,avail,availability,32,"/// Validates ObjCInterfaceDecl availability.; /// ObjCInterfaceDecl, used to create ObjC literals, should be defined; /// if clang not in a debugger mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:4,Security,Validat,Validates,4,"/// Validates ObjCInterfaceDecl availability.; /// ObjCInterfaceDecl, used to create ObjC literals, should be defined; /// if clang not in a debugger mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:67,Performance,cache,cached,67,"// Look up the NSNumber class, if we haven't done so already. It's cached; // in the Sema instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:12,Testability,stub,stub,12,// create a stub definition this NSNumber factory method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:29,Integrability,depend,dependent,29,"// If the expression is type-dependent, there's nothing for us to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Performance,Perform,Perform,3,// Perform lvalue-to-rvalue conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:179,Performance,cache,cached,179,"// Support for structure types, that marked as objc_boxable; // struct __attribute__((objc_boxable)) s { ... };; // Look up the NSValue class, if we haven't done so already. It's cached; // in the Sema instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:16,Integrability,depend,dependent,16,// We can't get dependent types here; our callers should have; // filtered them out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Performance,Perform,Perform,3,// Perform lvalue-to-rvalue conversion on the base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:82,Performance,perform,performing,82,"// Check that each of the elements provided is valid in a collection literal,; // performing conversions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:89,Performance,perform,performing,89,"// Check that each of the keys and values provided is valid in a collection; // literal, performing conversions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Deployability,release,release,63,"// In ARC, forbid the user from using @selector for; // retain/release/autorelease/dealloc/retainCount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Availability,error,error,35,"// If we're not in an ObjC method, error out. Note that, unlike the; // C++ case, we don't require an instance method --- class methods; // still have a 'self', and we really do still need to capture it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,message,message,35,"/// Determine the result type of a message send based on the receiver type,; /// method, and the kind of message send.; ///; /// This is the ""base"" result type, which will still need to be adjusted; /// to account for nullability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:105,Integrability,message,message,105,"/// Determine the result type of a message send based on the receiver type,; /// method, and the kind of message send.; ///; /// This is the ""base"" result type, which will still need to be adjusted; /// to account for nullability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:99,Integrability,message,message,99,"// If a method has a related return type:; // - if the method found is an instance method, but the message send; // was a class message send, T is the declared return type of the method; // found",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:128,Integrability,message,message,128,"// If a method has a related return type:; // - if the method found is an instance method, but the message send; // was a class message send, T is the declared return type of the method; // found",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,"// If this is a class message, ignore the nullability of the receiver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:28,Integrability,message,messages,28,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:118,Safety,safe,safely,118,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:191,Safety,unsafe,unsafely,191,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,Integrability,interface,interface,90,"// For these purposes, a method in an @implementation overrides a; // declaration in the @interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:47,Integrability,message,message,47,// Find the class to which we are sending this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:43,Integrability,depend,dependent,43,// We can't do any type-checking on a type-dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Deployability,Update,Update,3,// Update the parameter type in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:101,Modifiability,extend,extend,101,"// If we are type-erasing a block to a block-compatible; // Objective-C pointer type, we may need to extend the lifetime; // of the block object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:26,Integrability,interface,interface,26,"// Look it up in the main interface (and categories, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:57,Integrability,protocol,protocol,57,/// LookupMethodInQualifiedType - Lookups up a method in protocol qualifier; /// list of a qualified objective pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:93,Integrability,interface,interface,93,/// HandleExprPropertyRefExpr - Handle foo.bar where foo is a pointer to an; /// objective C interface. This is a property reference expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:9,Integrability,protocol,protocols,9,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:32,Integrability,interface,interfaces,32,// Check protocols on qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:120,Testability,log,logic,120,"// If that failed, look for an ""implicit"" property by seeing if the nullary; // selector is implemented.; // FIXME: The logic for looking up nullary and unary selectors should be; // shared with the code in ActOnInstanceMessage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:70,Security,access,accessor,70,// Special warning if member name used in a property-dot for a setter accessor; // does not use a property with same name; e.g. obj.X = ... for a property with; // name 'x'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:67,Security,access,access,67,"// This is a class property, we should not use the instance to; // access it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Modifiability,refactor,refactor,10,// FIXME: refactor/share with ActOnMemberReference().; // Check if we can reference this property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,message,message,168,"// If the identifier is ""super"" and there is no trailing dot, we're; // messaging super. If the identifier is ""super"" and there is a; // trailing dot, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:60,Integrability,message,message,60,// Fall back: let the parser try to parse it as an instance message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:20,Performance,perform,perform,20,// Break out; we'll perform typo correction below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,Integrability,message,message,90,"// If the identifier is a class or not, and there is a trailing dot,; // it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:64,Integrability,message,message,64,"// We found something. If it's a type, then we have a class; // message. Otherwise, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:101,Integrability,message,message,101,"// We found something. If it's a type, then we have a class; // message. Otherwise, it's an instance message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:19,Integrability,message,message,19,"// We have a class message, and T is the type we're; // messaging. Build source-location information for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:60,Integrability,message,message,60,// Fall back: let the parser try to parse it as an instance message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Integrability,message,message,63,"// Since we are in an instance method, this is an instance; // message to the superclass instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:51,Integrability,message,message,51,"// Since we are in a class method, this is a class message to; // the superclass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Performance,perform,performSelector,22,// Check if this is a performSelector method that uses a selector that returns; // a record or a vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:31,Integrability,message,message,31,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:66,Integrability,rout,routine,66,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:106,Integrability,message,messages,106,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:130,Integrability,message,messages,130,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:257,Integrability,message,message,257,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:457,Integrability,message,message,457,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:697,Integrability,message,message,697,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:753,Integrability,message,message,753,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:827,Integrability,message,message,827,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:1047,Integrability,message,message,1047,"/// Build an Objective-C class message expression.; ///; /// This routine takes care of both normal class messages and; /// class messages to the superclass.; ///; /// \param ReceiverTypeInfo Type source information that describes the; /// receiver of this message. This may be NULL, in which case we are; /// sending to the superclass and \p SuperLoc must be a valid source; /// location.; /// \param ReceiverType The type of the object receiving the; /// message. When \p ReceiverTypeInfo is non-NULL, this is the same; /// type as that refers to. For a superclass send, this is the type of; /// the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this class message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,depend,dependent,27,"// If the receiver type is dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:94,Integrability,depend,dependent,94,"// If the receiver type is dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:47,Integrability,message,message,47,// Find the class to which we are sending this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Integrability,message,messages,55,"// ActOnClassMessage - used for both unary and keyword messages.; // ArgExprs is optional - if it is present, the number of expressions; // is obtained from Sel.getNumArgs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Integrability,message,message,34,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:69,Integrability,rout,routine,69,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:112,Integrability,message,messages,112,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:139,Integrability,message,messages,139,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:270,Integrability,message,message,270,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:494,Integrability,message,message,494,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:771,Integrability,message,message,771,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:827,Integrability,message,message,827,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:904,Integrability,message,message,904,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:1124,Integrability,message,message,1124,"/// Build an Objective-C instance message expression.; ///; /// This routine takes care of both normal instance messages and; /// instance messages to the superclass instance.; ///; /// \param Receiver The expression that computes the object that will; /// receive this message. This may be empty, in which case we are; /// sending to the superclass instance and \p SuperLoc must be a valid; /// source location.; ///; /// \param ReceiverType The (static) type of the object receiving the; /// message. When a \p Receiver expression is provided, this is the; /// same type as that expression. For a superclass instance send, this; /// is a pointer to the type of the superclass.; ///; /// \param SuperLoc The location of the ""super"" keyword in a; /// superclass instance message.; ///; /// \param Sel The selector to which the message is being sent.; ///; /// \param Method The method that this instance message is invoking, if; /// already known.; ///; /// \param LBracLoc The location of the opening square bracket ']'.; ///; /// \param RBracLoc The location of the closing square bracket ']'.; ///; /// \param ArgsIn The message arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:37,Performance,perform,perform,37,"// If we have a receiver expression, perform appropriate promotions; // and determine receiver type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,Integrability,depend,dependent,27,"// If the receiver is type-dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:94,Integrability,depend,dependent,94,"// If the receiver is type-dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,messages,10,// Handle messages to id and __kindof types (where we use the; // global method pool).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,messages,10,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:52,Integrability,message,message,52,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:135,Integrability,protocol,protocols,135,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocols,10,// Search protocols for class methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:45,Integrability,message,message,45,// warn if instance method found for a Class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:57,Integrability,interface,interface,57,"// As a guess, try looking for the method in the current interface.; // This very well may not produce the ""right"" method.; // First check the public methods in the class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:171,Integrability,interface,interface,171,"// As a guess, try looking for the method in the current interface.; // This very well may not produce the ""right"" method.; // First check the public methods in the class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:99,Integrability,protocol,protocols,99,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,message,message,168,"// We allow sending a message to a qualified ID (""id<foo>""), which is ok as; // long as one of the protocols implements the selector (if not, warn).; // And as long as message is not deprecated/unavailable (warn if it is).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocols,10,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,Integrability,message,message,22,// We allow sending a message to a pointer to an interface (an object).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Integrability,interface,interface,49,// We allow sending a message to a pointer to an interface (an object).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Availability,error,error,55,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:92,Availability,recover,recover,92,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:159,Availability,error,error,159,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:92,Safety,recover,recover,92,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,protocol,protocol,10,// Search protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:103,Safety,safe,safe,103,"// Under ARC, self can't be assigned, and doing a direct call to `self`; // when it's a Class is hence safe. For other cases, we can't trust `self`; // is what we think it is, so we reject it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Integrability,message,message,13,// Check the message arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Deployability,release,release,63,"// In ARC, forbid the user from sending messages to; // retain/release/autorelease/dealloc/retainCount explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:40,Integrability,message,messages,40,"// In ARC, forbid the user from sending messages to; // retain/release/autorelease/dealloc/retainCount explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:9,Availability,error,error,9,"// Issue error, unless ns_returns_not_retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Availability,error,error,3,// error (may leak).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,Integrability,message,message,10,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:66,Integrability,message,message,66,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,Integrability,Message,Messages,168,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:211,Integrability,message,messages,211,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:147,Performance,perform,performed,147,"// 'self' message receivers in class methods should be treated as message; // sends to the class object in order for the semantic checks to be; // performed correctly. Messages to 'super' already count as class messages,; // so they don't need to be handled here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:21,Integrability,message,message,21,"// In ARC, check for message sends which are likely to introduce; // retain cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:58,Integrability,message,messages,58,"// ActOnInstanceMessage - used for both unary and keyword messages.; // ArgExprs is optional - if it is present, the number of expressions; // is obtained from Sel.getNumArgs().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:43,Availability,error,error,43,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Availability,recover,recovery,49,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:49,Safety,recover,recovery,49,// A ParenListExpr can show up while doing error recovery with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:11,Safety,safe,safely,11,/// Can be safely retained or not retained.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:39,Safety,safe,safely,39,/// Objective-C string literals can be safely casted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:13,Integrability,message,message,13,"// Check for message sends to functions returning CF types. We; // just obey the Cocoa conventions with these, even though the; // return type is CF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,Integrability,bridg,bridge-related,35,// Defer emitting a diagnostic for bridge-related casts; that will be; // handled by CheckObjCBridgeRelatedConversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:44,Integrability,bridg,bridge,44,// Check whether this could be fixed with a bridge cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Integrability,Bridg,Bridge,3,// Bridge from an ARC type to a CF type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:3,Integrability,Bridg,Bridge,3,// Bridge from a CF type to an ARC type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:58,Integrability,bridg,bridge,58,// ok to cast to 'id'.; // casting to id<p-list> is ok if bridge type adopts all of; // p-list protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:95,Integrability,protocol,protocols,95,// ok to cast to 'id'.; // casting to id<p-list> is ok if bridge type adopts all of; // p-list protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,Integrability,bridg,bridge,63,// warn in presence of __bridge casting to or from a toll free bridge cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,Security,access,accessor,55,// fixit: ObjectExpr.propertyname when it is aproperty accessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,Availability,error,error,34,// Check for viability and report error if casting an rvalue to a; // life-time qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:138,Integrability,bridg,bridge,138,"// Issue a diagnostic about a missing @-sign when implicit casting a cstring; // to 'NSString *', instead of falling through to report a ""bridge cast""; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:17,Integrability,bridg,bridge,17,"// Do not issue ""bridge cast"" diagnostic when implicit casting; // a retainable object to a CF type parameter belonging to an audited; // CF API function. Let caller issue a normal type mismatched diagnostic; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:126,Security,audit,audited,126,"// Do not issue ""bridge cast"" diagnostic when implicit casting; // a retainable object to a CF type parameter belonging to an audited; // CF API function. Let caller issue a normal type mismatched diagnostic; // instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:8,Availability,down,down,8,// Walk down the expression until we hit an implicit cast of kind; // ARCReclaimReturnedObject or an Expr that is neither a Paren nor a Cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:23,Integrability,depend,dependent,23,// Okay: we'll build a dependent expression type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:4,Deployability,Update,Update,4,"/// Update the type of a string literal, including any surrounding parentheses,; /// to match the type of the object which it is initializing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:150,Safety,Avoid,Avoid,150,"// We have an array of character type with known size. However,; // the size may be smaller or larger than the string we are initializing.; // FIXME: Avoid truncation for 64-bit length strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:99,Integrability,rout,routines,99,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:491,Integrability,rout,routines,491,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:645,Integrability,rout,routine,645,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:750,Integrability,rout,routine,750,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:272,Performance,perform,performs,272,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:679,Safety,avoid,avoid,679,"// Explanation on the ""FillWithNoInit"" mode:; //; // Assume we have the following definitions (Case#1):; // struct P { char x[6][6]; } xp = { .x[1] = ""bar"" };; // struct PP { struct P lp; } l = { .lp = xp, .lp.x[1][2] = 'f' };; //; // l.lp.x[1][0..1] should not be filled with implicit initializers because the; // ""base"" initializer ""xp"" will provide values for them; l.lp.x[1] will be ""baf"".; //; // But if we have (Case#2):; // struct PP l = { .lp = xp, .lp.x[1] = { [2] = 'f' } };; //; // l.lp.x[1][0..1] are implicitly initialized and do not use values from the; // ""base"" initializer; l.lp.x[1] will be ""\0\0f\0\0\0"".; //; // To distinguish Case#1 from Case#2, and also to avoid leaving many ""holes""; // in the InitListExpr, the ""holes"" in Case#1 are filled not with empty; // initializers but with special ""NoInitExpr"" place holders, which tells the; // CodeGen not to generate any initializers for these parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:320,Performance,perform,performs,320,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:426,Safety,avoid,avoid,426,"// C++1y / DR1070:; // shall be initialized [...] from an empty initializer list.; //; // We apply the resolution of this DR to C++11 but not C++98, since C++98; // does not have useful semantics for initialization from an init list.; // We treat this as copy-initialization, because aggregate initialization; // always performs copy-initialization on its elements.; //; // Only do this if we're initializing a class type, to avoid filling in; // the initializer list where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:96,Availability,recover,recover,96,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:96,Safety,recover,recover,96,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:120,Testability,log,logic,120,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Modifiability,extend,extend,60,"// Empty initialization requires a constructor call, so; // extend the initializer list to include the constructor; // call and make a note that we'll need to take another pass; // through the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Performance,perform,perform,98,"/// Recursively replaces NULL values within the given initializer list; /// with expressions that perform value-initialization of the; /// appropriate type, and finish off the InitListExpr formation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:241,Deployability,update,updated,241,"// If this is a nested initializer list, we might have changed its contents; // (and therefore some of its properties, such as instantiation-dependence); // while filling it in. Inform the outer initializer list so that its state; // can be updated to match.; // FIXME: We should fully build the inner initializers before constructing; // the outer InitListExpr instead of mutating AST nodes after they have; // been used as subexpressions of other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:141,Integrability,depend,dependence,141,"// If this is a nested initializer list, we might have changed its contents; // (and therefore some of its properties, such as instantiation-dependence); // while filling it in. Inform the outer initializer list so that its state; // can be updated to match.; // FIXME: We should fully build the inner initializers before constructing; // the outer InitListExpr instead of mutating AST nodes after they have; // been used as subexpressions of other nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:28,Performance,perform,performing,28,// A transparent ILE is not performing aggregate initialization and should; // not be filled in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:40,Performance,perform,performing,40,"// In VerifyOnly mode, there's no point performing empty initialization; // more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Modifiability,extend,extend,60,"// Empty initialization requires a constructor call, so; // extend the initializer list to include the constructor; // call and make a note that we'll need to take another pass; // through the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:147,Deployability,Update,Update,147,"/// Check whether the range of the initializer \p ParentIList from element; /// \p Index onwards can be used to initialize an object of type \p T. Update; /// \p Index to indicate how many elements of the list were consumed.; ///; /// This also fills in \p StructuredList, from element \p StructuredIndex; /// onwards, with the fully-braced, desugared form of the initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the structured sub-object initializer so that it's ending; // range corresponds with the end of the last initializer it used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:79,Integrability,depend,dependent,79,"// Don't warn during template instantiation. If the initialization was; // non-dependent, we warned during the initial parse; otherwise, the; // type might not be scalar in some uses of the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Availability,error,error,59,"// Don't complain for incomplete types, since we'll get an error elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Integrability,depend,dependent,115,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:170,Integrability,depend,dependent,170,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Integrability,depend,dependent,115,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent; // bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:170,Integrability,depend,dependent,170,// C++ [over.match.class.deduct]p1.5:; // brace elision is not considered for any aggregate element that has a; // dependent non-array type or an array type with a value-dependent; // bound,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:190,Performance,perform,performed,190,"// C++14 [dcl.init.aggr]p13:; // If the assignment-expression can initialize a member, the member is; // initialized. Otherwise [...] brace elision is assumed; //; // Brace elision is never performed if the element is not an; // assignment-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:55,Modifiability,flexible,flexible,55,"// arrayType can be incomplete if we're initializing a flexible; // array member. There's nothing we can do with the completed; // type here, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:45,Performance,Perform,PerformCopyInitialization,45,"// We cannot initialize this element, so let PerformCopyInitialization; // produce the appropriate diagnostic. We already checked that this; // initialization will fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Deployability,update,update,26,"// The type was promoted, update initializer list.; // FIXME: Why are we updating the syntactic init list?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,Availability,down,down,136,"// FIXME: It would be wonderful if we could point at the actual member. In; // general, it would be useful to pass location information down the stack,; // so that we know the location (or decl) of the ""current object"" being; // initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:120,Availability,failure,failure,120,"// If the initializing element is a vector, try to copy-initialize; // instead of breaking it apart (which is doomed to failure anyway).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Deployability,update,update,26,"// The type was promoted, update initializer list.; // FIXME: Why are we updating the syntactic init list?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:390,Modifiability,portab,portable,390,"// The ability to use vector initializer lists is a GNU vector extension; // and is unrelated to the NEON intrinsics in arm_neon.h. On little; // endian machines it works fine, however on big endian machines it; // exhibits surprising behaviour:; //; // uint32x2_t x = {42, 64};; // return vget_lane_u32(x, 0); // Will return 64.; //; // Because of this, explicitly call out that it is non-portable.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Security,access,accessible,48,"/// Check if the type of a class element has an accessible destructor, and marks; /// it referenced. Returns true if we shouldn't form a reference to the; /// destructor.; ///; /// Aggregate initialization requires a class element's destructor be; /// accessible per 11.6.1 [dcl.init.aggr]:; ///; /// The destructor for each element of class type is potentially invoked; /// (15.4 [class.dtor]) from the context where the aggregate initialization; /// occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:252,Security,access,accessible,252,"/// Check if the type of a class element has an accessible destructor, and marks; /// it referenced. Returns true if we shouldn't form a reference to the; /// destructor.; ///; /// Aggregate initialization requires a class element's destructor be; /// accessible per 11.6.1 [dcl.init.aggr]:; ///; /// The destructor for each element of class type is potentially invoked; /// (15.4 [class.dtor]) from the context where the aggregate initialization; /// occurs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:263,Availability,error,error,263,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:30,Modifiability,variab,variable,30,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:379,Usability,clear,clear,379,"// C23 6.7.10p4: An entity of variable length array type shall not be; // initialized except by an empty initializer.; //; // The C extension warnings are issued from ParseBraceInitializer() and; // do not need to be issued here. However, we continue to issue an error; // in the case there are initializers or we are compiling C++. We allow; // use of VLAs in C++, but it's not clear we want to allow {} to zero; // init a VLA in C++ in all cases (such as with non-trivial constructors).; // FIXME: should we allow this construct in C++ when it makes sense to do; // so?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:64,Deployability,update,updated,64,// Handle this designated initializer. elementIndex will be; // updated to be the next array element we'll initialize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:179,Performance,perform,performing,179,"// If there are any members of the array that get value-initialized, check; // that is possible. That happens if we know the bound and don't have; // enough elements, or if we're performing an array new with an unknown; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Modifiability,flexible,flexible,14,// Handle GNU flexible array initializers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:9,Modifiability,flexible,flexible,9,// Empty flexible array init always allowed as an extension,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on non-top-level object,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on anything which is not a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Modifiability,variab,variable,59,// Disallow flexible array init on anything which is not a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,flexible,flexible,12,// Disallow flexible array init on local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:41,Modifiability,variab,variables,41,// Disallow flexible array init on local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:66,Safety,avoid,avoid,66,"// If the record is invalid, some of it's members are invalid. To avoid; // confusion, we forgo checking the initializer for the entire record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:143,Availability,error,error,143,"// If structDecl is a forward declaration, this loop won't do; // anything except look at designated initializers; That's okay,; // because an error should get printed out elsewhere. It might be; // worthwhile to skip over the rest of the initializer, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:53,Deployability,update,updated,53,// Handle this designated initializer. Field will be updated to; // the next field that we'll be initializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:20,Modifiability,flexible,flexible,20,"// If we've hit the flexible array member at the end, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:53,Security,access,accessible,53,// Check that the types of the remaining fields have accessible destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:111,Availability,down,down,111,"// Expand the current designator into the set of replacement; // designators, so we have a full subobject path down to where the; // member of the anonymous struct/union is actually stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:1723,Availability,error,error,1723,"// end anonymous namespace; /// Check the well-formedness of a C99 designated initializer.; ///; /// Determines whether the designated initializer @p DIE, which; /// resides at the given @p Index within the initializer list @p; /// IList, is well-formed for a current object of type @p DeclType; /// (C99 6.7.8). The actual subobject that this designator refers to; /// within the current subobject is returned in either; /// @p NextField or @p NextElementIndex (whichever is appropriate).; ///; /// @param IList The initializer list in which this designated; /// initializer occurs.; ///; /// @param DIE The designated initializer expression.; ///; /// @param DesigIdx The index of the current designator.; ///; /// @param CurrentObjectType The type of the ""current object"" (C99 6.7.8p17),; /// into which the designation in @p DIE should refer.; ///; /// @param NextField If non-NULL and the first designator in @p DIE is; /// a field, this will be set to the field declaration corresponding; /// to the field named by the designator. On input, this is expected to be; /// the next field that would be initialized in the absence of designation,; /// if the complete object being initialized is a struct.; ///; /// @param NextElementIndex If non-NULL and the first designator in @p; /// DIE is an array designator or GNU array-range designator, this; /// will be set to the last index initialized by this designator.; ///; /// @param Index Index into @p IList where the designated initializer; /// @p DIE occurs.; ///; /// @param StructuredList The initializer list expression that; /// describes all of the subobject initializers in the order they'll; /// actually be initialized.; ///; /// @returns true if there was an error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:153,Performance,perform,performing,153,"// C++20 designated initialization can result in direct-list-initialization; // of the designated subobject. This is the only way that we can end up; // performing direct initialization as part of aggregate initialization, so; // it needs special handling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:81,Deployability,update,update,81,"// We don't need to track the structured representation of a; // designated init update of an already-fully-initialized object in; // verify-only mode. The only reason we would need the structure is; // to determine where the uninitialized ""holes"" are, and in this; // case, we know there aren't any and we can't introduce any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:26,Modifiability,variab,variable,26,// We found a placeholder variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:319,Performance,perform,performing,319,"// C++20 [dcl.init.list]p3:; // The ordered identifiers in the designators of the designated-; // initializer-list shall form a subsequence of the ordered identifiers; // in the direct non-static data members of T.; //; // Note that this is not a condition on forming the aggregate; // initialization, only on actually performing initialization,; // so it is not checked in VerifyOnly mode.; //; // FIXME: This is the only reordering diagnostic we produce, and it only; // catches cases where we have a top-level field designator that jumps; // backwards. This is the only such case that is reachable in an; // otherwise-valid C++20 program, so is the only case that's required for; // conformance, but for consistency, we should diagnose all the other; // cases where a designator takes us backwards too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the designator with the field declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:27,Modifiability,flexible,flexible,27,// This designator names a flexible array member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:43,Modifiability,flexible,flexible,43,// We can't designate an object within the flexible array; // member (because GCC doesn't allow it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:13,Modifiability,flexible,flexible,13,// Check GNU flexible array initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:309,Availability,error,error,309,"// Codegen can't handle evaluating array range designators that have side; // effects, because we replicate the AST value for each initialized element.; // As such, set the sawArrayRangeDesignator() bit if we initialize multiple; // elements with something that has a side effect, so codegen can emit an; // ""error unsupported"" error instead of miscompiling the app.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:328,Availability,error,error,328,"// Codegen can't handle evaluating array range designators that have side; // effects, because we replicate the AST value for each initialized element.; // As such, set the sawArrayRangeDesignator() bit if we initialize multiple; // elements with something that has a side effect, so codegen can emit an; // ""error unsupported"" error instead of miscompiling the app.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:27,Deployability,update,update,27,// We're just verifying an update to a string literal init. We don't need; // to split the string up into individual characters to do that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Performance,perform,perform,14,"// Repeatedly perform subobject initializations in the range; // [DesignatedStartIndex, DesignatedEndIndex].; // Move to the next designator",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:554,Deployability,update,update,554,"// We are creating an initializer list that initializes the; // subobjects of the current object, but there was already an; // initialization that completely initialized the current; // subobject:; //; // struct X { int a, b; };; // struct X xs[] = { [0] = { 1, 2 }, [0].b = 3 };; //; // Here, xs[0].a == 1 and xs[0].b == 3, since the second,; // designated initializer overwrites the [0].b initializer; // from the prior initialization.; //; // When the existing initializer is an expression rather than an; // initializer list, we cannot decompose and update it in this way.; // For example:; //; // struct X xs[] = { [0] = (struct X) { 1, 2 }, [0].b = 3 };; //; // This case is handled by CheckDesignatedInitializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:7,Energy Efficiency,allocate,allocate,7,// Pre-allocate storage for the structured initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Energy Efficiency,allocate,allocate,37,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Usability,Simpl,Simple,3,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:4,Deployability,Update,Update,4,/// Update the initializer at index @p StructuredIndex within the; /// structured initializer list to the value @p expr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Deployability,update,update,37,// No structured initializer list to update,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Performance,perform,perform,29,/// Determine whether we can perform aggregate initialization for the purposes; /// of overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:259,Availability,failure,failure,259,"/// Check that the given Index expression is a valid array designator; /// value. This is essentially just a wrapper around; /// VerifyIntegerConstantExpression that also checks for negative values; /// and produces a reasonable diagnostic if there is a; /// failure. Returns the index expression, possibly with an implicit cast; /// added, on success. If everything went okay, Value will receive the; /// value of the constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:109,Integrability,wrap,wrapper,109,"/// Check that the given Index expression is a valid array designator; /// value. This is essentially just a wrapper around; /// VerifyIntegerConstantExpression that also checks for negative values; /// and produces a reasonable diagnostic if there is a; /// failure. Returns the index expression, possibly with an implicit cast; /// added, on success. If everything went okay, Value will receive the; /// value of the constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution and return the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:129,Performance,perform,performs,129,"/// Attempt initialization by constructor (C++ [dcl.init]), which; /// enumerates the constructors of the initialized entity and performs overload; /// resolution to select the best.; /// \param DestType The destination class type.; /// \param DestArrayType The destination type, which is either DestType or; /// a (possibly multidimensional) array of DestType.; /// \param IsListInit Is this list-initialization?; /// \param IsInitListCopy Is this non-list-initialization resulting from a; /// list-initialization from {x} where x is the same; /// type as the entity?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:489,Safety,avoid,avoid,489,"// C++17 [dcl.init]p17:; // - If the initializer expression is a prvalue and the cv-unqualified; // version of the source type is the same class as the class of the; // destination, the initializer expression is used to initialize the; // destination object.; // Per DR (no number yet), this does not apply when initializing a base; // class or delegating to another constructor from a mem-initializer.; // ObjC++: Lambda captured by the block in the lambda to block conversion; // should avoid copy elision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:179,Performance,perform,performed,179,"// C++11 [over.match.list]p1, per DR1467:; // When objects of non-aggregate type T are list-initialized, such that; // 8.5.4 [dcl.init.list] specifies that overload resolution is performed; // according to the rules in this section, overload resolution selects; // the constructor in two phases:; //; // - Initially, the candidate functions are the initializer-list; // constructors of the class T and the argument list consists of the; // initializer list as a single argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:115,Performance,perform,performed,115,"// C++11 [over.match.list]p1:; // - If no viable initializer-list constructor is found, overload resolution; // is performed again, where the candidate functions are all the; // constructors of the class T and the argument list consists of the; // elements of the initializer list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:108,Performance,perform,performed,108,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.; // For deleted functions in other contexts, there is no need to get the; // initialization sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:250,Performance,perform,perform,250,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.; // For deleted functions in other contexts, there is no need to get the; // initialization sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the initializer if we've resolved an overloaded function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform address space compatibility check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:60,Performance,perform,perform,60,// Ignore address space of reference type at this point and perform address; // space conversion after the reference binding step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:167,Performance,perform,performed,167,"// C++20 [dcl.init.list]p3:; // - If the braced-init-list contains a designated-initializer-list, T shall; // be an aggregate class. [...] Aggregate initialization is performed.; //; // We allow arrays here too in order to support array designators.; //; // FIXME: This check should precede the handling of reference initialization.; // We follow other compilers in allowing things like 'Aggr &&a = {.x = 1};'; // as a tentative DR resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:530,Performance,perform,performed,530,"// C++11 [dcl.init.list]p3, per DR1467:; // - If T is a class type and the initializer list has a single element of; // type cv U, where U is T or a class derived from T, the object is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization).; // - Otherwise, if T is a character array and the initializer list has a; // single element that is an appropriately-typed string literal; // (8.5.2 [dcl.init.string]), initialization is performed as described; // in that section.; // - Otherwise, if T is an aggregate, [...] (continue below).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:84,Performance,perform,performed,84,"// C++11 [dcl.init.list]p3:; // - If T is an aggregate, aggregate initialization is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:460,Performance,perform,performing,460,"// - Otherwise, if the initializer list has a single element of type E; // [...references are handled above...], the object or reference is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization); if a narrowing conversion is required; // to convert the element to T, the program is ill-formed.; //; // Per core-24034, this is direct-initialization if we were performing; // direct-list-initialization and copy-initialization otherwise.; // We can't use InitListChecker for this, because it always performs; // copy-initialization. This only matters if we might use an 'explicit'; // conversion operator, or for the special case conversion of nullptr_t to; // bool, so we only need to handle those cases.; //; // FIXME: Why not do this in all cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:598,Performance,perform,performs,598,"// - Otherwise, if the initializer list has a single element of type E; // [...references are handled above...], the object or reference is; // initialized from that element (by copy-initialization for; // copy-list-initialization, or by direct-initialization for; // direct-list-initialization); if a narrowing conversion is required; // to convert the element to T, the program is ill-formed.; //; // Per core-24034, this is direct-initialization if we were performing; // direct-list-initialization and copy-initialization otherwise.; // We can't use InitListChecker for this, because it always performs; // copy-initialization. This only matters if we might use an 'explicit'; // conversion operator, or for the special case conversion of nullptr_t to; // bool, so we only need to handle those cases.; //; // FIXME: Why not do this in all cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution. If it fails, return the failed result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Performance,perform,perform,35,// Determine whether we'll need to perform derived-to-base adjustments or; // other conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform a (possibly multi-level) qualification conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:92,Performance,perform,perform,92,"// The corresponding bullet in C++03 [dcl.init.ref]p5 gives the; // compiler the freedom to perform a copy here or bind to the; // object, while C++0x requires that we bind directly to the; // object. Hence, we always bind to the object without making an; // extra copy. However, in C++03 requires that we check for the; // presence of a suitable copy constructor:; //; // The constructor that would be used to make the copy shall; // be callable whether or not the copy is actually done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:292,Performance,perform,perform,292,"// - Otherwise, a temporary of type ""cv1 T1"" is created and initialized; // from the initializer expression using the rules for a non-reference; // copy-initialization (8.5). The reference is then bound to the; // temporary. [...]; // Ignore address space of reference type at this point and perform address; // space conversion after the reference binding step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:193,Security,access,accessible,193,"// C++98:; // -- if T is a class type (clause 9) with a user-declared constructor; // (12.1), then the default constructor for T is called (and the; // initialization is ill-formed if T has no accessible default; // constructor);; // C++11:; // -- if T is a class type (clause 9) with either no default constructor; // (12.1 [class.ctor]) or a default constructor that is user-provided; // or deleted, then the object is default-initialized;; //; // Note that the C++11 rule is the same as the C++98 rule if there are no; // defaulted or deleted constructors, so we just use it unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:73,Integrability,wrap,wrap,73,"// FIXME: Instead of creating a CXXConstructExpr of array type here,; // wrap a class-typed CXXConstructExpr in an ArrayInitLoopExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:160,Security,access,accessible,160,"// - if T is a (possibly cv-qualified) class type (Clause 9), the default; // constructor for T is called (and the initialization is ill-formed if; // T has no accessible default constructor);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:37,Performance,perform,performed,37,"// - otherwise, no initialization is performed.; // If a program calls for the default initialization of an object of; // a const-qualified type T, T shall be a class type with a user-provided; // default constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:28,Modifiability,variab,variable,28,"// Braced-initialization of variable array types is not allowed, even if; // the size is greater than or equal to the number of args, so we don't; // allow them to be initialized via parenthesized aggregate initialization; // either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:17,Safety,avoid,avoid,17,// Exit early to avoid confusion when processing members.; // We do the same for braced list initialization in; // `CheckStructUnionTypes`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Modifiability,flexible,flexible,35,"// Incomplete array types indicate flexible array members. Do not allow; // paren list initializations of structs with these members, as GCC; // doesn't either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:125,Performance,perform,performs,125,"/// Attempt a user-defined conversion between two types (C++ [dcl.init]),; /// which enumerates all conversion functions and performs overload resolution; /// to select the best.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:195,Usability,simpl,simply,195,"// The type we're converting from is a class type, enumerate its conversion; // functions.; // We can only enumerate the conversion functions for a complete type; if; // the type isn't complete, simply skip this step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution. If it fails, return the failed result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:108,Performance,perform,performed,108,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:250,Performance,perform,perform,250,"// [class.copy.elision]p3:; // In some copy-initialization contexts, a two-stage overload resolution; // is performed.; // If the first overload resolution selects a deleted function, we also; // need the initialization sequence to decide whether to perform the second; // overload resolution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:343,Performance,perform,performs,343,"// C++14 and before:; // - if the function is a constructor, the call initializes a temporary; // of the cv-unqualified version of the destination type. The [...]; // temporary [...] is then used to direct-initialize, according to the; // rules above, the object that is the destination of the; // copy-initialization.; // Note that this just performs a simple object copy from the temporary.; //; // C++17:; // - if the function is a constructor, the call is a prvalue of the; // cv-unqualified version of the destination type whose return object; // is initialized by the constructor. The call is used to; // direct-initialize, according to the rules above, the object that; // is the destination of the copy-initialization.; // Therefore we need to do nothing further.; //; // FIXME: Mark this copy as extraneous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:354,Usability,simpl,simple,354,"// C++14 and before:; // - if the function is a constructor, the call initializes a temporary; // of the cv-unqualified version of the destination type. The [...]; // temporary [...] is then used to direct-initialize, according to the; // rules above, the object that is the destination of the; // copy-initialization.; // Note that this just performs a simple object copy from the temporary.; //; // C++17:; // - if the function is a constructor, the call is a prvalue of the; // cv-unqualified version of the destination type whose return object; // is initialized by the constructor. The call is used to; // direct-initialize, according to the rules above, the object that; // is the destination of the copy-initialization.; // Therefore we need to do nothing further.; //; // FIXME: Mark this copy as extraneous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:68,Security,hash,hashtable,68,"/// An egregious hack for compatibility with libstdc++-4.2: in <tr1/hashtable>,; /// a function with a pointer return type contains a 'return false;' statement.; /// In C++11, 'false' is not a null pointer, so this breaks the build of any; /// code using that header.; ///; /// Work around this by treating 'return false;' as zero-initializing the result; /// if it's used in a pointer-returning function in a system header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:64,Modifiability,variab,variable,64,"// If we have a declaration reference, it had better be a local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:72,Performance,load,load,72,"// set isWeakAccess to true, to mean that there will be an implicit; // load which requires a cleanup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:58,Performance,load,load,58,"// If isWeakAccess to true, there will be an implicit; // load which requires a cleanup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Performance,perform,perform,29,/// Determine whether we can perform an elementwise array copy for this kind; /// of entity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:119,Integrability,depend,dependent,119,// Eliminate non-overload placeholder types in the arguments. We; // need to do this before checking whether types are dependent; // because lowering a pseudo-object expression might well give us; // something of dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:213,Integrability,depend,dependent,213,// Eliminate non-overload placeholder types in the arguments. We; // need to do this before checking whether types are dependent; // because lowering a pseudo-object expression might well give us; // something of dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:33,Modifiability,variab,variable,33,"// C++0x [dcl.init.ref]p1:; // A variable declared to be a T& or T&&, that is, ""reference to type T""; // (8.3.2), shall be initialized by an object, or function, of type T or; // by an object that can be converted into a T.; // (Therefore, multiple arguments are not permitted.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:111,Performance,perform,perform,111,"// Some kinds of initialization permit an array to be initialized from; // another array of the same type, and perform elementwise initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:159,Integrability,wrap,wrapping,159,"// Do not attempt paren list initialization if overload resolution; // resolves to a deleted function .; //; // We may reach this condition if we have a union wrapping a class with; // a non-trivial copy or move constructor and we call one of those two; // constructors. The union is an aggregate, but the matched constructor; // is implicitly deleted, so we need to prevent aggregate initialization; // (otherwise, it'll attempt aggregate initialization by initializing; // the first element with a reference to the union).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Performance,Perform,Perform,85,//===----------------------------------------------------------------------===//; // Perform initialization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:732,Availability,error,error,732,"/// Make a (potentially elidable) temporary copy of the object; /// provided by the given initializer by calling the appropriate copy; /// constructor.; ///; /// \param S The Sema object used for type-checking.; ///; /// \param T The type of the temporary object, which must either be; /// the type of the initializer expression or a superclass thereof.; ///; /// \param Entity The entity being initialized.; ///; /// \param CurInit The initializer expression.; ///; /// \param IsExtraneousCopy Whether this is an ""extraneous"" copy that; /// is permitted in C++03 (but not C++0x) when binding a reference to; /// an rvalue.; ///; /// \returns An expression that copies the initializer expression into; /// a temporary object, or an error expression if a copy could not be; /// created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution using the class's constructors. Per; // C++11 [dcl.init]p16, second bullet for class types, this initialization; // is direct-initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:234,Availability,down,down,234,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:249,Safety,avoid,avoid,249,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:107,Integrability,rout,routine,107,"// Build the default argument expression; we don't actually care; // if this succeeds or not, because this routine will complain; // if there was a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,"// Determine the arguments required to actually perform the; // constructor call (we might have derived-to-base conversions, or; // the copy constructor may have default arguments).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Performance,perform,perform,12,// Actually perform the constructor call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,// Determine the arguments required to actually perform the constructor; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,Security,access,access,14,// Only check access if all of that succeeded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:56,Modifiability,extend,extended,56,/// The lifetime of a temporary bound to this entity is extended to the; /// lifeitme of the entity itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Energy Efficiency,allocate,allocated,104,"/// The lifetime of a temporary bound to this entity probably ends too soon,; /// because the entity is allocated in a new-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:43,Modifiability,extend,extend,43,"/// This is a mem-initializer: if it would extend a temporary (other than via; /// a default member initializer), the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:113,Modifiability,extend,extending,113,"/// Determine the declaration which an initialized entity ultimately refers to,; /// for the purpose of lifetime-extending a temporary bound to a reference in; /// the initialization of \p Entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:51,Modifiability,variab,variable,51,"// Per [dcl.decomp]p3, the binding is treated as a variable of reference; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Modifiability,extend,extended,104,// -- The lifetime of a temporary bound to the returned value in a; // function return statement is not extended; the temporary is; // destroyed at the end of the full-expression in the return statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,Modifiability,extend,extend,29,// FIXME: Should we lifetime-extend through the result of a statement; // expression?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:134,Deployability,patch,patch,134,"// We don't yet know the storage duration of the surrounding temporary.; // Assume it's got full-expression duration for now, it will patch up our; // storage duration if that's not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extended,22,/// Lifetime would be extended by a reference binding to a temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extended,22,/// Lifetime would be extended by a std::initializer_list object binding to; /// its backing array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:25,Modifiability,variab,variable,25,/// A temporary or local variable. This will be one of:; /// * A MaterializeTemporaryExpr.; /// * A DeclRefExpr whose declaration is a local.; /// * An AddrLabelExpr.; /// * A BlockExpr for a block with captures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,variab,variable,22,// Don't declare this variable in the second operand of the for-statement;; // GCC miscompiles that by ending its lifetime before evaluating the; // third operand. See gcc.gnu.org/PR86769.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:50,Modifiability,extend,extend,50,// Walk past any constructs which we can lifetime-extend across.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,Availability,redundant,redundant,19,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,Safety,redund,redundant,19,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Performance,perform,performing,82,"// Per current approach for DR1376, look through casts to reference type; // when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:101,Performance,perform,performing,101,"// Per the current approach for DR1299, look through array element access; // on array glvalues when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:67,Security,access,access,67,"// Per the current approach for DR1299, look through array element access; // on array glvalues when performing lifetime extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:21,Modifiability,extend,extend,21,// We can't lifetime extend through this but we might still find some; // retained temporaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Modifiability,inherit,inherits,82,// Step into CXXDefaultInitExprs so we can diagnose cases where a; // constructor inherits one as an implicit mem-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Modifiability,inherit,inherits,82,// Step into CXXDefaultInitExprs so we can diagnose cases where a; // constructor inherits one as an implicit mem-initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:47,Modifiability,extend,extended,47,// Dig out the expression which constructs the extended temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:87,Modifiability,extend,extends,87,// C++17 [dcl.init.list]p6:; // initializing an initializer_list object from the array extends the; // lifetime of the array exactly like binding a reference to a temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:70,Performance,perform,performing,70,// We already visited the elements of this initializer list while; // performing the initialization. Don't visit them again unless we've; // changed the lifetime of the initialized entity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:18,Modifiability,extend,extend,18,"// If we lifetime-extend a braced initializer which is initializing an; // aggregate, and that aggregate contains reference members which are; // bound to temporaries, those temporaries are also lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:204,Modifiability,extend,extended,204,"// If we lifetime-extend a braced initializer which is initializing an; // aggregate, and that aggregate contains reference members which are; // bound to temporaries, those temporaries are also lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:165,Modifiability,extend,extend,165,"// This might be either aggregate-initialization of a member or; // initialization of a std::initializer_list object. Regardless,; // we should recursively lifetime-extend that initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Availability,redundant,redundant,98,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,Safety,redund,redundant,98,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:13,Modifiability,extend,extend,13,/// Lifetime-extend along this path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:244,Deployability,update,update,244,"/// We should lifetime-extend, but we don't because (due to technical; /// limitations) we can't. This happens for default member initializers,; /// which we don't clone for every use, so we don't have a unique; /// MaterializeTemporaryExpr to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:23,Modifiability,extend,extend,23,"/// We should lifetime-extend, but we don't because (due to technical; /// limitations) we can't. This happens for default member initializers,; /// which we don't clone for every use, so we don't have a unique; /// MaterializeTemporaryExpr to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:20,Modifiability,extend,extend,20,/// Do not lifetime extend along this path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:100,Modifiability,extend,extend,100,/// Determine whether this is an indirect path to a temporary that we are; /// supposed to lifetime-extend along.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:106,Safety,avoid,avoid,106,// We do not want to follow the references when returning a pointer originating; // from a local owner to avoid the following false positive:; // int &p = *localUniquePtr;; // someContainer.add(std::move(localUniquePtr));; // return p;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:192,Modifiability,variab,variable,192,// Skipping a chain of initializing gsl::Pointer annotated objects.; // We are looking only for the final source to find out if it was; // a local or temporary owner or the address of a local variable/param.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:201,Modifiability,variab,variable,201,"// The initialized entity has lifetime beyond the full-expression,; // and the local entity does too, so don't warn.; //; // FIXME: We should consider warning if a static / thread storage; // duration variable retains an automatic storage duration local.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Deployability,Update,Update,3,// Update the storage duration of the materialized temporary.; // FIXME: Rebuild the expression instead of mutating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:39,Modifiability,extend,extended,39,// Also visit the temporaries lifetime-extended by this initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:30,Modifiability,extend,extend,30,"// We're supposed to lifetime-extend the temporary along this path (per; // the resolution of DR1815), but we don't support that yet.; //; // FIXME: Properly handle this situation. Perhaps the easiest approach; // would be to clone the initializer expression on each use that would; // lifetime extend its temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:295,Modifiability,extend,extend,295,"// We're supposed to lifetime-extend the temporary along this path (per; // the resolution of DR1815), but we don't support that yet.; //; // FIXME: Properly handle this situation. Perhaps the easiest approach; // would be to clone the initializer expression on each use that would; // lifetime extend its temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Modifiability,variab,variable,52,"// If the path goes through the initialization of a variable or field,; // it can't possibly reach a temporary created in this full-expression.; // We will have already diagnosed any problems with the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:122,Modifiability,extend,extend,122,"// Under C++ DR1696, if a mem-initializer (or a default member; // initializer used by the absence of one) would lifetime-extend a; // temporary, the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:57,Availability,error,error,57,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:63,Availability,recover,recovery,63,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:63,Safety,recover,recovery,63,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Modifiability,variab,variable,35,// We can't determine if the local variable outlives the statement; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:90,Availability,error,errors,90,"// We didn't lifetime-extend, so don't go any further; we don't need more; // warnings or errors on inner temporaries within this one's initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:22,Modifiability,extend,extend,22,"// We didn't lifetime-extend, so don't go any further; we don't need more; // warnings or errors on inner temporaries within this one's initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:11,Modifiability,variab,variables,11,// __block variables are not moved implicitly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:11,Testability,test,testing,11,"// Special testing for the argument location. Since the fix-it needs the; // location right before the argument, the argument location can be in a; // macro only if it is at the beginning of the macro.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:113,Security,access,access,113,"// Order an ExprWithCleanups for lifetime marks.; //; // TODO: It'll be good to have a single place to check the access of the; // destructor and generate ExprWithCleanups for various uses. Currently these; // are done in both CreateMaterializeTemporaryExpr and MaybeBindToTemporary,; // but there may be a chance to merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:90,Availability,error,error,90,"// The initialization would have succeeded with this fixit. Since the fixit; // is on the error, we need to build a valid AST in this case, so this isn't; // handled in the Failed() branch above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:46,Modifiability,variab,variables,46,// Use a more useful diagnostic for constexpr variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:31,Integrability,depend,dependent,31,"// If the declaration is a non-dependent, incomplete array type; // that has an initializer, then its type will be completed once; // the initializer is instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:306,Integrability,depend,dependently-sized,306,"// FIXME: We don't currently have the ability to accurately; // compute the length of an initializer list without; // performing full type-checking of the initializer list; // (since we have to determine where braces are implicitly; // introduced and such). So, we fall back to making the array; // type a dependently-sized array type with no specified; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:118,Performance,perform,performing,118,"// FIXME: We don't currently have the ability to accurately; // compute the length of an initializer list without; // performing full type-checking of the initializer list; // (since we have to determine where braces are implicitly; // introduced and such). So, we fall back to making the array; // type a dependently-sized array type with no specified; // bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:34,Modifiability,variab,variables,34,// OpenCL v2.0 s6.13.11.1. atomic variables can be initialized in global scope,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:188,Performance,perform,perform,188,// Promote from an unevaluated context to an unevaluated list context in; // C++11 list-initialization; we need to instantiate entities usable in; // constant expressions here in order to perform narrowing checks =(,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,Usability,usab,usable,136,// Promote from an unevaluated context to an unevaluated list context in; // C++11 list-initialization; we need to instantiate entities usable in; // constant expressions here in order to perform narrowing checks =(,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:72,Performance,perform,performing,72,"// Walk through the computed steps for the initialization sequence,; // performing the specified conversions along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:57,Deployability,update,update,57,// Overload resolution determined which function invoke; update the; // initializer to reflect that choice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:83,Performance,Perform,Perform,83,// We have a derived-to-base cast that produces either an rvalue or an; // lvalue. Perform that cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:69,Availability,avail,availability,69,"// We don't check for e.g. function pointers here, since address; // availability checks should only occur when the function first decays; // into a pointer or reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:12,Modifiability,extend,extending,12,// If we're extending this temporary to automatic storage duration -- we; // need to register its cleanup during the full-expression's cleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,Performance,perform,perform,48,// Determine the arguments required to actually perform the constructor; // call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Performance,Perform,Perform,3,// Perform a qualification conversion; these can never go wrong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:39,Availability,avail,available,39,"// Hack: We must update *ResultType if available in order to set the; // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.; // Worst case: 'const int (&arref)[] = {1, 2, 3};'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:17,Deployability,update,update,17,"// Hack: We must update *ResultType if available in order to set the; // bounds of arrays, e.g. in 'int ar[] = {1, 2, 3};'.; // Worst case: 'const int (&arref)[] = {1, 2, 3};'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:56,Deployability,update,update,56,"// If the destination type is an incomplete array type, update the; // type accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Integrability,Wrap,Wrap,3,// Wrap it in a construction of a std::initializer_list<T>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:106,Modifiability,variab,variable,106,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:152,Modifiability,variab,variable,152,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:224,Modifiability,variab,variable,224,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:282,Modifiability,variab,variable,282,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:329,Modifiability,variab,variable,329,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:361,Modifiability,variab,variables,361,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:591,Modifiability,variab,variables,591,"// Sampler initialization have 5 cases:; // 1. function argument passing; // 1a. argument is a file-scope variable; // 1b. argument is a function-scope variable; // 1c. argument is one of caller function's parameters; // 2. variable initialization; // 2a. initializing a file-scope variable; // 2b. initializing a function-scope variable; //; // For file-scope variables, since they cannot be initialized by function; // call of __translate_sampler_initializer in LLVM IR, their references; // need to be replaced by a cast from their literal initializers to; // sampler type. Since sampler variables can only be used in function; // calls as arguments, we only need to replace them when handling the; // argument passing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:59,Modifiability,variab,variable,59,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:148,Modifiability,variab,variable,148,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:242,Modifiability,variab,variable,242,"// Case 1a; // For function call with a file-scope sampler variable as argument,; // get the integer literal.; // Do not diagnose if the file-scope variable does not have initializer; // since this has already been diagnosed when parsing the variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:104,Modifiability,variab,variable,104,"// Case 2; // Check initializer is 32 bit integer constant.; // If the initializer is taken from global variable, do not diagnose since; // this has already been done when parsing the variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:184,Modifiability,variab,variable,184,"// Case 2; // Check initializer is 32 bit integer constant.; // If the initializer is taken from global variable, do not diagnose since; // this has already been done when parsing the variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:117,Modifiability,extend,extend,117,"// Check whether the initializer has a shorter lifetime than the initialized; // entity, and if not, either lifetime-extend or warn as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:109,Availability,failure,failures,109,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:296,Availability,failure,failure,296,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:277,Usability,simpl,simple,277,"//===----------------------------------------------------------------------===//; // Diagnose initialization failures; //===----------------------------------------------------------------------===//; /// Emit notes associated with an initialization that failed due to a; /// ""simple"" conversion failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:82,Integrability,message,message,82,// Emit a possible note about the conversion failing because the; // operand is a message send with a related result type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:25,Availability,failure,failure,25,// A list-initialization failure for a reference means that we tried to; // create a temporary of the inner type (per [dcl.init.list]p3.6) and the; // inner initialization failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:15,Availability,error,error,15,// No-op. This error has already been reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:103,Usability,clear,clear,103,"// If this is a defaulted or implicitly-declared function, then; // it was implicitly deleted. Make it clear that the deletion was; // implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:5,Modifiability,variab,variable,5,// A variable's value may have been narrowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:47,Modifiability,variab,variable,47,"// Oops, we didn't find the actual type of the variable. Don't emit a fixit; // with a broken cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:35,Performance,perform,performing,35,// Prevent infinite recursion when performing parameter copy-initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:15,Performance,perform,perform,15,// We can only perform deduction for class templates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:21,Integrability,depend,dependent,21,// Can't deduce from dependent arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:10,Performance,Perform,Perform,10,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:126,Usability,guid,guide,126,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:223,Usability,guid,guides,223,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:526,Usability,guid,guide,526,"// FIXME: Perform ""exact type"" matching first, per CWG discussion?; // Or implement this via an implied 'T(T) -> T' deduction guide?; // FIXME: Do we need/want a std::initializer_list<T> special case?; // Look up deduction guides, including those synthesized from constructors.; //; // C++1z [over.match.class.deduct]p1:; // A set of functions and function templates is formed comprising:; // - For each constructor of the class template designated by the; // template-name, a function template [...]; // - For each deduction-guide, a function or function template [...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:128,Security,access,access,128,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:49,Usability,guid,guides,49,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:80,Usability,clear,clear,80,"// FIXME: Do not diagnose inaccessible deduction guides. The standard isn't; // clear on this, but they're not found by name so access does not apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:523,Energy Efficiency,reduce,reduces,523,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Performance,perform,performed,85,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:240,Performance,perform,performed,240,"// C++1z [over.match.class.deduct]p1:; // Initialization and overload resolution are performed as described in; // [dcl.init] and [over.match.ctor], [over.match.copy], or [over.match.list]; // (as appropriate for the type of initialization performed) for an object; // of a hypothetical class type, where the selected functions and function; // templates are considered to be the constructors of that class type; //; // Since we know we're initializing a class type of a type unrelated to that; // of the initializer, this reduces to something fairly reasonable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Usability,guid,guide,52,"// Overload resolution checks whether the deduction guide is declared; // explicit for us.; // When looking for a converting constructor, deduction guides that; // could never be called with one argument are not interesting to; // check or note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:148,Usability,guid,guides,148,"// Overload resolution checks whether the deduction guide is declared; // explicit for us.; // When looking for a converting constructor, deduction guides that; // could never be called with one argument are not interesting to; // check or note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:511,Usability,clear,clear,511,"// C++ [over.match.list]p1.2: (second phase list initialization); // the candidate functions are all the constructors of the class T; // C++ [over.match.ctor]p1: (all other cases); // the candidate functions are all the constructors of the class of; // the object being initialized; // C++ [over.best.ics]p4:; // When [...] the constructor [...] is a candidate by; // - [over.match.copy] (in all cases); // FIXME: The ""second phase of [over.match.list] case can also; // theoretically happen here, but it's not clear whether we can; // ever have a parameter of the right type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:180,Integrability,depend,dependent,180,"// C++ [over.match.class.deduct]p1.4:; // if C is defined and its definition satisfies the conditions for an; // aggregate class ([dcl.init.aggr]) with the assumption that any; // dependent base class has no virtual functions and no virtual base; // classes, and the initializer is a non-empty braced-init-list or; // parenthesized expression-list, and there are no deduction-guides for; // C, the set contains an additional function template, called the; // aggregate deduction candidate, defined as follows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:376,Usability,guid,guides,376,"// C++ [over.match.class.deduct]p1.4:; // if C is defined and its definition satisfies the conditions for an; // aggregate class ([dcl.init.aggr]) with the assumption that any; // dependent base class has no virtual functions and no virtual base; // classes, and the initializer is a non-empty braced-init-list or; // parenthesized expression-list, and there are no deduction-guides for; // C, the set contains an additional function template, called the; // aggregate deduction candidate, defined as follows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,Usability,guid,guide,52,"// Make sure we didn't select an unusable deduction guide, and mark it; // as referenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Usability,guid,guides,85,// Warn if CTAD was used on a type that does not have any user-defined; // deduction guides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:358,Availability,down,down,358,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:620,Availability,down,down,620,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:855,Integrability,depend,dependent,855,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Modifiability,variab,variable,149,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1468,Modifiability,inherit,inherits,1468,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1611,Modifiability,variab,variable,1611,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-ready' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-ready lambda's LambdaScopeInfo.; ///; /// Climbs down the stack of lambdas (deepest nested lambda - i.e. current; /// lambda - is on top) to determine the index of the nearest enclosing/outer; /// lambda that is ready to capture the \p VarToCapture being referenced in; /// the current lambda.; /// As we climb down the stack, we want the index of the first such lambda -; /// that is the lambda with the highest index that is 'capture-ready'.; ///; /// A lambda 'L' is capture-ready for 'V' (var or this) if:; /// - its enclosing context is non-dependent; /// - and if the chain of lambdas between L and the lambda in which; /// V is potentially used (i.e. the lambda at the top of the scope info; /// stack), can all capture or have already captured V.; /// If \p VarToCapture is 'null' then we are trying to capture 'this'.; ///; /// Note that a lambda that is deemed 'capture-ready' still needs to be checked; /// for whether it is 'capture-capable' (see; /// getStackIndexOfNearestEnclosingCaptureCapableLambda), before it can truly; /// capture.; ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack and has the highest index.; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-ready. If the return value evaluates to 'false'; /// then no lambda is capture-ready for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:9,Availability,failure,failure,9,// Label failure to capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:22,Availability,down,down,22,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:189,Integrability,depend,dependent,189,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:267,Integrability,depend,dependent,267,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:84,Modifiability,variab,variable,84,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Modifiability,variab,variable,149,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:380,Modifiability,variab,variable,380,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:647,Integrability,depend,dependent,647,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:768,Integrability,depend,dependent,768,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:720,Modifiability,variab,variable,720,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:807,Modifiability,variab,variable,807,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:29,Integrability,depend,dependent,29,"// If the enclosingDC is not dependent, then the immediately nested lambda; // (one index above) is capture-ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:716,Availability,down,down,716,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1039,Availability,failure,failure,1039,"tionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is captu",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:973,Integrability,depend,dependent,973,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:151,Modifiability,variab,variable,151,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:427,Modifiability,variab,variable,427,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:573,Modifiability,variab,variable,573,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:903,Modifiability,variab,variable,903,"/// Examines the FunctionScopeInfo stack to determine the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1140,Modifiability,variab,variable,1140," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1309,Modifiability,variab,variable,1309," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1364,Modifiability,variab,variables,1364," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1583,Modifiability,inherit,inherits,1583," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:1705,Modifiability,variab,variable,1705," the nearest; /// enclosing lambda (to the current lambda) that is 'capture-capable' for; /// the variable referenced in the current lambda (i.e. \p VarToCapture).; /// If successful, returns the index into Sema's FunctionScopeInfo stack; /// of the capture-capable lambda's LambdaScopeInfo.; ///; /// Given the current stack of lambdas being processed by Sema and; /// the variable of interest, to identify the nearest enclosing lambda (to the; /// current lambda at the top of the stack) that can truly capture; /// a variable, it has to have the following two properties:; /// a) 'capture-ready' - be the innermost lambda that is 'capture-ready':; /// - climb down the stack (i.e. starting from the innermost and examining; /// each outer lambda step by step) checking if each enclosing; /// lambda can either implicitly or explicitly capture the variable.; /// Record the first such lambda that is enclosed in a non-dependent; /// context. If no such lambda currently exists return failure.; /// b) 'capture-capable' - make sure the 'capture-ready' lambda can truly; /// capture the variable by checking all its enclosing lambdas:; /// - check if all outer lambdas enclosing the 'capture-ready' lambda; /// identified above in 'a' can also capture the variable (this is done; /// via tryCaptureVariable for variables and CheckCXXThisCapture for; /// 'this' by passing in the index of the Lambda identified in step 'a'); ///; /// \param FunctionScopes - Sema's stack of nested FunctionScopeInfo's (which a; /// LambdaScopeInfo inherits from). The current/deepest/innermost lambda; /// is at the top of the stack.; ///; /// \param VarToCapture - the variable to capture. If NULL, capture 'this'.; ///; ///; /// \returns An std::optional<unsigned> Index that if evaluates to 'true'; /// contains the index (into Sema's FunctionScopeInfo stack) of the innermost; /// lambda which is capture-capable. If the return value evaluates to 'false'; /// then no lambda is capture-capable for \p VarToCapture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Modifiability,variab,variable,59,"// Check if the capture-ready lambda can truly capture the variable, by; // checking whether all enclosing lambdas of the capture-ready lambda allow; // the capture - i.e. make sure it is capture-capable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:46,Modifiability,variab,variables,46,// -- the initializers of inline or templated variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,Integrability,depend,dependent,28,"// If a lambda appears in a dependent context or is a generic lambda (has; // template parameters) and has an 'auto' return type, deduce it to a; // dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:149,Integrability,depend,dependent,149,"// If a lambda appears in a dependent context or is a generic lambda (has; // template parameters) and has an 'auto' return type, deduce it to a; // dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:396,Integrability,depend,depends,396,"// Force lambda numbering in CUDA/HIP as we need to name lambdas following; // ODR. Both device- and host-compilation need to have a consistent naming; // on kernel functions. As lambdas are potential part of these `__global__`; // function names, they needs numbering following ODR.; // Also force for SYCL, since we need this for the; // __builtin_sycl_unique_stable_name implementation, which depends on lambda; // mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Integrability,Depend,DependentTy,59,"// If it was ever a placeholder, it had to been deduced to DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,Usability,simpl,simply,28,"// It's possible there were simply no /valid/ return statements.; // In this case, the first one we found may have at least given us a type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:50,Integrability,depend,dependent,50,// Second case: at least one return statement has dependent type.; // Delay type checking until instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:56,Modifiability,variab,variable,56,// Just ignore the ellipsis for now and form a non-pack variable. We'll; // diagnose this later when we try to capture it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:3,Performance,Perform,Perform,3,// Perform initialization analysis and ensure any implicit conversions; // (such as lvalue-to-rvalue) are enforced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:18,Modifiability,variab,variable,18,"// Create a dummy variable representing the init-capture. This is not actually; // used as a variable, and only exists as a way to name and refer to the; // init-capture.; // FIXME: Pass in separate source locations for '&' and identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:93,Modifiability,variab,variable,93,"// Create a dummy variable representing the init-capture. This is not actually; // used as a variable, and only exists as a way to name and refer to the; // init-capture.; // FIXME: Pass in separate source locations for '&' and identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:81,Integrability,depend,dependent,81,"// Determine if we're within a context where we know that the lambda will; // be dependent, because there are template parameters in scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,Availability,redundant,redundant,234,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:234,Safety,redund,redundant,234,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:102,Usability,simpl,simple-capture,102,"// C++20 [expr.prim.lambda]p8:; // If a lambda-capture includes a capture-default that is =,; // each simple-capture of that lambda-capture shall be of the form; // ""&identifier"", ""this"", or ""* this"". [ Note: The form [&,this] is; // redundant but accepted for compatibility with ISO C++14. --end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:88,Availability,error,error,88,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:253,Modifiability,variab,variable,253,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:36,Usability,usab,usable,36,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:72,Modifiability,variab,variable,72,// C++11 [expr.prim.lambda]p10:; // [...] each such lookup shall find a variable with automatic storage; // duration declared in the reaching scope of the local lambda expression.; // Note that the 'reaching scope' check happens in tryCaptureVariable().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:341,Modifiability,variab,variable,341,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:205,Usability,simpl,simple-capture,205,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:258,Usability,simpl,simple-captures,258,"// C++11 [expr.prim.lambda]p9:; // A lambda-expression whose smallest enclosing scope is a block scope is a; // local lambda expression; any other lambda expression shall not have a; // capture-default or simple-capture in its lambda-introducer.; //; // For simple-captures, this is covered by the check below that any named; // entity is a variable that can be captured.; //; // For DR1632, we also allow a capture-default in any context where we can; // odr-use 'this' (in particular, in a default initializer for a non-static; // data member).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:145,Integrability,depend,dependent,145,"// After the parameter list, we may parse a noexcept/requires/trailing return; // type which need to know whether the call operator constiture a dependent; // context, so we need to setup the FunctionTemplateDecl of generic lambdas; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:451,Modifiability,variab,variable,451,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:724,Modifiability,variab,variable,724,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:738,Modifiability,variab,variable,738,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:761,Modifiability,variab,variable,761,"// [temp.pre]/8:; // An entity is templated if it is; // - a template,; // - an entity defined ([basic.def]) or created ([class.temporary]) in a; // templated entity,; // - a member of a templated entity,; // - an enumerator for an enumeration that is a templated entity, or; // - the closure type of a lambda-expression ([expr.prim.lambda.closure]); // appearing in the declaration of a templated entity. [Note 6: A local; // class, a local or block variable, or a friend function defined in a; // templated entity is a templated entity.  end note]; //; // A templated function is a function template or a function that is; // templated. A templated class is a class template or a class that is; // templated. A templated variable is a variable template or a variable; // that is templated.; // Note: we only have to check if this is defined in a template entity, OR; // if we are a template, since the rest don't apply. The requires clause; // applies to the call operator, which we already know is a member function,; // AND defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:784,Safety,detect,detecting,784,"/// Implement emitting a version of the operator for many of the calling; /// conventions for MSVC, as described here:; /// https://devblogs.microsoft.com/oldnewthing/20150220-00/?p=44623.; /// Experimentally, we determined that cdecl, stdcall, fastcall, and; /// vectorcall are generated by MSVC when it is supported by the target.; /// Additionally, we are ensuring that the default-free/default-member and; /// call-operator calling convention are generated as well.; /// NOTE: We intentionally generate a 'thiscall' on Win32 implicitly from the; /// 'member default', despite MSVC not doing so. We do this in order to ensure; /// that someone who intentionally places 'thiscall' on the lambda call; /// operator will still get that overload, since we don't have the a way of; /// detecting the attribute by the time we get here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:626,Modifiability,variab,variables,626,"// Construct a TypeSourceInfo for the conversion function, and wire; // all the parameters appropriately for the FunctionProtoTypeLoc; // so that everything works during transformation/instantiation of; // generic lambdas.; // The main reason for wiring up the parameters of the conversion; // function with that of the call operator is so that constructs; // like the following work:; // auto L = [](auto b) { <-- 1; // return [](auto a) -> decltype(a) { <-- 2; // return a;; // };; // };; // int (*fp)(int) = L(5);; // Because the trailing return type can contain DeclRefExprs that refer; // to the original call operator's variables, we hijack the call; // operators ParmVarDecls below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:432,Usability,simpl,simply,432,"// Wire up the FunctionProtoTypeLocs with the call operator's parameters.; // These parameter's are essentially used to transform the name and; // the type of the conversion operator. By using the same parameters; // as the call operator's we don't have to fix any back references that; // the trailing return type of the call operator's uses (such as; // decltype(some_type<decltype(a)>::type{} + decltype(a){}) etc.); // - we can simply use the return type of the call operator, and; // everything should work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:374,Safety,avoid,avoid,374,"// FIXME: Instead of passing in the CallOperator->getTypeSourceInfo(); // we should get a prebuilt TrivialTypeSourceInfo from Context; // using FunctionTy & Loc and get its TypeLoc as a FunctionProtoTypeLoc; // then rewire the parameters accordingly, by hoisting up the InvokeParams; // loop below and then use its Params to set Invoke->setParams(...) below.; // This would avoid the 'const' qualifier of the calloperator from; // contaminating the type of the invoker, which is currently adjusted; // in SemaTemplateDeduction.cpp:DeduceTemplateArguments. Fixing the; // trailing return type of the invoker would require a visitor to rebuild; // the trailing return type and adjusting all back DeclRefExpr's to refer; // to the new static invoker parameters - not the call operator's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:361,Performance,perform,performed,361,"// C++11 [expr.prim.lambda]p21:; // When the lambda-expression is evaluated, the entities that; // are captured by copy are used to direct-initialize each; // corresponding non-static data member of the resulting closure; // object. (For array members, the array elements are; // direct-initialized in increasing subscript order.) These; // initializations are performed in the (unspecified) order in; // which the non-static data members are declared.; // C++ [expr.prim.lambda]p12:; // An entity captured by a lambda-expression is odr-used (3.2) in; // the scope containing the lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:77,Modifiability,variab,variables,77,"// In OpenMP, the capture kind doesn't actually describe how to capture:; // variables are ""mapped"" onto the device in a process that does not formally; // make a copy, even for a ""copy capture"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:81,Integrability,message,message,81,// FIXME: maybe we should warn on these if we can find a sensible diagnostic; // message,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:10,Modifiability,variab,variable,10,"// If the variable being captured has an invalid type, mark the class as; // invalid as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Availability,avail,available,59,// Use source ranges of explicit captures for fixits where available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:103,Integrability,depend,dependent,103,"// If the lambda expression's call operator is not explicitly marked constexpr; // and we are not in a dependent context, analyze the call operator to infer; // its constexpr-ness, suppressing diagnostics while doing so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:40,Modifiability,variab,variable,40,"// Add capture. The capture uses a fake variable, which doesn't correspond; // to any actual memory location. However, the initializer copy-initializes; // the lambda object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:2,Modifiability,variab,variable,2,/*variable=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Safety,Avoid,Avoid,3,"// Avoid picking up a newer decl, just because it was newer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:270,Modifiability,variab,variable,270,"// C++ [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region [...]; // exactly one declaration shall declare a class name or enumeration name; // that is not a typedef name and the other declarations shall all refer to; // the same variable, non-static data member, or enumerator, or all refer; // to functions and function templates; in this case the class name or; // enumeration name is hidden.; // C++ [basic.scope.hiding]p2:; // A class name or enumeration name can be hidden by the name of a; // variable, data member, function, or enumerator declared in the same; // scope.; // An UnresolvedUsingValueDecl always instantiates to one of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:540,Modifiability,variab,variable,540,"// C++ [basic.scope.declarative]p4:; // Given a set of declarations in a single declarative region [...]; // exactly one declaration shall declare a class name or enumeration name; // that is not a typedef name and the other declarations shall all refer to; // the same variable, non-static data member, or enumerator, or all refer; // to functions and function templates; in this case the class name or; // enumeration name is hidden.; // C++ [basic.scope.hiding]p2:; // A class name or enumeration name can be hidden by the name of a; // variable, data member, function, or enumerator declared in the same; // scope.; // An UnresolvedUsingValueDecl always instantiates to one of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:48,Availability,avail,available,48,// Bail out if there is an argument that has no available types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,Availability,avail,available,45,// Ignore this builtin function if it is not available in the currently; // selected language version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:198,Availability,avail,available,198,"// Ignore this builtin function if it carries an extension macro that is; // not defined. This indicates that the extension is not supported by the; // target, so the builtin function should not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Security,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:127,Availability,error,error,127,"// In C++ and OpenCL (spec v1.2 s6.9.f), we don't have any predefined; // library functions like 'malloc'. Instead, we'll just error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform lookup into this declaration context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:14,Performance,perform,performing,14,"// When we're performing lookup for the purposes of redeclaration, just; // add the conversion function template. When we deduce template; // arguments for specializations, we'll end up unifying the return; // type of the new declaration with the type of the function template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:330,Performance,perform,perform,330,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:467,Performance,perform,perform,467,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:434,Safety,avoid,avoid,434,"// C++ [temp.mem]p6:; // [...] For each such operator, if argument deduction succeeds; // (14.9.2.3), the resulting specialization is used as if found by; // name lookup.; //; // When referencing a conversion function for any purpose other than; // a redeclaration (such that we'll be building an expression with the; // result), perform template argument deduction and place the; // specialization into the result set. We do this to avoid forcing all; // callers to perform special deduction for conversion functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction against the type that we would; // expect the function to have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Performs,3,// Performs C++ unqualified lookup into the given file context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform direct name lookup into the LookupCtx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform direct name lookup into the namespaces nominated by the; // using directives whose common ancestor is this namespace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:8,Performance,perform,performing,8,"// When performing a scope lookup, we want to find local extern decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:88,Modifiability,variab,variables,88,"// We do not look directly into function or method contexts,; // since all of the local variables and parameters of the; // function/method are present within the Scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Integrability,interface,interface,86,"// If we have an Objective-C instance method, look for ivars; // in the corresponding interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Performance,perform,perform,41,"// If this is a file context, we need to perform unqualified name; // lookup considering using directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,"// Perform qualified name lookup into this context.; // FIXME: In some cases, we know that every name that could be found by; // this qualified name lookup will also be on the identifier chain. For; // example, inside a class without any base classes, we never need to; // perform qualified lookup because all of the members are on top of the; // identifier chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:273,Performance,perform,perform,273,"// Perform qualified name lookup into this context.; // FIXME: In some cases, we know that every name that could be found by; // this qualified name lookup will also be on the identifier chain. For; // example, inside a class without any base classes, we never need to; // perform qualified lookup because all of the members are on top of the; // identifier chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:133,Performance,Cache,Cache,133,"// Collect UsingDirectiveDecls in all scopes, and recursively all; // nominated namespaces by those using-directives.; //; // FIXME: Cache this sorted list in Scope structure, and DeclContext, so we; // don't build it for each lookup!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:16,Performance,perform,performing,16,"// If we're not performing redeclaration lookup, do not look for local; // extern declarations outside of a function scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:24,Performance,cache,cached,24,// Return quickly if we cached the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Usability,usab,usable,91,// If M is the global module fragment of the current translation unit. So it; // should be usable.; // [module.global.frag]p1:; // The global module fragment can be used to provide declarations that are; // attached to the global module and usable within the module unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:241,Usability,usab,usable,241,// If M is the global module fragment of the current translation unit. So it; // should be usable.; // [module.global.frag]p1:; // The global module fragment can be used to provide declarations that are; // attached to the global module and usable within the module unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:430,Safety,avoid,avoid,430,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Usability,usab,usable,50,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:134,Usability,usab,usable,134,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:83,Usability,usab,usable,83,// The module unit which is in the same module with the current module; // unit is usable.; //; // FIXME: Here we judge if they are in the same module by comparing the; // string. Is there any better solution?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:81,Integrability,rout,routine,81,"/// Determine whether a declaration is acceptable to name lookup.; ///; /// This routine determines whether the declaration D is acceptable in the; /// current lookup context, taking into account the current template; /// instantiation stack. During template instantiation, a declaration is; /// acceptable if it is acceptable from a module containing any entity on the; /// template instantiation path (by instantiating a template, you allow it to; /// see the declarations that your module can see, including those later on in; /// your module).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Cache,Cache,3,// Cache the fact that this declaration is implicitly visible because; // its parent has a visible definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Integrability,interface,interface,52,// FIXME: Return false directly if we don't have an interface dependency on the; // translation unit containing D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:62,Integrability,depend,dependency,62,// FIXME: Return false directly if we don't have an interface dependency on the; // translation unit containing D.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:107,Integrability,interface,interface,107,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:176,Integrability,interface,interface,176,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:186,Integrability,depend,dependency,186,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:353,Integrability,interface,interface,353,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:363,Integrability,depend,dependency,363,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:498,Integrability,interface,interface,498,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:508,Integrability,depend,dependency,508,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:557,Integrability,interface,interface,557,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:567,Integrability,depend,dependency,567,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:696,Integrability,interface,interface,696,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:744,Integrability,interface,interface,744,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:754,Integrability,depend,dependency,754,"// [module.reach]/p1; // A translation unit U is necessarily reachable from a point P if U is a; // module interface unit on which the translation unit containing P has an; // interface dependency, or the translation unit containing P imports U, in; // either case prior to P ([module.import]).; //; // [module.import]/p10; // A translation unit has an interface dependency on a translation unit U if; // it contains a declaration (possibly a module-declaration) that imports U; // or if it has an interface dependency on a translation unit that has an; // interface dependency on U.; //; // So we could conclude the module unit U is necessarily reachable if:; // (1) The module unit U is module interface unit.; // (2) The current unit has an interface dependency on the module unit U.; //; // Here we only check for the first condition. Since we couldn't see; // DeclModule if it isn't (transitively) imported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:103,Integrability,interface,interface,103,"// [module.reach]/p2; // Additional translation units on; // which the point within the program has an interface dependency may be; // considered reachable, but it is unspecified which are and under what; // circumstances.; //; // The decision here is to treat all additional tranditional units as; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:113,Integrability,depend,dependency,113,"// [module.reach]/p2; // Additional translation units on; // which the point within the program has an interface dependency may be; // considered reachable, but it is unspecified which are and under what; // circumstances.; //; // The decision here is to treat all additional tranditional units as; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:481,Safety,safe,safe,481,"// This function is called once ""New"" is essentially complete, but before a; // previous declaration is attached. We can't query the linkage of ""New"" in; // general, because attaching the previous declaration can change the; // linkage of New to match the previous declaration.; //; // However, because we've just determined that there is no *visible* prior; // declaration, we can compute the linkage here. There are two possibilities:; //; // * This is not a redeclaration; it's safe to compute the linkage now.; //; // * This is a redeclaration of a prior declaration that is externally; // redeclarable. In that case, the linkage of the declaration is not; // changed by attaching the prior declaration, because both are externally; // declarable (and thus ExternalLinkage or VisibleNoLinkage).; //; // FIXME: This is subtle and fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:80,Integrability,rout,routine,80,"/// Retrieve the visible declaration corresponding to D, if any.; ///; /// This routine determines whether the declaration D is visible in the current; /// module, with the current imports. If not, it checks whether any; /// redeclaration of D is visible, and if so, returns that declaration.; ///; /// \returns D, or a visible previous declaration of D, whichever is more recent; /// and visible. If no declaration of D is visible, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:13,Usability,guid,guide,13,"// Deduction guide lives in namespace scope generally, but it is just a; // hint to the compilers. What we actually lookup for is the generated member; // of the corresponding template. So it is sufficient to check the; // reachability of the template decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:474,Availability,down,downside,474,// FIXME: The lookup for allocation function is a standalone process.; // (We can find the logics in Sema::FindAllocationFunctions); //; // Such structure makes it a problem when we instantiate a template; // declaration using placement allocation function if the placement; // allocation function is invisible.; // (See https://github.com/llvm/llvm-project/issues/59601); //; // Here we workaround it by making the placement allocation functions; // always acceptable. The downside is that we can't diagnose the direct; // use of the invisible placement allocation functions. (Although such uses; // should be rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Testability,log,logics,91,// FIXME: The lookup for allocation function is a standalone process.; // (We can find the logics in Sema::FindAllocationFunctions); //; // Such structure makes it a problem when we instantiate a template; // declaration using placement allocation function if the placement; // allocation function is invisible.; // (See https://github.com/llvm/llvm-project/issues/59601); //; // Here we workaround it by making the placement allocation functions; // always acceptable. The downside is that we can't diagnose the direct; // use of the invisible placement allocation functions. (Although such uses; // should be rare).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:376,Availability,Error,Error,376,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:425,Availability,error,error,425,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:550,Availability,error,error,550,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:11,Integrability,interface,interface,11,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:739,Integrability,interface,interface,739,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:343,Testability,test,test,343,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:716,Testability,test,test,716,"// [module.interface]p7; // Class and enumeration member names can be found by name lookup in any; // context in which a definition of the type is reachable.; //; // FIXME: The current implementation didn't consider about scope. For example,; // ```; // // m.cppm; // export module m;; // enum E1 { e1 };; // // Use.cpp; // import m;; // void test() {; // auto a = E1::e1; // Error as expected.; // auto b = e1; // Should be error. namespace-scope name e1 is not visible; // }; // ```; // For the above example, the current implementation would emit error for `a`; // correctly. However, the implementation wouldn't diagnose about `b` now.; // Since we only check the reachability for the parent only.; // See clang/test/CXX/module/module.interface/p7.cpp for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:950,Deployability,update,updated,950,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:881,Performance,perform,perform,881,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:8,Performance,perform,performing,8,"// When performing a scope lookup, we want to find local extern decls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Performance,perform,perform,91,"// If the scope containing the declaration is the translation unit,; // then we'll need to perform our checks based on the matching; // DeclContexts rather than matching scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform C++ unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Security,inject,injecting,156,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:129,Availability,failure,failures,129,"// If we didn't find a use of this identifier, the ExternalSource; // may be able to handle the situation.; // Note: some lookup failures are expected!; // See e.g. R.isForRedeclaration().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform qualified name lookup in the namespaces nominated by; /// using directives by the given context.; ///; /// C++98 [namespace.qual]p2:; /// Given X::m (where X is a user-declared namespace), or given \::m; /// (where X is the global namespace), let S be the set of all; /// declarations of m in X and in the transitive closure of all; /// namespaces nominated by using-directives in X and its used; /// namespaces, except that using-directives are ignored in any; /// namespace, including X, directly containing one or more; /// declarations of m. No namespace is searched more than once in; /// the lookup of a name. If S is the empty set, the program is; /// ill-formed. Otherwise, if S has exactly one member, or if the; /// context of the reference is a using-declaration; /// (namespace.udecl), S is the required set of declarations of; /// m. Otherwise if the use of m is not one that allows a unique; /// declaration to be chosen from S, the program is ill-formed.; ///; /// C++98 [namespace.qual]p5:; /// During the lookup of a qualified namespace member name, if the; /// lookup finds more than one declaration of the member, and if one; /// declaration introduces a class name or enumeration name and the; /// other declarations either introduce the same object, the same; /// enumerator or a set of functions, the non-type name hides the; /// class or enumeration name if and only if the declarations are; /// from the same namespace; otherwise (the declarations are from; /// different namespaces), the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:99,Performance,queue,queue,99,"// We have not yet looked into these namespaces, much less added; // their ""using-children"" to the queue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Performance,queue,queue,52,// We have at least added all these contexts to the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:63,Performance,queue,queue,63,// We have already looked into the initial namespace; seed the queue; // with its using-children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:43,Safety,avoid,avoid,43,// We go through some convolutions here to avoid copying results; // between LookupResults.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,"/// Perform qualified name lookup into a given context.; ///; /// Qualified name lookup (C++ [basic.lookup.qual]) is used to find; /// names when the context of those names is explicit specified, e.g.,; /// ""std::vector"" or ""x->member"", or as part of unqualified name lookup.; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search. If the lookup criteria permits, name lookup may also search; /// in the parent contexts or (for C++ classes) base classes.; ///; /// \param InUnqualifiedLookup true if this is qualified name lookup that; /// occurs as part of unqualified name lookup.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:283,Availability,avail,available,283,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,Integrability,depend,dependent,52,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:151,Integrability,depend,dependent,151,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:12,Performance,perform,performing,12,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform lookup into our base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Integrability,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:202,Integrability,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,Security,inject,injected-class-name,50,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:202,Security,inject,injected-class-names,202,"// C++ [temp.local]p3:; // A lookup that finds an injected-class-name (10.2) can result in; // an ambiguity in certain cases (for example, if it is found in; // more than one base class). If all of the injected-class-names; // that are found refer to specializations of the same class; // template, and if the name is used as a template-name, the; // reference refers to the class template itself and not a; // specialization thereof, and is not ambiguous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Integrability,inject,injected-class-names,65,// C++ [class.member.lookup]p3:; // type declarations (including injected-class-names) are replaced by; // the types they designate,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Security,inject,injected-class-names,65,// C++ [class.member.lookup]p3:; // type declarations (including injected-class-names) are replaced by; // the types they designate,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:128,Energy Efficiency,efficient,efficiently,128,// We'll often find the declarations are in the same order. Handle this; // case (and the special case of only one declaration) efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:64,Security,access,access,64,// Pick the best (i.e. most permissive i.e. numerically lowest) access; // across all paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:144,Security,access,access,144,// FIXME: This language rule no longer exists. Checking for ambiguous base; // subobjects should be done as part of formation of a class member access; // expression (when converting the object parameter to the member's type).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:114,Integrability,rout,routine,114,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Performs,4,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:199,Performance,perform,perform,199,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:131,Integrability,rout,routine,131,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,Integrability,rout,routine,156,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Performs,4,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:295,Performance,perform,perform,295,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:469,Performance,perform,perform,469,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:89,Performance,perform,perform,89,"// We have resolved the scope specifier to a particular declaration; // contex, and will perform name lookup in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,// Perform unqualified name lookup starting in the given scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,/// Perform qualified name lookup into all base classes of the given; /// class.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param Class The context in which qualified name lookup will; /// search. Name lookup will search in all base classes merging the results.; ///; /// @returns True if any decls were found (but possibly ambiguous),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Security,access,access-control,7,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:214,Security,access,access,214,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:234,Security,access,access,234,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:63,Security,access,access,63,"// Copy the lookup results into the target, merging the base's access into; // the path access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:88,Security,access,access,88,"// Copy the lookup results into the target, merging the base's access into; // the path access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Availability,recover,recovery,7,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,Safety,recover,recovery,7,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:58,Integrability,depend,dependent,58,// Add the associated classes and namespaces for argument-dependent; // lookup that involves a template argument (C++ [basic.lookup.argdep]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:58,Integrability,depend,dependent,58,// Add the associated classes and namespaces for argument-dependent lookup; // with an argument of class type (C++ [basic.lookup.argdep]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:6,Integrability,depend,dependent,6,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:99,Integrability,depend,dependent,99,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:387,Integrability,depend,dependent,387,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:185,Usability,simpl,simply,185,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:62,Integrability,depend,dependent,62,// Add the associated classes and namespaces for; // argument-dependent lookup with an argument of type T; // (C++ [basic.lookup.koenig]p2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,Integrability,depend,dependent,38,"// T is canonical. We can also ignore dependent types because; // we don't need to do ADL at the definition point, but if we; // wanted to implement template export (or if we find some other; // use for associated classes and namespaces...) this would be; // wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Queue,Queue,3,// Queue up the class type into which this points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:44,Availability,error,error,44,// Non-deduced auto types only get here for error cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:36,Integrability,interface,interface,36,"// If T is an Objective-C object or interface type, or a pointer to an; // object or interface type, the associated namespace is the global; // namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:85,Integrability,interface,interface,85,"// If T is an Objective-C object or interface type, or a pointer to an; // object or interface type, the associated namespace is the global; // namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:25,Integrability,wrap,wrappers,25,// Atomic types are just wrappers; use the associations of the; // contained type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:65,Integrability,depend,dependent,65,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:146,Integrability,rout,routine,146,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:246,Integrability,depend,dependent,246,/// Find the associated classes and namespaces for; /// argument-dependent lookup for a call with the given set of; /// arguments.; ///; /// This routine computes the sets of associated classes and associated; /// namespaces searched by argument-dependent lookup; /// (C++ [basic.lookup.argdep]) for a given set of arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:374,Integrability,depend,dependent,374,"// [...] In addition, if the argument is the name or address of a; // set of overloaded functions and/or function templates, its; // associated classes and namespaces are the union of those; // associated with each of the members of the set: the namespace; // in which the function or function template is defined and the; // classes and namespaces associated with its (non-dependent); // parameter types and return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:13,Integrability,protocol,protocol,13,"/// Find the protocol with the given name, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:20,Performance,cache,cached,20,// This was already cached,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Performance,perform,perform,10,// Now we perform lookup on the name we computed earlier and do overload; // resolution. Lookup is only performed directly into the class since there; // will always be a (possibly implicit) declaration to shadow any others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:104,Performance,perform,performed,104,// Now we perform lookup on the name we computed earlier and do overload; // resolution. Lookup is only performed directly into the class since there; // will always be a (possibly implicit) declaration to shadow any others.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:53,Performance,load,load,53,// Copy the candidates as our processing of them may load new declarations; // from an external source and invalidate lookup_result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:89,Integrability,rout,routine,89,"/// Look for the destructor of the given class.; ///; /// During semantic analysis, this routine should be used in lieu of; /// CXXRecordDecl::getDestructor().; ///; /// \returns The destructor for this class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:152,Integrability,depend,dependent,152,"// C++ [basic.lookup.argdep]p3:; // Let X be the lookup set produced by unqualified lookup (3.4.1); // and let Y be the lookup set produced by argument dependent; // lookup (defined as follows). If X contains [...] then Y is; // empty. Otherwise Y is the set of declarations found in the; // namespaces associated with the argument types as described; // below. The set of declarations found by the lookup of the name; // is the union of X and Y.; //; // Here, we compute Y and add its members to the overloaded; // candidate set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Performance,perform,performed,86,"// When considering an associated namespace, the lookup is the; // same as the lookup performed when the associated namespace is; // used as a qualifier (3.4.3.2) except that:; //; // -- Any using-directives in the associated namespace are; // ignored.; //; // -- Any namespace-scope friend functions declared in; // associated classes are visible within their respective; // namespaces even if they are not visible during an ordinary; // lookup (11.4).; //; // C++20 [basic.lookup.argdep] p4.3; // -- are exported, are attached to a named module M, do not appear; // in the translation unit containing the point of the lookup, and; // have the same innermost enclosing non-inline namespace scope as; // a declaration of an associated entity attached to M.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:42,Integrability,depend,dependent,42,// The declaration is visible to argument-dependent lookup if either; // it's ordinarily visible or declared as a friend in an associated; // class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:29,Performance,cache,cached,29,// TODO: maybe this could be cached when generating the; // associated namespaces / entities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Integrability,depend,dependent,41,"// [basic.lookup.argdep]p4:; // Argument-dependent lookup finds all declarations of functions and; // function templates that; // - ...; // - are declared as a friend ([class.friend]) of any class with a; // reachable definition in the set of associated entities,; //; // FIXME: If there's a merged definition of D that is reachable, then; // the friend declaration should be considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Performance,optimiz,optimized,41,"/// An entry in the shadow map, which is optimized to store a; /// single declaration (the common case) but can also store a list; /// of declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Integrability,Protocol,Protocols,3,// Protocols are in distinct namespaces from everything else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,Availability,avail,available,41,// Determine the set of using directives available during; // unqualified name lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:21,Performance,load,loading,21,// We sometimes skip loading namespace-level results (they tend to be huge).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:28,Modifiability,inherit,inherited,28,// Traverse the contexts of inherited C++ classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:19,Integrability,depend,dependent,19,"// Don't look into dependent bases, because name lookup can't look; // there anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:263,Security,access,accessing,263,"// FIXME: It would be nice to be able to determine whether referencing; // a particular member would be ambiguous. For example, given; //; // struct A { int member; };; // struct B { int member; };; // struct C : A, B { };; //; // void f(C *c) { c->### }; //; // accessing 'member' would result in an ambiguity. However, we; // could be smart enough to qualify the member with the base; // class, e.g.,; //; // c->B::member; //; // or; //; // c->A::member; // Find results in this base class (and its bases).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:12,Integrability,protocol,protocols,12,// Traverse protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:66,Testability,test,tests,66,// No clients run in this mode and it's not supported. Please add tests and; // remove the assertion if you start relying on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,Testability,assert,assertion,91,// No clients run in this mode and it's not supported. Please add tests and; // remove the assertion if you start relying on it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:56,Integrability,interface,interface,56,"// For instance methods, look for ivars in the method's interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:17,Performance,perform,performed,17,// We've already performed all of the name lookup that we need; // to for Objective-C methods; the next context will be the; // outer scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:175,Performance,load,loaded,175,"// Look into the translation unit scope. We walk through the translation; // unit's declaration context, because the Scope itself won't have all of; // the declarations if we loaded a precompiled header.; // FIXME: We would like the translation unit's Scope object to point to; // the translation unit, so we don't need this special ""if"" branch.; // However, doing so would force the normal C++ name-lookup code to look; // into the translation unit decl when the IdentifierInfo chains would; // suffice. Once we fix that problem (which is part of a more general; // ""don't look in DeclContexts unless we have to"" optimization), we can; // eliminate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:614,Performance,optimiz,optimization,614,"// Look into the translation unit scope. We walk through the translation; // unit's declaration context, because the Scope itself won't have all of; // the declarations if we loaded a precompiled header.; // FIXME: We would like the translation unit's Scope object to point to; // the translation unit, so we don't need this special ""if"" branch.; // However, doing so would force the normal C++ name-lookup code to look; // into the translation unit decl when the IdentifierInfo chains would; // suffice. Once we fix that problem (which is part of a more general; // ""don't look in DeclContexts unless we have to"" optimization), we can; // eliminate this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:9,Usability,simpl,simple,9,"// Use a simple length-based heuristic to determine the minimum possible; // edit distance. If the minimum isn't good enough, bail out early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:194,Performance,perform,performing,194,"// Reset the callback distance; // If the current correction candidate and namespace combination are; // too far away from the original typo based on the normalized edit; // distance, then skip performing a qualified name lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:39,Security,validat,validated,39,// Any corrections added below will be validated in subsequent; // iterations of the main while() loop over the Consumer's contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Performance,Perform,Perform,4,/// Perform name lookup for a possible result for typo correction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,Integrability,depend,dependent,86,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:152,Integrability,depend,dependent,152,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:28,Performance,perform,perform,28,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Safety,Abort,Abort,3,// Abort if typo correction already failed for this specific typo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:117,Performance,perform,performance,117,"// Provide a stop gap for files that are just seriously broken. Trying; // to correct all typos can turn into a HUGE performance penalty, causing; // some files to take minutes to get rejected by the parser.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,Availability,error,error,38,"// If we're handling a missing symbol error, using modules, and the; // special search all modules option is used, look for a missing import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:40,Performance,load,loading,40,// The following has the side effect of loading the missing module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:233,Energy Efficiency,allocate,allocated,233,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Modifiability,Extend,Extend,3,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:197,Modifiability,polymorphi,polymorphic,197,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:74,Safety,avoid,avoid,74,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Perform,Perform,3,"// Perform name lookup to find visible, similarly-named entities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:21,Integrability,interface,interfaces,21,// Look in qualified interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:3,Performance,Load,Load,3,// Load any externally-known namespaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1083,Integrability,protocol,protocols,1083,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1110,Integrability,interface,interfaces,1110,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:644,Security,validat,validation,644,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:852,Security,access,access,852,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1362,Security,access,access,1362,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a \c TypoCorrection containing the corrected name if the typo; /// along with information such as the \c NamedDecl where the corrected name; /// was declared, and any additional \c NestedNameSpecifier needed to access; /// it (C++ only). The \c TypoCorrection is empty if there is no correction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,Integrability,message,message-receiver,45,// Prefer 'super' when we're completing in a message-receiver; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:14,Availability,failure,failure,14,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:208,Availability,failure,failure,208,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:198,Performance,cache,cache,198,"// Record the failure's location if needed and return an empty correction. If; // this was an unqualified lookup and we believe the callback object did not; // filter out possible corrections, also cache the failure for the typo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1354,Integrability,protocol,protocols,1354,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1381,Integrability,interface,interfaces,1381,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1524,Performance,perform,performing,1524,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:644,Security,validat,validation,644,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1123,Security,access,access,1123,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Availability,recover,recover,10,// Try to recover by implicitly importing this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,Safety,recover,recover,10,// Try to recover by implicitly importing this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:502,Availability,Error,ErrorRecovery,502,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:570,Availability,recover,recover,570,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:674,Availability,error,error,674,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:177,Performance,perform,performing,177,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:570,Safety,recover,recover,570,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:104,Security,validat,validation,104,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:102,Security,access,access,102,"// We represent the primary and partition names as 'Paths' which are sections; // of the hierarchical access path for a clang module. However for C++20; // the periods in a name are just another character, and we will need to; // flatten them into a string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:241,Usability,usab,usable,241,// [module.global.frag]p2; // A global-module-fragment specifies the contents of the global module; // fragment for a module unit. The global module fragment can be used to; // provide declarations that are attached to the global module and usable; // within the module unit.; //; // So the declations in the global module shouldn't be visible by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:19,Availability,error,error,19,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:25,Availability,recover,recovery,25,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:25,Safety,recover,recovery,25,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:4,Testability,Test,Tests,4,/// Tests whether the given identifier is reserved as a module name and; /// diagnoses if it is. Returns true if a diagnostic is emitted and false; /// otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:149,Integrability,interface,interface,149,"// A (non-partition) module implementation unit requires that we are not; // compiling a module of any kind. A partition implementation emits an; // interface (and the AST for the implementation), which will subsequently; // be consumed to emit a binary.; // A module interface unit requires that we are not compiling a module map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:268,Integrability,interface,interface,268,"// A (non-partition) module implementation unit requires that we are not; // compiling a module of any kind. A partition implementation emits an; // interface (and the AST for the implementation), which will subsequently; // be consumed to emit a binary.; // A module interface unit requires that we are not compiling a module map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:31,Integrability,interface,interface,31,// It's OK to compile a module interface as a normal translation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:37,Integrability,interface,interface,37,// We were asked to compile a module interface unit but this is a module; // implementation unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:402,Testability,Test,Test,402,// C++23 [module.unit]p1: ... The identifiers module and import shall not; // appear as identifiers in a module-name or module-partition. All; // module-names either beginning with an identifier consisting of std; // followed by zero or more digits or containing a reserved identifier; // ([lex.name]) are reserved and shall not be specified in a; // module-declaration; no diagnostic is required.; // Test the first part of the path to see if it's std[0-9]+ but allow the; // name in a system header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:8,Testability,test,test,8,// Then test all of the components in the path to see if any of them are; // using another kind of reserved or invalid identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:7,Integrability,interface,interface,7,// The interface for an implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:140,Integrability,interface,interface,140,// C++20 A module-declaration that contains neither an export-; // keyword nor a module-partition implicitly imports the primary; // module interface unit of the module as if by a module-import-; // declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:14,Performance,load,loader,14,// The module loader will assume we're trying to import the module that; // we're building if `LangOpts.CurrentModule` equals to 'ModuleName'.; // Change the value for `LangOpts.CurrentModule` temporarily to make the; // module loader work properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:228,Performance,load,loader,228,// The module loader will assume we're trying to import the module that; // we're building if `LangOpts.CurrentModule` equals to 'ModuleName'.; // Change the value for `LangOpts.CurrentModule` temporarily to make the; // module loader work properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:45,Availability,error,error,45,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:51,Availability,recover,recovery,51,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:26,Integrability,interface,interface,26,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:51,Safety,recover,recovery,51,// Create an empty module interface unit for error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:13,Integrability,interface,interface,13,"// Create an interface, but note that it is an implementation; // unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:113,Integrability,interface,interface,113,// We already potentially made an implicit import (in the case of a module; // implementation unit importing its interface). Make this module visible; // and return the import decl to be added to the current TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:32,Integrability,interface,interface,32,// Make the import decl for the interface in the impl module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:87,Integrability,interface,interface,87,// As if we imported it.; // Also save this as a shortcut to checking for decls in the interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:47,Integrability,interface,interface,47,"// If we made an implicit import of the module interface, then return the; // imported module decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:97,Integrability,interface,interface,97,// C++20 [basic.link]/2:; // A private-module-fragment shall appear only in a primary module; // interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:156,Integrability,interface,interface,156,// All declarations created from now on are scoped to the private module; // fragment (and are neither visible nor reachable in importers of the module; // interface).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:253,Integrability,interface,interface,253,"// Diagnose self-import before attempting a load.; // [module.import]/9; // A module implementation unit of a module M that is not a module partition; // shall not contain a module-import-declaration nominating M.; // (for an implementation, the module interface is imported implicitly,; // but that's handled in the module decl code).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:44,Performance,load,load,44,"// Diagnose self-import before attempting a load.; // [module.import]/9; // A module implementation unit of a module M that is not a module partition; // shall not contain a module-import-declaration nominating M.; // (for an implementation, the module interface is imported implicitly,; // but that's handled in the module decl code).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:201,Availability,error,error,201,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:284,Availability,redundant,redundant,284,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:284,Safety,redund,redundant,284,"//checkModuleImportContext(*this, Mod, ImportLoc, CurContext);; // FIXME: we should support importing a submodule within a different submodule; // of the same top-level module. Until we do, make it an error rather than; // silently ignoring the import.; // FIXME: Should we warn on a redundant import of the current module?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:11,Integrability,interface,interface,11,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope and appear in the; // purview of a module interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:125,Integrability,interface,interface,125,// [module.interface]p1:; // An export-declaration shall inhabit a namespace scope and appear in the; // purview of a module interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:68,Performance,cache,cache,68,"// Leaving a module hides namespace names, so our visible namespace cache; // is now out of date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++2a [module.interface]p1:; // An export-declaration shall appear only [...] in the purview of a module; // interface unit. An export-declaration shall not appear directly or; // indirectly within [...] a private-module-fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:112,Integrability,interface,interface,112,// C++2a [module.interface]p1:; // An export-declaration shall appear only [...] in the purview of a module; // interface unit. An export-declaration shall not appear directly or; // indirectly within [...] a private-module-fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:189,Safety,avoid,avoid,189,"// A declaration is exported if it is [...] a namespace-definition; // that contains an exported declaration.; //; // Defer exporting the namespace until after we leave it, in order to; // avoid marking all subsequent declarations in the namespace as exported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++20 [module.interface]p3:; // [...] it shall not declare a name with internal linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:17,Integrability,interface,interface,17,// C++2a [module.interface]p5:; // all entities to which all of the using-declarators ultimately refer; // shall have been introduced with a name having external linkage,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:47,Modifiability,variab,variable,47,"// [dcl.inline]/7; // If an inline function or variable that is attached to a named module; // is declared in a definition domain, it shall be defined in that; // domain.; // So, if the current declaration does not have a definition, we must; // check at the end of the TU (or when the PMF starts) to see that we; // have a definition at that point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:82,Integrability,protocol,protocol,82,/// Check this Objective-C property against a property declared in the; /// given protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:21,Integrability,protocol,protocol,21,// Have we seen this protocol before?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:35,Integrability,protocol,protocols,35,// Check this property against any protocols we inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:48,Modifiability,inherit,inherit,48,// Check this property against any protocols we inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:3,Security,Validat,Validate,3,// Validate the attributes on the @property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:55,Integrability,protocol,protocols,55,// Also compare the property against a property in our protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,protocol,protocols,28,// Slower path: look in all protocols we referenced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,interface,interface,27,// We need to look in the @interface to see if the @property was; // already declared.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Modifiability,extend,extended,28,// Find the property in the extended class's primary class or; // extensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:148,Availability,error,error,148,// A readonly property declared in the primary class can be refined; // by adding a readwrite property within an extension.; // Anything else is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:155,Availability,error,error,155,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:102,Integrability,interface,interface,102,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:250,Safety,safe,safe,250,// Relax the strict type matching for property type in continuation class.; // Allow property object type of continuation class to be different as long; // as it narrows the object type in its primary class property. Note that; // this conversion is safe only because the wider type is for a 'readonly'; // property in primary class and 'narrowed' type for a 'readwrite' property; // in continuation class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:113,Integrability,protocol,protocol,113,"// Issue a warning if property is 'assign' as default and its; // object, which is gc'able conforms to NSCopying protocol",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:63,Integrability,rout,routine,63,"/// setImpliedPropertyAttributeForReadOnlyProperty -; /// This routine evaludates life-time attributes for a 'readonly'; /// property with no known lifetime of its own, using backing; /// 'ivar's attribute, if any. If no backing 'ivar', property's; /// life-time is assumed 'strong'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:155,Integrability,protocol,protocols,155,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:217,Integrability,protocol,protocols,217,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:140,Modifiability,inherit,inherited,140,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:207,Modifiability,inherit,inherited,207,"/// SelectPropertyForSynthesisFromProtocols - Finds the most appropriate; /// property declaration that should be synthesised in all of the inherited; /// protocols. It also diagnoses properties declared in inherited protocols with; /// mismatched types or attributes, since any of them can be candidate for; /// synthesis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,Integrability,protocol,protocol,38,// Represents a property from another protocol that conflicts with the; // selected declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:29,Availability,error,error,29,// Promote the warning to an error if there are incompatible attributes or; // incompatible types together with readwrite/readonly incompatibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,protocol,protocols,27,// Look through all of the protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:34,Security,access,accessor,34,/// Create a synthesized property accessor stub inside the \@implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:43,Testability,stub,stub,43,/// Create a synthesized property accessor stub inside the \@implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:33,Integrability,rout,routine,33,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:41,Performance,perform,performs,41,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,interface,interface,27,"// We always synthesize an interface for an implementation; // without an interface decl. So, IDecl is always non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:74,Integrability,interface,interface,74,"// We always synthesize an interface for an implementation; // without an interface decl. So, IDecl is always non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:64,Integrability,interface,interface,64,// Look for this property declaration in the @implementation's @interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:59,Availability,error,error,59,"// If category for this implementation not found, it is an error which; // has already been reported eralier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:62,Integrability,interface,interface,62,// Check that this is a previously declared 'ivar' in 'IDecl' interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:11,Availability,error,error,11,// It's an error if we have to do this and the user didn't; // explicitly write an ownership attribute on the property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Safety,avoid,avoid,96,"// Note! I deliberately want it to fall thru so, we have a; // a property implementation and to avoid future warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:53,Availability,error,errors,53,// Note! I deliberately want it to fall thru so more errors are caught.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Safety,avoid,avoid,96,"// Note! I deliberately want it to fall thru so, we have a; // a property implementation and to avoid future warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,Integrability,rout,routine,96,// FIXME! Rules for properties are somewhat different that those; // for assignments. Use a new routine to consolidate all cases;; // specifically for property redeclarations as well as for ivars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,protocol,protocols,28,"// Readonly properties from protocols can be implemented as ""readwrite""; // with a custom setter name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,Integrability,rout,routine,38,/// CollectImmediateProperties - This routine collects all properties in; /// the class and its conforming protocols; but not those in its super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:107,Integrability,protocol,protocols,107,/// CollectImmediateProperties - This routine collects all properties in; /// the class and its conforming protocols; but not those in its super class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,// Scan through class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,// Scan through class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,Integrability,protocol,protocols,24,"// Exclude property for protocols which conform to class's super-class,; // as super-class has to implement the property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:52,Integrability,rout,routine,52,/// CollectSuperClassPropertyImplementations - This routine collects list of; /// properties to be implemented in super class(s) and also coming from their; /// conforming protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:172,Integrability,protocol,protocols,172,/// CollectSuperClassPropertyImplementations - This routine collects list of; /// properties to be implemented in super class(s) and also coming from their; /// conforming protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:42,Integrability,rout,routine,42,/// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is; /// an ivar synthesized for 'Method' and 'Method' is a property accessor; /// declared in class 'IFace'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:141,Security,access,accessor,141,/// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is; /// an ivar synthesized for 'Method' and 'Method' is a property accessor; /// declared in class 'IFace'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,Security,access,accessors,51,// look up a property declaration whose one of its accessors is implemented; // by this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:77,Security,access,accessors,77,// Also look up property declaration in class extension whose one of its; // accessors is implemented by this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,Integrability,protocol,protocols,51,"// We won't auto-synthesize properties declared in protocols.; // Suppress the warning if class's superclass implements property's; // getter and implements property's setter (if readwrite property).; // Or, if property is going to be implemented in its super class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:153,Integrability,protocol,protocol,153,"// When reporting on missing property setter/getter implementation in; // categories, do not report when they are declared in primary class,; // class's protocol, or one of it super classes. This is because,; // the class is going to implement them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:13,Integrability,interface,interface,13,"// Scan the @interface to see if any of the protocols it adopts; // require an explicit implementation, via attribute; // 'objc_protocol_requires_explicit_implementation'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:44,Integrability,protocol,protocols,44,"// Scan the @interface to see if any of the protocols it adopts; // require an explicit implementation, via attribute; // 'objc_protocol_requires_explicit_implementation'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:56,Integrability,interface,interface,56,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:284,Integrability,protocol,protocols,284,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:323,Integrability,protocol,protocols,323,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:20,Security,access,accessors,20,// Collect property accessors implemented in current implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:208,Deployability,update,update,208,/// ProcessPropertyDecl - Make sure that any user-defined setter/getter methods; /// have the property type and issue diagnostics if they don't.; /// Also synthesize a getter/setter method if none exist (and update the; /// appropriate lookup tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:16,Security,access,accessors,16,// synthesizing accessors must not result in a direct method that is not; // monomorphic,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:156,Integrability,interface,interface,156,"// Add any synthesized methods to the global pool. This allows us to; // handle the following, which is supported by GCC (and part of the design).; //; // @interface Foo; // @property double bar;; // @end; //; // void thisIsUnfortunate() {; // id foo;; // double bar = [foo bar];; // }; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:85,Modifiability,inherit,inherited,85,// Don't issue warning on property with no life time in class; // extension as it is inherited from property in primary class.; // Skip this warning in gc-only mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,Integrability,depend,dependent,28,// FIXME: Implement warning dependent on NSCopying being; // implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:122,Modifiability,variab,variables,122,//===----------------------------------------------------------------------===//; // Stack of data-sharing attributes for variables; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:75,Modifiability,variab,variable,75,/// Pointer to a reference expression and a flag which shows that the; /// variable is marked as lastprivate(true) or not (false).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,Modifiability,variab,variable,61,"/// true if the attribute is applied to the pointee, not the variable; /// itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Integrability,depend,depend,12,/// Set of 'depend' clauses with 'sink|source' dependence kind. Required to; /// get the data (loop counters etc.) about enclosing loop-based construct.; /// This data is required during codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:47,Integrability,depend,dependence,47,/// Set of 'depend' clauses with 'sink|source' dependence kind. Required to; /// get the data (loop counters etc.) about enclosing loop-based construct.; /// This data is required during codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variable,12,/// Capture variable decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,Modifiability,variab,variables,20,/// true if all the variables in the target executable directives must be; /// captured by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Modifiability,variab,variable,18,/// Checks if the variable is a local for OpenMP region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:83,Testability,log,logically,83,/// RAII object to temporarily leave the scope of a directive when we want to; /// logically operate in its parent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variables,27,/// Start capturing of the variables in the loop context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variables,13,"/// true, if variables are captured, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:14,Usability,clear,clears,14,/// Marks (or clears) declaration as possibly loop counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Modifiability,variab,variable,39,"/// If 'aligned' declaration for given variable \a D was not seen yet,; /// add it and return NULL; otherwise return previous occurrence's expression; /// for diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,Modifiability,variab,variable,43,"/// If 'nontemporal' declaration for given variable \a D was not seen yet,; /// add it and return NULL; otherwise return previous occurrence's expression; /// for diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,/// Register specified variable as loop control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:48,Modifiability,variab,variable,48,/// Register specified variable as loop control variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,Modifiability,variab,variable,131,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:130,Modifiability,variab,variable,130,/// Check if the specified variable is a loop control variable for; /// parent region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,variab,variable,54,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,Modifiability,variab,variable,131,/// Check if the specified variable is a loop control variable for; /// current region.; /// \return The index of the loop control variable in the list of associated; /// for-loops (from outer to inner).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Modifiability,variab,variable,25,/// Get the loop control variable for the I-th loop (or nullptr) in; /// parent directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:92,Modifiability,variab,variable,92,/// Checks if the given \p VD declaration is actually a taskgroup reduction; /// descriptor variable at the \p Level of OpenMP regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has data-sharing attributes which; /// match specified \a CPred predicate in any directive which matches \a DPred; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has data-sharing attributes which; /// match specified \a CPred predicate in any innermost directive which; /// matches \a DPred predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,/// Checks if the specified variables has explicit data-sharing; /// attributes which match specified \a CPred predicate at the specified; /// OpenMP region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variable,28,/// Checks if the specified variable is a threadprivate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,/// Add a new iterator variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,/// Check if variable declaration is an iterator VarDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:177,Integrability,rout,routines,177,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:146,Modifiability,variab,variables,146,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:187,Integrability,rout,routines,187,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:116,Modifiability,Variab,Variables,116,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables with automatic storage duration that are declared in a scope; // inside the construct are private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Modifiability,Variab,Variables,125,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables with automatic storage duration that are declared in a scope; // inside the construct are private.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:45,Modifiability,variab,variables,45,// Explicitly specified attributes and local variables with predetermined; // attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, implicitly determined, p.1]; // In a parallel or task construct, the data-sharing attributes of these; // variables are determined by the default clause, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:207,Modifiability,variab,variables,207,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, implicitly determined, p.1]; // In a parallel or task construct, the data-sharing attributes of these; // variables are determined by the default clause, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:8,Modifiability,variab,variable,8,"// each variable with static storage duration that is declared; // in a namespace or global scope and referenced in the construct,; // and that does not have a predetermined data-sharing attribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.2]; // In a parallel construct, if no default clause is present, these; // variables are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:194,Modifiability,variab,variables,194,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.2]; // In a parallel construct, if no default clause is present, these; // variables are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.4]; // In a task construct, if no default clause is present, a variable that in; // the enclosing context is determined to be shared by all implicit tasks; // bound to the current team is shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:182,Modifiability,variab,variable,182,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.4]; // In a task construct, if no default clause is present, a variable that in; // the enclosing context is determined to be shared by all implicit tasks; // bound to the current team is shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, implicitly determined, p.6]; // In a task construct, if no default clause is present, a variable; // whose data-sharing attribute is not determined by the rules above is; // firstprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:182,Modifiability,variab,variable,182,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, implicitly determined, p.6]; // In a task construct, if no default clause is present, a variable; // whose data-sharing attribute is not determined by the rules above is; // firstprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.3]; // For constructs other than task, if no default clause is present, these; // variables inherit their data-sharing attributes from the enclosing; // context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:201,Modifiability,variab,variables,201,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.3]; // For constructs other than task, if no default clause is present, these; // variables inherit their data-sharing attributes from the enclosing; // context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:211,Modifiability,inherit,inherit,211,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, implicitly determined, p.3]; // For constructs other than task, if no default clause is present, these; // variables inherit their data-sharing attributes from the enclosing; // context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variable,12,/// Build a variable declaration for OpenMP loop iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:59,Modifiability,variab,variable,59,/// Build a variable declaration for OpenMP loop iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables appearing in threadprivate directives are threadprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Modifiability,Variab,Variables,125,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.1]; // Variables appearing in threadprivate directives are threadprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.4]; // Static data members are shared.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.7]; // Variables with static storage duration that are declared in a scope; // inside the construct are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:211,Modifiability,Variab,Variables,211,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.4]; // Static data members are shared.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.7]; // Variables with static storage duration that are declared in a scope; // inside the construct are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:283,Modifiability,Variab,Variables,283,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.4]; // Static data members are shared.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.7]; // Variables with static storage duration that are declared in a scope; // inside the construct are shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.6]; // Variables with const qualified type having no mutable member are; // shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Modifiability,Variab,Variables,125,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, predetermined, p.6]; // Variables with const qualified type having no mutable member are; // shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variables,3,"// Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:45,Modifiability,variab,variables,45,// Explicitly specified attributes and local variables with predetermined; // attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:50,Modifiability,variab,variables,50,// Check predetermined rules for the loop control variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:37,Modifiability,variab,variable,37,"// This table summarizes how a given variable should be passed to the device; // given its type and the clauses where it appears. This table is based on; // the description in OpenMP 4.5 [2.10.4, target Construct] and; // OpenMP 4.5 [2.15.5, Data-mapping Attribute Rules and Clauses].; //; // =========================================================================; // | type | defaultmap | pvt | first | is_device_ptr | map | res. |; // | |(tofrom:scalar)| | pvt | |has_dv_adr| |; // =========================================================================; // | scl | | | | - | | bycopy|; // | scl | | - | x | - | - | bycopy|; // | scl | | x | - | - | - | null |; // | scl | x | | | - | | byref |; // | scl | x | - | x | - | - | bycopy|; // | scl | x | x | - | - | - | null |; // | scl | | - | - | - | x | byref |; // | scl | x | - | - | - | x | byref |; //; // | agg | n.a. | | | - | | byref |; // | agg | n.a. | - | x | - | - | byref |; // | agg | n.a. | x | - | - | - | null |; // | agg | n.a. | - | - | - | x | byref |; // | agg | n.a. | - | - | - | x[] | byref |; //; // | ptr | n.a. | | | - | | bycopy|; // | ptr | n.a. | - | x | - | - | bycopy|; // | ptr | n.a. | x | - | - | - | null |; // | ptr | n.a. | - | - | - | x | byref |; // | ptr | n.a. | - | - | - | x[] | bycopy|; // | ptr | n.a. | - | - | x | | bycopy|; // | ptr | n.a. | - | - | x | x | bycopy|; // | ptr | n.a. | - | - | x | x[] | bycopy|; // =========================================================================; // Legend:; // scl - scalar; // ptr - pointer; // agg - aggregate; // x - applies; // - - invalid in this combination; // [] - mapped with an array section; // byref - should be mapped by reference; // byval - should be mapped by value; // null - initialize a local variable to null on the device; //; // Observations:; // - All scalar declarations that show up in a map clause have to be passed; // by reference, because they may have been mapped in the enclosing data; // environment.; // - If the scalar",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:1761,Modifiability,variab,variable,1761,"=======================================; // | type | defaultmap | pvt | first | is_device_ptr | map | res. |; // | |(tofrom:scalar)| | pvt | |has_dv_adr| |; // =========================================================================; // | scl | | | | - | | bycopy|; // | scl | | - | x | - | - | bycopy|; // | scl | | x | - | - | - | null |; // | scl | x | | | - | | byref |; // | scl | x | - | x | - | - | bycopy|; // | scl | x | x | - | - | - | null |; // | scl | | - | - | - | x | byref |; // | scl | x | - | - | - | x | byref |; //; // | agg | n.a. | | | - | | byref |; // | agg | n.a. | - | x | - | - | byref |; // | agg | n.a. | x | - | - | - | null |; // | agg | n.a. | - | - | - | x | byref |; // | agg | n.a. | - | - | - | x[] | byref |; //; // | ptr | n.a. | | | - | | bycopy|; // | ptr | n.a. | - | x | - | - | bycopy|; // | ptr | n.a. | x | - | - | - | null |; // | ptr | n.a. | - | - | - | x | byref |; // | ptr | n.a. | - | - | - | x[] | bycopy|; // | ptr | n.a. | - | - | x | | bycopy|; // | ptr | n.a. | - | - | x | x | bycopy|; // | ptr | n.a. | - | - | x | x[] | bycopy|; // =========================================================================; // Legend:; // scl - scalar; // ptr - pointer; // agg - aggregate; // x - applies; // - - invalid in this combination; // [] - mapped with an array section; // byref - should be mapped by reference; // byval - should be mapped by value; // null - initialize a local variable to null on the device; //; // Observations:; // - All scalar declarations that show up in a map clause have to be passed; // by reference, because they may have been mapped in the enclosing data; // environment.; // - If the scalar value does not fit the size of uintptr, it has to be; // passed by reference, regardless the result in the table above.; // - For pointers mapped by value that have either an implicit map or an; // array section, the runtime library may pass the NULL value to the; // device instead of the value passed to it by the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:37,Modifiability,variab,variable,37,"// Locate map clauses and see if the variable being captured is referred to; // in any of those clauses. Here we only care about variables, not fields,; // because fields are part of aggregates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:129,Modifiability,variab,variables,129,"// Locate map clauses and see if the variable being captured is referred to; // in any of those clauses. Here we only care about variables, not fields,; // because fields are part of aggregates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:73,Modifiability,variab,variable,73,// Both map and has_device_addr clauses information influences how a; // variable is captured. E.g. is_device_ptr does not require changing; // the default behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,// There is nothing more we need to know about this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:6,Modifiability,variab,variable,6,// If variable is identified in a map clause it is always captured by; // reference except if it is a pointer that is dereferenced somehow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:95,Modifiability,variab,variables,95,"// By default, all the data that has a scalar type is mapped by copy; // (except for reduction variables).; // Defaultmap scalar is mutual exclusive to defaultmap pointer",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Modifiability,variab,variable,10,// If the variable is artificial and must be captured by value - try to; // capture by value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Modifiability,variab,variable,10,// If the variable is implicitly firstprivate and scalar - capture by; // copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,// Do not capture constexpr variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Modifiability,variab,variable,39,"// If we want to determine whether the variable should be captured from the; // perspective of the current capturing scope, and we've already left all the; // capturing scopes of the top directive on the stack, check from the; // perspective of its parent directive (if any) instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,// If we are attempting to capture a global variable in a directive with; // 'target' we return true so that this global is also mapped to the device.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,// Try to mark variable as declare target if it is used in capturing; // regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Modifiability,variab,variables,17,// Threadprivate variables must not be captured.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,Modifiability,variab,variable,7,// The variable is not private or it is the variable in the directive with; // default(none) clause and not used in any clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,// The variable is not private or it is the variable in the directive with; // default(none) clause and not used in any clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,Modifiability,variab,variable,43,// Consider taskgroup reduction descriptor variable a private; // to avoid possible capture in the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Safety,avoid,avoid,69,// Consider taskgroup reduction descriptor variable a private; // to avoid possible capture in the region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,variab,variable,53,"// OpenMP [2.14.3.5, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a lastprivate; // clause requires an accessible, unambiguous default constructor for the; // class type, unless the list item is also specified in a firstprivate; // clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:148,Security,access,accessible,148,"// OpenMP [2.14.3.5, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a lastprivate; // clause requires an accessible, unambiguous default constructor for the; // class type, unless the list item is also specified in a firstprivate; // clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,"// Generate helper private variable and initialize it with the; // default value. The address of the original variable is replaced; // by the address of the new private variable in CodeGen. This new; // variable is not added to IdResolver, so the code in the OpenMP; // region uses original variable for proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:110,Modifiability,variab,variable,110,"// Generate helper private variable and initialize it with the; // default value. The address of the original variable is replaced; // by the address of the new private variable in CodeGen. This new; // variable is not added to IdResolver, so the code in the OpenMP; // region uses original variable for proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:169,Modifiability,variab,variable,169,"// Generate helper private variable and initialize it with the; // default value. The address of the original variable is replaced; // by the address of the new private variable in CodeGen. This new; // variable is not added to IdResolver, so the code in the OpenMP; // region uses original variable for proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:203,Modifiability,variab,variable,203,"// Generate helper private variable and initialize it with the; // default value. The address of the original variable is replaced; // by the address of the new private variable in CodeGen. This new; // variable is not added to IdResolver, so the code in the OpenMP; // region uses original variable for proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:291,Modifiability,variab,variable,291,"// Generate helper private variable and initialize it with the; // default value. The address of the original variable is replaced; // by the address of the new private variable in CodeGen. This new; // variable is not added to IdResolver, so the code in the OpenMP; // region uses original variable for proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,Modifiability,variab,variable,7,"// The variable is also a firstprivate, so initialization sequence; // for private copy is generated already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Energy Efficiency,allocate,allocate,9,// Check allocate clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:37,Modifiability,Variab,Variables,37,"// OpenMP [2.9.2, Syntax, C/C++]; // Variables must be file-scope, namespace-scope, or static block-scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:89,Modifiability,variab,variables,89,"// OpenMP [2.9.2, Restrictions, C/C++, p.2]; // A threadprivate directive for file-scope variables must appear outside; // any definition or declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,variab,variables,98,"// OpenMP [2.9.2, Restrictions, C/C++, p.3]; // A threadprivate directive for static class member variables must appear; // in the class definition, in the same scope in which the member; // variables are declared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:191,Modifiability,variab,variables,191,"// OpenMP [2.9.2, Restrictions, C/C++, p.3]; // A threadprivate directive for static class member variables must appear; // in the class definition, in the same scope in which the member; // variables are declared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:94,Modifiability,variab,variables,94,"// OpenMP [2.9.2, Restrictions, C/C++, p.4]; // A threadprivate directive for namespace-scope variables must appear; // outside any definition or declaration other than the namespace; // definition itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:97,Modifiability,variab,variables,97,"// OpenMP [2.9.2, Restrictions, C/C++, p.6]; // A threadprivate directive for static block-scope variables must appear; // in the scope of the variable and not in a nested scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Modifiability,variab,variable,143,"// OpenMP [2.9.2, Restrictions, C/C++, p.6]; // A threadprivate directive for static block-scope variables must appear; // in the scope of the variable and not in a nested scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:132,Modifiability,variab,variables,132,"// OpenMP [2.9.2, Restrictions, C/C++, p.2-6]; // A threadprivate directive must lexically precede all references to any; // of the variables in its list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:8,Modifiability,variab,variable,8,// Mark variable as used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:65,Modifiability,variab,variable,65,"// OpenMP [2.9.2, Restrictions, C/C++, p.10]; // A threadprivate variable must not have an incomplete type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:65,Modifiability,variab,variable,65,"// OpenMP [2.9.2, Restrictions, C/C++, p.10]; // A threadprivate variable must not have a reference type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:26,Modifiability,variab,variable,26,"// Check if this is a TLS variable. If TLS is not being supported, produce; // the corresponding diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,Modifiability,variab,variable,43,// Check if initial value of threadprivate variable reference variable with; // local storage (it is not supported by runtime).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Modifiability,variab,variable,62,// Check if initial value of threadprivate variable reference variable with; // local storage (it is not supported by runtime).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:30,Usability,usab,usable,30,// Apply later when we have a usable value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:22,Energy Efficiency,allocate,allocate,22,"// OpenMP 5.0, 2.11.3 allocate Directive, Restrictions.; // allocate directives that appear in a target region must specify an; // allocator clause unless a requires directive with the dynamic_allocators; // clause is present in the same compilation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:60,Energy Efficiency,allocate,allocate,60,"// OpenMP 5.0, 2.11.3 allocate Directive, Restrictions.; // allocate directives that appear in a target region must specify an; // allocator clause unless a requires directive with the dynamic_allocators; // clause is present in the same compilation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:26,Modifiability,variab,variable,26,// Check if this is a TLS variable or global register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,Energy Efficiency,allocate,allocate,36,"// If the used several times in the allocate directive, the same allocator; // must be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Energy Efficiency,allocate,allocate,18,"// OpenMP, 2.11.3 allocate Directive, Restrictions, C / C++; // If a list item has a static storage type, the allocator expression in the; // allocator clause must be a constant expression that evaluates to one of; // the predefined memory allocator values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:99,Modifiability,variab,variable,99,"// OpenMP 5.1 [2.21.7.3] defaultmap clause, Description]; // If implicit-behavior is present, each variable referenced in the; // construct in the category specified by variable-category is treated as if; // it had been listed in a map clause with the map-type of alloc and; // map-type-modifier of present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:169,Modifiability,variab,variable-category,169,"// OpenMP 5.1 [2.21.7.3] defaultmap clause, Description]; // If implicit-behavior is present, each variable referenced in the; // construct in the category specified by variable-category is treated as if; // it had been listed in a map clause with the map-type of alloc and; // map-type-modifier of present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Modifiability,variab,variables,29,// Check implicitly captured variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variables,27,// Do not analyze internal variables and do not enclose them into; // implicit clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variables,28,// Skip internally declared variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:16,Modifiability,variab,variable,16,// Check if the variable has explicit DSA set and stop analysis if it so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:35,Modifiability,variab,variables,35,// Skip internally declared static variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:47,Modifiability,variab,variable,47,"// The default(none) clause requires that each variable that is referenced; // in the construct, and does not have a predetermined data-sharing; // attribute, must have its data-sharing attribute explicitly determined; // by being listed in a data-sharing attribute clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:96,Modifiability,variab,variable,96,"// OpenMP 5.0 [2.19.7.2, defaultmap clause, Description]; // If implicit-behavior is none, each variable referenced in the; // construct that does not have a predetermined data-sharing attribute; // and does not appear in a to or link clause on a declare target; // directive must be listed in a data-mapping attribute clause, a; // data-sharing attribute clause (including a data-sharing attribute; // clause on a combined construct where target. is one of the; // constituent constructs), or an is_device_ptr clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variable,3,"// Variable is used if it has been marked as an array, array; // section, array shaping or the variable iself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:95,Modifiability,variab,variable,95,"// Variable is used if it has been marked as an array, array; // section, array shaping or the variable iself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:166,Security,access,accessed,166,"// OpenMP [2.9.3.6, Restrictions, p.2]; // A list item that appears in a reduction clause of the innermost; // enclosing worksharing or parallel construct may not be accessed in an; // explicit task.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:16,Modifiability,variab,variable,16,// Check if the variable has explicit DSA set and stop analysis if it; // so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:166,Security,access,accessed,166,"// OpenMP [2.9.3.6, Restrictions, p.2]; // A list item that appears in a reduction clause of the innermost; // enclosing worksharing or parallel construct may not be accessed in; // an explicit task.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Modifiability,variab,variables,29,// Check implicitly captured variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Modifiability,variab,variables,29,// Check implicitly captured variables in the task-based directives to; // check if they must be firstprivatized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Modifiability,variab,variables,29,// Check implicitly captured variables in the task-based directives to; // check if they must be firstprivatized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Modifiability,variab,variable,25,// Do not try to map the variable if it or its sub-component was mapped; // already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variables,31,// Process declare target link variables for the target directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:50,Integrability,depend,depending,50,// TODO: 'loop' may require additional parameters depending on the binding.; // Treat similar to OMPD_simd/OMPD_for for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:129,Availability,error,error,129,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:461,Availability,error,error,461,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:142,Safety,detect,detected,142,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:221,Safety,abort,abort,221,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:11,Modifiability,variab,variables,11,// Capture variables captured by reference in lambdas for target-based; // directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variables,12,// Mark all variables in private list clauses as used in inner region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:79,Performance,concurren,concurrent,79,"// OpenMP 5.0, 2.9.2 Worksharing-Loop Construct, Restrictions.; // If an order(concurrent) clause is present, an ordered clause may not appear; // on the same directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variables,12,// Mark all variables in private list clauses as used in inner region.; // Required for proper codegen of combined directives.; // TODO: add processing for other clauses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:405,Integrability,message,message,405,"// OpenMP [2.16, Nesting of Regions]; // OpenMP constructs may not be nested inside a simd region.; // OpenMP [2.8.1,simd Construct, Restrictions]; // An ordered construct with the simd clause is the only OpenMP; // construct that can appear in the simd region.; // Allowing a SIMD construct nested in another SIMD construct is an; // extension. The OpenMP 4.5 spec does not allow it. Issue a warning; // message.; // OpenMP 5.0 [2.9.3.1, simd Construct, Restrictions]; // The only OpenMP constructs that can be encountered during execution of; // a simd region are the atomic construct, the loop construct, the simd; // construct and the ordered construct with the simd clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:47,Availability,mask,masked,47,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A masked region may not be closely nested inside a worksharing, loop,; // atomic, task, or taskloop region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:164,Availability,mask,masked,164,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A scope region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.; // OpenMP 5.1 [2.22, Nesting of Regions]; // A barrier region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:346,Availability,mask,masked,346,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A scope region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.; // OpenMP 5.1 [2.22, Nesting of Regions]; // A barrier region may not be closely nested inside a worksharing, loop,; // task, taskloop, critical, ordered, atomic, or masked region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:223,Availability,mask,masked,223,"// OpenMP 5.1 [2.22, Nesting of Regions]; // A loop region that binds to a parallel region or a worksharing region; // may not be closely nested inside a worksharing, loop, task, taskloop,; // critical, ordered, atomic, or masked region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:64,Deployability,update,update,64,"// OpenMP 4.5 [2.17 Nesting of Regions]; // If a target, target update, target data, target enter data, or; // target exit data construct is encountered during execution of a; // target region, the behavior is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,"// OpenMP [3.1, C/C++]; // A list item is a variable name.; // OpenMP [2.9.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:105,Modifiability,variab,variable,105,"// OpenMP [3.1, C/C++]; // A list item is a variable name.; // OpenMP [2.9.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:138,Modifiability,variab,variable,138,"// OpenMP [3.1, C/C++]; // A list item is a variable name.; // OpenMP [2.9.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Energy Efficiency,allocate,allocate,144,"// OpenMP, 2.12.5 target Construct; // Memory allocators that do not appear in a uses_allocators clause cannot; // appear as an allocator in an allocate clause or be used in the target; // region unless a requires directive with the dynamic_allocators clause; // is present in the same compilation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Energy Efficiency,allocate,allocate,18,"// OpenMP, 2.11.4 allocate Clause, Restrictions.; // For task, taskloop or target directives, allocation requests to memory; // allocators with the trait access set to thread result in unspecified; // behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:154,Security,access,access,154,"// OpenMP, 2.11.4 allocate Clause, Restrictions.; // For task, taskloop or target directives, allocation requests to memory; // allocators with the trait access set to thread result in unspecified; // behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,Energy Efficiency,allocate,allocate,21,// Placeholder until allocate clause supports align modifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:89,Integrability,wrap,wrap,89,/// Rewrite statements and expressions for Sema \p Actions CurContext.; ///; /// Used to wrap already parsed statements/expressions into a new CapturedStmt; /// context. DeclRefExpr used inside the new context are changed to refer to the; /// captured variable instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite statements and expressions for Sema \p Actions CurContext.; ///; /// Used to wrap already parsed statements/expressions into a new CapturedStmt; /// context. DeclRefExpr used inside the new context are changed to refer to the; /// captured variable instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:252,Modifiability,variab,variable,252,/// Rewrite statements and expressions for Sema \p Actions CurContext.; ///; /// Used to wrap already parsed statements/expressions into a new CapturedStmt; /// context. DeclRefExpr used inside the new context are changed to refer to the; /// captured variable instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Testability,Log,LogicalTy,125,/// Create a closure that computes the number of iterations of a loop.; ///; /// \param Actions The Sema object.; /// \param LogicalTy Type for the logical iteration number.; /// \param Rel Comparison operator of the loop condition.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param StopExpr Expression the loop counter is compared against in the loop; /// condition. \param StepExpr Amount of increment after each iteration.; ///; /// \return Closure (CapturedStmt) of the distance calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:148,Testability,log,logical,148,/// Create a closure that computes the number of iterations of a loop.; ///; /// \param Actions The Sema object.; /// \param LogicalTy Type for the logical iteration number.; /// \param Rel Comparison operator of the loop condition.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param StopExpr Expression the loop counter is compared against in the loop; /// condition. \param StepExpr Amount of increment after each iteration.; ///; /// \return Closure (CapturedStmt) of the distance calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:26,Modifiability,variab,variable,26,"// Capture all referenced variable references.; // TODO: Instead of computing NewStart/NewStop/NewStep inside the; // CapturedStmt, we could compute them before and capture the result, to be; // used jointly with the LoopVar function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:263,Safety,avoid,avoided,263,"// Divide by the absolute step amount. If the range is not a multiple of; // the step size, rounding-up the effective upper bound ensures that the; // last iteration is included.; // Note that the rounding-up may cause an overflow in a temporry that; // could be avoided, but would have occurred in a C-style for-loop as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:175,Modifiability,variab,variable,175,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:434,Modifiability,variab,variable,434,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:485,Modifiability,variab,variable,485,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Testability,log,logical,62,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:219,Testability,Log,LogicalTy,219,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:242,Testability,log,logical,242,/// Create a closure that computes the loop variable from the logical iteration; /// number.; ///; /// \param Actions The Sema object.; /// \param LoopVarTy Type for the loop variable used for result value.; /// \param LogicalTy Type for the logical iteration number.; /// \param StartExpr Value of the loop counter at the first iteration.; /// \param Step Amount of increment after each iteration.; /// \param Deref Whether the loop variable is a dereference of the loop; /// counter variable.; ///; /// \return Closure (CapturedStmt) of the loop value calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:147,Deployability,update,update,147,"// Capture the initial iterator which represents the LoopVar value at the; // zero's logical iteration. Since the original ForStmt/CXXForRangeStmt update; // it in every iteration, capture it by value before it is modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:85,Testability,log,logical,85,"// Capture the initial iterator which represents the LoopVar value at the; // zero's logical iteration. Since the original ForStmt/CXXForRangeStmt update; // it in every iteration, capture it by value before it is modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:83,Modifiability,variab,variable,83,// For range-based for-loops convert the loop counter value to a concrete; // loop variable value by dereferencing the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:72,Modifiability,variab,variable,72,"// Extract the common elements of ForStmt and CXXForRangeStmt:; // Loop variable, repeat condition, increment",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variable,31,// For statement declares loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:24,Modifiability,variab,variable,24,// For statement reuses variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:32,Testability,log,logical,32,"// Decide the bit width for the logical iteration counter. By default use the; // unsigned ptrdiff_t integer size (for iterators and pointers).; // TODO: For iterators, use iterator::difference_type,; // std::iterator_traits<>::difference_type or decltype(it - end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:4,Performance,Perform,Perform,4,/// Perform DFS through the structure/class data members trying to find; /// member(s) with user-defined 'default' mapper and generate implicit map; /// clauses for such members with the found 'default' mapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Integrability,depend,dependent,17,"// Expression is dependent - skip it, build the mapper when it gets; // instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:442,Security,access,accessed,442,"/// An initial pass after recognizing all the statements is done in the; /// Parser when the directive OMPD_loop is mapped to OMPD_for,; /// OMPD_distribute or OMPD_simd. A second transform pass with call from; /// clang::TreeTransform::TransformOMPExecutableDirective() is done; /// with the Directive as one of the above mapped directive without; /// the bind clause. Then ""PrevMappedDirective"" stored in the; /// OMPExecutableDirective is accessed and hence this else statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Availability,down,down,25,"// Variable used to note down the DirectiveKind because mapLoopConstruct may; // change ""Kind"" variable, due to mapping of ""omp loop"" to other directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variable,3,"// Variable used to note down the DirectiveKind because mapLoopConstruct may; // change ""Kind"" variable, due to mapping of ""omp loop"" to other directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:95,Modifiability,variab,variable,95,"// Variable used to note down the DirectiveKind because mapLoopConstruct may; // change ""Kind"" variable, due to mapping of ""omp loop"" to other directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:56,Modifiability,variab,variables,56,// Check default data sharing attributes for referenced variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variables,52,// Generate list of implicitly defined firstprivate variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Modifiability,variab,variables,9,// Check variables in the clauses if default(none) or; // default(firstprivate) was specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:291,Performance,concurren,concurrent,291,"// OpenMP [2.8.2, declare simd construct, Description]; // The special this pointer can be used as if was one of the arguments to the; // function in any of the linear, aligned, or uniform clauses.; // The uniform clause declares one or more arguments to have an invariant; // value for all concurrent invocations of the function in the execution of a; // single SIMD loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Security,access,accessible,54,// TODO Track the selector locations in a way that is accessible here to; // improve the diagnostic location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:51,Availability,error,error,51,// Anything that is not a function parameter is an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,Modifiability,variab,variable,21,/// The loop counter variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Modifiability,variab,variable,25,/// Private loop counter variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:58,Deployability,update,update,58,/// This is step for the #CounterVar used to generate its update:; /// #CounterVar = #CounterInit + #CounterStep * CurrentIteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:49,Modifiability,variab,variable,49,"/// Minimum value that can have the loop control variable. Used to support; /// non-rectangular loops. Applied only for LCV with the non-iterator types,; /// since only such variables can be used in non-loop invariant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:174,Modifiability,variab,variables,174,"/// Minimum value that can have the loop control variable. Used to support; /// non-rectangular loops. Applied only for LCV with the non-iterator types,; /// since only such variables can be used in non-loop invariant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:49,Modifiability,variab,variable,49,"/// Maximum value that can have the loop control variable. Used to support; /// non-rectangular loops. Applied only for LCV with the non-iterator type,; /// since only such variables can be used in non-loop invariant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:173,Modifiability,variab,variables,173,"/// Maximum value that can have the loop control variable. Used to support; /// non-rectangular loops. Applied only for LCV with the non-iterator type,; /// since only such variables can be used in non-loop invariant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Integrability,depend,depends,29,"/// true, if the lower bound depends on the outer loop control var.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Integrability,depend,depends,29,"/// true, if the upper bound depends on the outer loop control var.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:32,Integrability,depend,depends,32,/// Index of the loop this loop depends on and forms non-rectangular loop; /// nest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Modifiability,variab,variable,9,/// Loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:22,Modifiability,variab,variable,22,/// Reference to loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:37,Integrability,depend,depends,37,/// The outer loop counter this loop depends on (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:100,Integrability,depend,depends,100,/// Contains number of loop (starts from 1) on which loop counter init; /// expression of this loop depends on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:105,Integrability,depend,depends,105,/// Contains number of loop (starts from 1) on which loop counter condition; /// expression of this loop depends on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,Integrability,depend,depends,36,/// Checks if the provide statement depends on the loop counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:71,Modifiability,variab,variable,71,/// Check init-expr for canonical loop form and save loop counter; /// variable - #Var and its initialization value - #LB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Testability,test,test-expr,10,"/// Check test-expr for canonical form, save upper-bound (#UB), flags; /// for less/greater and for strict/non-strict comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:28,Modifiability,variab,variable,28,/// Return the loop counter variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,/// Return the reference expression to loop counter variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:43,Integrability,depend,depend,43,/// Build loop data with counter value for depend clauses in ordered; /// directives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:37,Integrability,depend,dependent,37,/// Return true if any expression is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:33,Integrability,depend,depend,33,"/// Returns index of the loop we depend on (starting from 1), or 0 otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variable,31,/// Helper to set loop counter variable and its initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:58,Testability,test,test-expr,58,"// OpenMP [2.6, Canonical Loop Form, Restrictions]; // If test-expr is of form var relational-op b and relational-op is < or; // <= then incr-expr must cause var to increase on each iteration of the; // loop. If test-expr is of form var relational-op b and relational-op is; // > or >= then incr-expr must cause var to decrease on each iteration of; // the loop.; // If test-expr is of form b relational-op var and relational-op is < or; // <= then incr-expr must cause var to decrease on each iteration of the; // loop. If test-expr is of form b relational-op var and relational-op is; // > or >= then incr-expr must cause var to increase on each iteration of; // the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:212,Testability,test,test-expr,212,"// OpenMP [2.6, Canonical Loop Form, Restrictions]; // If test-expr is of form var relational-op b and relational-op is < or; // <= then incr-expr must cause var to increase on each iteration of the; // loop. If test-expr is of form var relational-op b and relational-op is; // > or >= then incr-expr must cause var to decrease on each iteration of; // the loop.; // If test-expr is of form b relational-op var and relational-op is < or; // <= then incr-expr must cause var to decrease on each iteration of the; // loop. If test-expr is of form b relational-op var and relational-op is; // > or >= then incr-expr must cause var to increase on each iteration of; // the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:370,Testability,test,test-expr,370,"// OpenMP [2.6, Canonical Loop Form, Restrictions]; // If test-expr is of form var relational-op b and relational-op is < or; // <= then incr-expr must cause var to increase on each iteration of the; // loop. If test-expr is of form var relational-op b and relational-op is; // > or >= then incr-expr must cause var to decrease on each iteration of; // the loop.; // If test-expr is of form b relational-op var and relational-op is < or; // <= then incr-expr must cause var to decrease on each iteration of the; // loop. If test-expr is of form b relational-op var and relational-op is; // > or >= then incr-expr must cause var to increase on each iteration of; // the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:524,Testability,test,test-expr,524,"// OpenMP [2.6, Canonical Loop Form, Restrictions]; // If test-expr is of form var relational-op b and relational-op is < or; // <= then incr-expr must cause var to increase on each iteration of the; // loop. If test-expr is of form var relational-op b and relational-op is; // > or >= then incr-expr must cause var to decrease on each iteration of; // the loop.; // If test-expr is of form b relational-op var and relational-op is < or; // <= then incr-expr must cause var to decrease on each iteration of the; // loop. If test-expr is of form b relational-op var and relational-op is; // > or >= then incr-expr must cause var to increase on each iteration of; // the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:122,Modifiability,variab,variable,122,/// Checker for the non-rectangular loops. Checks if the initializer or; /// condition expression references loop counter variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Integrability,depend,depend,98,"// OpenMP, 2.9.1 Canonical Loop Form, Restrictions.; // The type of the loop iterator on which we depend may not have a random; // access iterator type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,Security,access,access,131,"// OpenMP, 2.9.1 Canonical Loop Form, Restrictions.; // The type of the loop iterator on which we depend may not have a random; // access iterator type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Modifiability,variab,variable,69,// Check init-expr for canonical loop form and save loop counter; // variable - #Var and its initialization value - #LB.; // OpenMP [2.6] Canonical loop form. init-expr may be one of the following:; // var = lb; // integer-type var = lb; // random-access-iterator-type var = lb; // pointer-type var = lb; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:248,Security,access,access-iterator-type,248,// Check init-expr for canonical loop form and save loop counter; // variable - #Var and its initialization value - #LB.; // OpenMP [2.6] Canonical loop form. init-expr may be one of the following:; // var = lb; // integer-type var = lb; // random-access-iterator-type var = lb; // pointer-type var = lb; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:79,Modifiability,variab,variable,79,"/// Ignore parenthesizes, implicit casts, copy constructor and return the; /// variable (which may be the loop variable) if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:111,Modifiability,variab,variable,111,"/// Ignore parenthesizes, implicit casts, copy constructor and return the; /// variable (which may be the loop variable) if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Testability,test,test-expr,9,"// Check test-expr for canonical form, save upper-bound UB, flags for; // less/greater and for strict/non-strict comparison.; // OpenMP [2.9] Canonical loop form. Test-expr may be one of the following:; // var relational-op b; // b relational-op var; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:163,Testability,Test,Test-expr,163,"// Check test-expr for canonical form, save upper-bound UB, flags for; // less/greater and for strict/non-strict comparison.; // OpenMP [2.9] Canonical loop form. Test-expr may be one of the following:; // var relational-op b; // b relational-op var; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:125,Testability,Test,Test-expr,125,// Check incr-expr for canonical loop form and return true if it; // does not conform.; // OpenMP [2.6] Canonical loop form. Test-expr may be one of the following:; // ++var; // var++; // --var; // var--; // var += incr; // var -= incr; // var = var + incr; // var = incr + var; // var = var - incr; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:30,Availability,error,error,30,"// BuildBinOp already emitted error, this one is to point user to upper; // and lower bound, and to tell what is passed to 'operator-'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,Testability,Test,TestIsLessOp,20,"// OuterVar = (LB = TestIsLessOp.getValue() ? min(LB(MinVal), LB(MaxVal)) :; // max(LB(MinVal), LB(MaxVal)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:8,Testability,Test,TestIsLessOp,8,"// UB = TestIsLessOp.getValue() ? max(UB(MinVal), UB(MaxVal)) :; // min(UB(MinVal), UB(MaxVal))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:49,Modifiability,variab,variables,49,// OpenMP runtime requires 32-bit or 64-bit loop variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:68,Integrability,depend,dependent,68,// Do not build a precondition when the condition/initialization is dependent; // to prevent pessimistic early loop exit.; // TODO: this can be improved by calculating min/max values but not sure that; // it will be very effective.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:2,Testability,Test,TestIsStrictOp,2,/*TestIsStrictOp=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,Variab,Variables,54,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, C/C++]. The loop iteration variable in the; // associated for-loop of a simd construct with just one associated; // for-loop may be listed in a linear clause with a constant-linear-step; // that is the increment of the associated for-loop. The loop iteration; // variable(s) in the associated for-loop(s) of a for or parallel for; // construct may be listed in a private or lastprivate clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:122,Modifiability,variab,variable,122,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, C/C++]. The loop iteration variable in the; // associated for-loop of a simd construct with just one associated; // for-loop may be listed in a linear clause with a constant-linear-step; // that is the increment of the associated for-loop. The loop iteration; // variable(s) in the associated for-loop(s) of a for or parallel for; // construct may be listed in a private or lastprivate clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:358,Modifiability,variab,variable,358,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables; // Referenced in a Construct, C/C++]. The loop iteration variable in the; // associated for-loop of a simd construct with just one associated; // for-loop may be listed in a linear clause with a constant-linear-step; // that is the increment of the associated for-loop. The loop iteration; // variable(s) in the associated for-loop(s) of a for or parallel for; // construct may be listed in a private or lastprivate clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:64,Modifiability,variab,variable,64,// If LoopVarRefExpr is nullptr it means the corresponding loop variable; // is declared in the loop and it is predetermined as a private.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,"// Make the loop iteration variable private (for worksharing; // constructs), linear (for simd directives with the only one; // associated loop) or lastprivate (for simd directives with several; // collapsed or ordered loops).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:59,Testability,test,test-expr,59,"// OpenMP [2.9.1, Canonical Loop Form]; // for (init-expr; test-expr; incr-expr) structured-block; // for (range-decl: range-expr) structured-block",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:24,Integrability,depend,dependent,24,// Postpone analysis in dependent contexts for ranged for loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:14,Modifiability,variab,variable,14,// Check loop variable's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:76,Modifiability,variab,variable,76,"// OpenMP [2.6, Canonical Loop Form]; // Var is one of the following:; // A variable of signed or unsigned integer type.; // For C++, a variable of a random access iterator type.; // For C, a variable of a pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:136,Modifiability,variab,variable,136,"// OpenMP [2.6, Canonical Loop Form]; // Var is one of the following:; // A variable of signed or unsigned integer type.; // For C++, a variable of a random access iterator type.; // For C, a variable of a pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:192,Modifiability,variab,variable,192,"// OpenMP [2.6, Canonical Loop Form]; // Var is one of the following:; // A variable of signed or unsigned integer type.; // For C++, a variable of a random access iterator type.; // For C, a variable of a pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:157,Security,access,access,157,"// OpenMP [2.6, Canonical Loop Form]; // Var is one of the following:; // A variable of signed or unsigned integer type.; // For C++, a variable of a random access iterator type.; // For C, a variable of a pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in; // a Construct; // The loop iteration variable(s) in the associated for-loop(s) of a for or; // parallel for construct is (are) private.; // The loop iteration variable in the associated for-loop of a simd; // construct with just one associated for-loop is linear with a; // constant-linear-step that is the increment of the associated for-loop.; // Exclude loop var from the list of variables with implicitly defined data; // sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:116,Modifiability,variab,variable,116,"// OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in; // a Construct; // The loop iteration variable(s) in the associated for-loop(s) of a for or; // parallel for construct is (are) private.; // The loop iteration variable in the associated for-loop of a simd; // construct with just one associated for-loop is linear with a; // constant-linear-step that is the increment of the associated for-loop.; // Exclude loop var from the list of variables with implicitly defined data; // sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:238,Modifiability,variab,variable,238,"// OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in; // a Construct; // The loop iteration variable(s) in the associated for-loop(s) of a for or; // parallel for construct is (are) private.; // The loop iteration variable in the associated for-loop of a simd; // construct with just one associated for-loop is linear with a; // constant-linear-step that is the increment of the associated for-loop.; // Exclude loop var from the list of variables with implicitly defined data; // sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:462,Modifiability,variab,variables,462,"// OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in; // a Construct; // The loop iteration variable(s) in the associated for-loop(s) of a for or; // parallel for construct is (are) private.; // The loop iteration variable in the associated for-loop of a simd; // construct with just one associated for-loop is linear with a; // constant-linear-step that is the increment of the associated for-loop.; // Exclude loop var from the list of variables with implicitly defined data; // sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Testability,test,test-expr,9,// Check test-expr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Integrability,rout,routine,18,"// This is helper routine for loop directives (e.g., 'for', 'simd',; // 'for simd', etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:51,Modifiability,variab,variables,51,// Handle initialization of captured loop iterator variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:797,Deployability,update,updates,797,"// An example of what is generated for the following code:; //; // #pragma omp simd collapse(2) ordered(2); // for (i = 0; i < NI; ++i); // for (k = 0; k < NK; ++k); // for (j = J0; j < NJ; j+=2) {; // <loop body>; // }; //; // We generate the code below.; // Note: the loop body may be outlined in CodeGen.; // Note: some counters may be C++ classes, operator- is used to find number of; // iterations and operator+= to calculate counter value.; // Note: decltype(NumIterations) must be integer type (in 'omp for', only i32; // or i64 is currently supported).; //; // #define NumIterations (NI * ((NJ - J0 - 1 + 2) / 2)); // for (int[32|64]_t IV = 0; IV < NumIterations; ++IV ) {; // .local.i = IV / ((NJ - J0 - 1 + 2) / 2);; // .local.j = J0 + (IV % ((NJ - J0 - 1 + 2) / 2)) * 2;; // // similar updates for vars in clauses (e.g. 'linear'); // <loop body (using local i and j)>; // }; // i = NI; // assign final values of counters; // j = NJ;; //; // Last iteration number is (I1 * I2 * ... In) - 1, where I1, I2 ... In are; // the iteration counts of the collapsed for loops.; // Precondition tests if there is at least one iteration (all conditions are; // true).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:1095,Testability,test,tests,1095,"// An example of what is generated for the following code:; //; // #pragma omp simd collapse(2) ordered(2); // for (i = 0; i < NI; ++i); // for (k = 0; k < NK; ++k); // for (j = J0; j < NJ; j+=2) {; // <loop body>; // }; //; // We generate the code below.; // Note: the loop body may be outlined in CodeGen.; // Note: some counters may be C++ classes, operator- is used to find number of; // iterations and operator+= to calculate counter value.; // Note: decltype(NumIterations) must be integer type (in 'omp for', only i32; // or i64 is currently supported).; //; // #define NumIterations (NI * ((NJ - J0 - 1 + 2) / 2)); // for (int[32|64]_t IV = 0; IV < NumIterations; ++IV ) {; // .local.i = IV / ((NJ - J0 - 1 + 2) / 2);; // .local.j = J0 + (IV % ((NJ - J0 - 1 + 2) / 2)) * 2;; // // similar updates for vars in clauses (e.g. 'linear'); // <loop body (using local i and j)>; // }; // i = NI; // assign final values of counters; // j = NJ;; //; // Last iteration number is (I1 * I2 * ... In) - 1, where I1, I2 ... In are; // the iteration counts of the collapsed for loops.; // Precondition tests if there is at least one iteration (all conditions are; // true).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Modifiability,variab,variables,9,"// Build variables passed into runtime, necessary for worksharing directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,"// Lower bound variable, initialized with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,"// Upper bound variable, initialized with last iteration number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variable-flag,12,// A 32-bit variable-flag where runtime returns 1 for the last iteration.; // This will be used to implement clause 'lastprivate'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Modifiability,variab,variable,10,// Stride variable returned by runtime (we initialize it to 1 by default).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:107,Energy Efficiency,schedul,scheduling,107,"// Build expression: UB = min(UB, LastIteration); // It is necessary for CodeGen of directives with static scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:130,Energy Efficiency,schedul,schedule,130,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:229,Energy Efficiency,schedul,scheduling,229,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:278,Energy Efficiency,schedul,schedule,278,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:105,Security,access,access,105,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,"// Lower bound variable, initialized with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,"// Upper bound variable, initialized with last iteration number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:132,Energy Efficiency,schedul,schedule,132,// We expect to have at least 2 more parameters than the 'parallel'; // directive does - the lower and upper bounds of the previous schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Usability,learn,learned,52,// Set the proper type for the bounds given what we learned from the; // enclosed loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,// Build the iteration variable and its initialization before loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:216,Deployability,update,update,216,"// Increments for worksharing loops (LB = LB + ST; UB = UB + ST).; // Used for directives with static scheduling.; // In combined construct, add combined version that use CombLB and CombUB; // base variables for the update",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:102,Energy Efficiency,schedul,scheduling,102,"// Increments for worksharing loops (LB = LB + ST; UB = UB + ST).; // Used for directives with static scheduling.; // In combined construct, add combined version that use CombLB and CombUB; // base variables for the update",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:198,Modifiability,variab,variables,198,"// Increments for worksharing loops (LB = LB + ST; UB = UB + ST).; // Used for directives with static scheduling.; // In combined construct, add combined version that use CombLB and CombUB; // base variables for the update",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Energy Efficiency,schedul,schedule,143,"// Build IV <= PrevUB or IV < PrevUB + 1 for unsigned IV to be used in; // parallel for is in combination with a distribute directive with; // schedule(static, 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Deployability,update,updates,9,// Build updates and final values of the loop counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:86,Modifiability,variab,variable,86,"// We implement the following algorithm for obtaining the; // original loop iteration variable values based on the; // value of the collapsed loop iteration variable IV.; //; // Let n+1 be the number of collapsed loops in the nest.; // Iteration variables (I0, I1, .... In); // Iteration counts (N0, N1, ... Nn); //; // Acc = IV;; //; // To compute Ik for loop k, 0 <= k <= n, generate:; // Prod = N(k+1) * N(k+2) * ... * Nn;; // Ik = Acc / Prod;; // Acc -= Ik * Prod;; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:157,Modifiability,variab,variable,157,"// We implement the following algorithm for obtaining the; // original loop iteration variable values based on the; // value of the collapsed loop iteration variable IV.; //; // Let n+1 be the number of collapsed loops in the nest.; // Iteration variables (I0, I1, .... In); // Iteration counts (N0, N1, ... Nn); //; // Acc = IV;; //; // To compute Ik for loop k, 0 <= k <= n, generate:; // Prod = N(k+1) * N(k+2) * ... * Nn;; // Ik = Acc / Prod;; // Acc -= Ik * Prod;; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:246,Modifiability,variab,variables,246,"// We implement the following algorithm for obtaining the; // original loop iteration variable values based on the; // value of the collapsed loop iteration variable IV.; //; // Let n+1 be the number of collapsed loops in the nest.; // Iteration variables (I0, I1, .... In); // Iteration counts (N0, N1, ... Nn); //; // Acc = IV;; //; // To compute Ik for loop k, 0 <= k <= n, generate:; // Prod = N(k+1) * N(k+2) * ... * Nn;; // Ik = Acc / Prod;; // Acc -= Ik * Prod;; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Safety,avoid,avoid,69,// Iter = Acc / Prod; // If there is at least one more inner loop to avoid; // multiplication by 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Deployability,Update,Update,3,// Update Acc:; // Acc -= Iter * Prod; // Check if there is at least one more inner loop to avoid; // multiplication by 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:92,Safety,avoid,avoid,92,// Update Acc:; // Acc -= Iter * Prod; // Check if there is at least one more inner loop to avoid; // multiplication by 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Deployability,update,update,9,// Build update: IS.CounterVar(Private) = IS.Start + Iter * IS.Step,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:76,Safety,safe,safelen,76,"// OpenMP 4.5 [2.8.1, simd Construct, Restrictions]; // If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:193,Safety,safe,safelen,193,"// OpenMP 4.5 [2.8.1, simd Construct, Restrictions]; // If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Modifiability,variab,variable,144,"// OpenMP 5.1 [2.11.7, loop construct, Restrictions]; // A list item may not appear in a lastprivate clause unless it is the; // loop iteration variable of a loop that is associated with the construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Modifiability,variab,variable,144,"// OpenMP 5.1 [2.11.7, loop construct, Restrictions]; // A list item may not appear in a lastprivate clause unless it is the; // loop iteration variable of a loop that is associated with the construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Modifiability,variab,variable,144,"// OpenMP 5.1 [2.11.7, loop construct, Restrictions]; // A list item may not appear in a lastprivate clause unless it is the; // loop iteration variable of a loop that is associated with the construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Modifiability,variab,variable,144,"// OpenMP 5.1 [2.11.7, loop construct, Restrictions]; // A list item may not appear in a lastprivate clause unless it is the; // loop iteration variable of a loop that is associated with the construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:144,Modifiability,variab,variable,144,"// OpenMP 5.1 [2.11.7, loop construct, Restrictions]; // A list item may not appear in a lastprivate clause unless it is the; // loop iteration variable of a loop that is associated with the construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:311,Integrability,depend,depend,311,"// OpenMP 5.0, 2.17.9, ordered Construct, Restrictions.; // During execution of an iteration of a worksharing-loop or a loop nest; // within a worksharing-loop, simd, or worksharing-loop SIMD region, a thread; // must not execute more than one ordered region corresponding to an ordered; // construct without a depend clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:57,Deployability,update,update,57,/// Helper class for checking expression in 'omp atomic [update]'; /// construct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:4,Availability,Error,Error,4,/// Error results for atomic update expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Deployability,update,update,29,/// Error results for atomic update expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:56,Deployability,update,updated,56,/// RHS binary operation does not have reference to the updated LHS; /// part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:38,Availability,error,error,38,/// An expression contains semantical error not related to; /// 'omp atomic [update]',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:77,Deployability,update,update,77,/// An expression contains semantical error not related to; /// 'omp atomic [update]',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,Availability,error,errors,7,/// No errors is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:42,Availability,error,error,42,/// A location for note diagnostics (when error is found).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Deployability,update,update,39,/// Is 'x' a LHS in a RHS part of full update expression. It is; /// important for non-associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:228,Availability,error,error,228,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:305,Availability,error,error,305,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:369,Availability,error,error,369,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Deployability,update,update,62,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:425,Deployability,update,update,425,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:375,Integrability,message,message,375,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:205,Performance,perform,performed,205,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Deployability,update,update,15,/// Return the update expression used in calculation of the updated; /// value. Always has form 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or; /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:60,Deployability,update,updated,60,/// Return the update expression used in calculation of the updated; /// value. Always has form 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or; /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:50,Deployability,update,update,50,"/// Return true if 'x' is LHS in RHS part of full update expression,; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Deployability,update,update,12,// Build an update expression of form 'OpaqueValueExpr(x) binop; // OpaqueValueExpr(expr)' or 'OpaqueValueExpr(expr) binop; // OpaqueValueExpr(x)' and then cast it to the type of the 'x' expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Availability,error,errors,17,/// All kinds of errors that can occur in `atomic compare`,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,Availability,error,error,7,/// No error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Deployability,update,update,39,/// Check if it is a valid conditional update statement (cond-update-stmt).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Deployability,update,update-stmt,62,/// Check if it is a valid conditional update statement (cond-update-stmt).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Deployability,update,update-stmt,69,// Check if the statement is in one of the following forms; // (cond-update-stmt):; // if (expr ordop x) { x = expr; }; // if (x ordop expr) { x = expr; }; // if (x == e) { x = d; },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:100,Deployability,update,update-capture-atomic,100,"// NOTE: Form 3, 4, 5 in the following comments mean the 3rd, 4th, and 5th; // form of 'conditional-update-capture-atomic' structured block on the v5.2; // spec p.p. 82:; // (1) { v = x; cond-update-stmt }; // (2) { cond-update-stmt v = x; }; // (3) if(x == e) { x = d; } else { v = x; }; // (4) { r = x == e; if(r) { x = d; } }; // (5) { r = x == e; if(r) { x = d; } else { v = x; } }; /// Check if it is valid 'if(x == e) { x = d; } else { v = x; }' (form 3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:192,Deployability,update,update-stmt,192,"// NOTE: Form 3, 4, 5 in the following comments mean the 3rd, 4th, and 5th; // form of 'conditional-update-capture-atomic' structured block on the v5.2; // spec p.p. 82:; // (1) { v = x; cond-update-stmt }; // (2) { cond-update-stmt v = x; }; // (3) if(x == e) { x = d; } else { v = x; }; // (4) { r = x == e; if(r) { x = d; } }; // (5) { r = x == e; if(r) { x = d; } else { v = x; } }; /// Check if it is valid 'if(x == e) { x = d; } else { v = x; }' (form 3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:221,Deployability,update,update-stmt,221,"// NOTE: Form 3, 4, 5 in the following comments mean the 3rd, 4th, and 5th; // form of 'conditional-update-capture-atomic' structured block on the v5.2; // spec p.p. 82:; // (1) { v = x; cond-update-stmt }; // (2) { cond-update-stmt v = x; }; // (3) if(x == e) { x = d; } else { v = x; }; // (4) { r = x == e; if(r) { x = d; } }; // (5) { r = x == e; if(r) { x = d; } else { v = x; } }; /// Check if it is valid 'if(x == e) { x = d; } else { v = x; }' (form 3)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:19,Deployability,update,updated,19,/// If 'v' is only updated when the comparison fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:59,Deployability,update,updated,59,"/// If original value of 'x' must be stored in 'v', not an updated one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,Deployability,update,update-stmt,61,// It could be one of the following cases:; // { v = x; cond-update-stmt }; // { v = x; cond-expr-stmt }; // { cond-expr-stmt; v = x; }; // form 45,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Deployability,update,update-stmt,17,// { v = x; cond-update-stmt },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Deployability,update,update-stmt,10,// { cond-update-stmt v = x; },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:134,Deployability,release,release,134,"// OpenMP 5.0, 2.17.7 atomic Construct, Restrictions; // If atomic-clause is read then memory-order-clause must not be acq_rel or; // release.; // If atomic-clause is write then memory-order-clause must not be acq_rel or; // acquire.; // If atomic-clause is update or not present then memory-order-clause must not; // be acq_rel or acquire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:258,Deployability,update,update,258,"// OpenMP 5.0, 2.17.7 atomic Construct, Restrictions; // If atomic-clause is read then memory-order-clause must not be acq_rel or; // release.; // If atomic-clause is write then memory-order-clause must not be acq_rel or; // acquire.; // If atomic-clause is update or not present then memory-order-clause must not; // be acq_rel or acquire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:321,Security,access,access,321,"// OpenMP [2.12.6, atomic Construct]; // In the next expressions:; // * x and v (as applicable) are both l-value expressions with scalar type.; // * During the execution of an atomic region, multiple syntactic; // occurrences of x must designate the same storage location.; // * Neither of v and expr (as applicable) may access the storage location; // designated by x.; // * Neither of x and expr (as applicable) may access the storage location; // designated by v.; // * expr is an expression with scalar type.; // * binop is one of +, *, -, /, &, ^, |, <<, or >>.; // * binop, binop=, ++, and -- are not overloaded operators.; // * The expression x binop expr must be numerically equivalent to x binop; // (expr). This requirement is satisfied if the operators in expr have; // precedence greater than binop, or by using parentheses around expr or; // subexpressions of expr.; // * The expression expr binop x must be numerically equivalent to (expr); // binop x. This requirement is satisfied if the operators in expr have; // precedence equal to or greater than binop, or by using parentheses around; // expr or subexpressions of expr.; // * For forms that allow multiple occurrences of x, the number of times; // that x is evaluated is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:418,Security,access,access,418,"// OpenMP [2.12.6, atomic Construct]; // In the next expressions:; // * x and v (as applicable) are both l-value expressions with scalar type.; // * During the execution of an atomic region, multiple syntactic; // occurrences of x must designate the same storage location.; // * Neither of v and expr (as applicable) may access the storage location; // designated by x.; // * Neither of x and expr (as applicable) may access the storage location; // designated by v.; // * expr is an expression with scalar type.; // * binop is one of +, *, -, /, &, ^, |, <<, or >>.; // * binop, binop=, ++, and -- are not overloaded operators.; // * The expression x binop expr must be numerically equivalent to x binop; // (expr). This requirement is satisfied if the operators in expr have; // precedence greater than binop, or by using parentheses around expr or; // subexpressions of expr.; // * The expression expr binop x must be numerically equivalent to (expr); // binop x. This requirement is satisfied if the operators in expr have; // precedence equal to or greater than binop, or by using parentheses around; // expr or subexpressions of expr.; // * For forms that allow multiple occurrences of x, the number of times; // that x is evaluated is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:16,Deployability,update,update,16,// If clause is update:; // x++;; // x--;; // ++x;; // --x;; // x binop= expr;; // x = x binop expr;; // x = expr binop x;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Modifiability,variab,variables,17,/// Check if the variables in the mapping clause are externally visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:67,Availability,error,error,67,// Empty statement should only be possible if there already was an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,Modifiability,variab,variables,20,// Create iteration variables for the generated loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,// Iteration variable for the floor (i.e. outer) loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,// Iteration variable for the tile (i.e. inner) loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Modifiability,variab,variable,23,// Reuse the iteration variable created by checkOpenMPLoop. It is also; // used by the expressions to derive the original iteration variable's; // value from the logical iteration number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:132,Modifiability,variab,variable,132,// Reuse the iteration variable created by checkOpenMPLoop. It is also; // used by the expressions to derive the original iteration variable's; // value from the logical iteration number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:162,Testability,log,logical,162,// Reuse the iteration variable created by checkOpenMPLoop. It is also; // used by the expressions to derive the original iteration variable's; // value from the logical iteration number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Modifiability,variab,variables,17,// Commonly used variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,"// Statements to set the original iteration variable's value from the; // logical iteration number.; // Generated for loop is:; // Original_for_init;; // for (auto .tile.iv = .floor.iv; .tile.iv < min(.floor.iv + DimTileSize,; // NumIterations); ++.tile.iv) {; // Original_Body;; // Original_counter_update;; // }; // FIXME: If the innermost body is an loop itself, inserting these; // statements stops it being recognized as a perfectly nested loop (e.g.; // for applying tiling again). If this is the case, sink the expressions; // further into the inner loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:74,Testability,log,logical,74,"// Statements to set the original iteration variable's value from the; // logical iteration number.; // Generated for loop is:; // Original_for_init;; // for (auto .tile.iv = .floor.iv; .tile.iv < min(.floor.iv + DimTileSize,; // NumIterations); ++.tile.iv) {; // Original_Body;; // Original_counter_update;; // }; // FIXME: If the innermost body is an loop itself, inserting these; // statements stops it being recognized as a perfectly nested loop (e.g.; // for applying tiling again). If this is the case, sink the expressions; // further into the inner loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Modifiability,variab,variables,17,// Commonly used variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:67,Availability,error,error,67,// Empty statement should only be possible if there already was an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:430,Deployability,Update,Updates,430,"// Otherwise, we need to provide a de-sugared/transformed AST that can be; // associated with another loop directive.; //; // The canonical loop analysis return by checkTransformableLoopNest assumes; // the following structure to be the same loop without transformations or; // directives applied: \code OriginalInits; LoopHelper.PreInits;; // LoopHelper.Counters;; // for (; IV < LoopHelper.NumIterations; ++IV) {; // LoopHelper.Updates;; // Body;; // }; // \endcode; // where IV is a variable declared and initialized to 0 in LoopHelper.PreInits; // and referenced by LoopHelper.IterationVarRef.; //; // The unrolling directive transforms this into the following loop:; // \code; // OriginalInits; \; // LoopHelper.PreInits; > NewPreInits; // LoopHelper.Counters; /; // for (auto UIV = 0; UIV < LoopHelper.NumIterations; UIV+=Factor) {; // #pragma clang loop unroll_count(Factor); // for (IV = UIV; IV < UIV + Factor && UIV < LoopHelper.NumIterations; ++IV); // {; // LoopHelper.Updates;; // Body;; // }; // }; // \endcode; // where UIV is a new logical iteration counter. IV must be the same VarDecl; // as the original LoopHelper.IterationVarRef because LoopHelper.Updates; // references it. If the partially unrolled loop is associated with another; // loop directive (like an OMPForDirective), it will use checkOpenMPLoop to; // analyze this loop, i.e. the outer loop must fulfill the constraints of an; // OpenMP canonical loop. The inner loop is not an associable canonical loop; // and only exists to defer its unrolling to LLVM's LoopUnroll instead of; // doing it in the frontend (by adding loop metadata). NewPreInits becomes a; // property of the OMPLoopBasedDirective instead of statements in; // CompoundStatement. This is to allow the loop to become a non-outermost loop; // of a canonical loop nest where these PreInits are emitted before the; // outermost directive.; // Determine the PreInit declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:981,Deployability,Update,Updates,981,"// Otherwise, we need to provide a de-sugared/transformed AST that can be; // associated with another loop directive.; //; // The canonical loop analysis return by checkTransformableLoopNest assumes; // the following structure to be the same loop without transformations or; // directives applied: \code OriginalInits; LoopHelper.PreInits;; // LoopHelper.Counters;; // for (; IV < LoopHelper.NumIterations; ++IV) {; // LoopHelper.Updates;; // Body;; // }; // \endcode; // where IV is a variable declared and initialized to 0 in LoopHelper.PreInits; // and referenced by LoopHelper.IterationVarRef.; //; // The unrolling directive transforms this into the following loop:; // \code; // OriginalInits; \; // LoopHelper.PreInits; > NewPreInits; // LoopHelper.Counters; /; // for (auto UIV = 0; UIV < LoopHelper.NumIterations; UIV+=Factor) {; // #pragma clang loop unroll_count(Factor); // for (IV = UIV; IV < UIV + Factor && UIV < LoopHelper.NumIterations; ++IV); // {; // LoopHelper.Updates;; // Body;; // }; // }; // \endcode; // where UIV is a new logical iteration counter. IV must be the same VarDecl; // as the original LoopHelper.IterationVarRef because LoopHelper.Updates; // references it. If the partially unrolled loop is associated with another; // loop directive (like an OMPForDirective), it will use checkOpenMPLoop to; // analyze this loop, i.e. the outer loop must fulfill the constraints of an; // OpenMP canonical loop. The inner loop is not an associable canonical loop; // and only exists to defer its unrolling to LLVM's LoopUnroll instead of; // doing it in the frontend (by adding loop metadata). NewPreInits becomes a; // property of the OMPLoopBasedDirective instead of statements in; // CompoundStatement. This is to allow the loop to become a non-outermost loop; // of a canonical loop nest where these PreInits are emitted before the; // outermost directive.; // Determine the PreInit declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:1169,Deployability,Update,Updates,1169,"// Otherwise, we need to provide a de-sugared/transformed AST that can be; // associated with another loop directive.; //; // The canonical loop analysis return by checkTransformableLoopNest assumes; // the following structure to be the same loop without transformations or; // directives applied: \code OriginalInits; LoopHelper.PreInits;; // LoopHelper.Counters;; // for (; IV < LoopHelper.NumIterations; ++IV) {; // LoopHelper.Updates;; // Body;; // }; // \endcode; // where IV is a variable declared and initialized to 0 in LoopHelper.PreInits; // and referenced by LoopHelper.IterationVarRef.; //; // The unrolling directive transforms this into the following loop:; // \code; // OriginalInits; \; // LoopHelper.PreInits; > NewPreInits; // LoopHelper.Counters; /; // for (auto UIV = 0; UIV < LoopHelper.NumIterations; UIV+=Factor) {; // #pragma clang loop unroll_count(Factor); // for (IV = UIV; IV < UIV + Factor && UIV < LoopHelper.NumIterations; ++IV); // {; // LoopHelper.Updates;; // Body;; // }; // }; // \endcode; // where UIV is a new logical iteration counter. IV must be the same VarDecl; // as the original LoopHelper.IterationVarRef because LoopHelper.Updates; // references it. If the partially unrolled loop is associated with another; // loop directive (like an OMPForDirective), it will use checkOpenMPLoop to; // analyze this loop, i.e. the outer loop must fulfill the constraints of an; // OpenMP canonical loop. The inner loop is not an associable canonical loop; // and only exists to defer its unrolling to LLVM's LoopUnroll instead of; // doing it in the frontend (by adding loop metadata). NewPreInits becomes a; // property of the OMPLoopBasedDirective instead of statements in; // CompoundStatement. This is to allow the loop to become a non-outermost loop; // of a canonical loop nest where these PreInits are emitted before the; // outermost directive.; // Determine the PreInit declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:486,Modifiability,variab,variable,486,"// Otherwise, we need to provide a de-sugared/transformed AST that can be; // associated with another loop directive.; //; // The canonical loop analysis return by checkTransformableLoopNest assumes; // the following structure to be the same loop without transformations or; // directives applied: \code OriginalInits; LoopHelper.PreInits;; // LoopHelper.Counters;; // for (; IV < LoopHelper.NumIterations; ++IV) {; // LoopHelper.Updates;; // Body;; // }; // \endcode; // where IV is a variable declared and initialized to 0 in LoopHelper.PreInits; // and referenced by LoopHelper.IterationVarRef.; //; // The unrolling directive transforms this into the following loop:; // \code; // OriginalInits; \; // LoopHelper.PreInits; > NewPreInits; // LoopHelper.Counters; /; // for (auto UIV = 0; UIV < LoopHelper.NumIterations; UIV+=Factor) {; // #pragma clang loop unroll_count(Factor); // for (IV = UIV; IV < UIV + Factor && UIV < LoopHelper.NumIterations; ++IV); // {; // LoopHelper.Updates;; // Body;; // }; // }; // \endcode; // where UIV is a new logical iteration counter. IV must be the same VarDecl; // as the original LoopHelper.IterationVarRef because LoopHelper.Updates; // references it. If the partially unrolled loop is associated with another; // loop directive (like an OMPForDirective), it will use checkOpenMPLoop to; // analyze this loop, i.e. the outer loop must fulfill the constraints of an; // OpenMP canonical loop. The inner loop is not an associable canonical loop; // and only exists to defer its unrolling to LLVM's LoopUnroll instead of; // doing it in the frontend (by adding loop metadata). NewPreInits becomes a; // property of the OMPLoopBasedDirective instead of statements in; // CompoundStatement. This is to allow the loop to become a non-outermost loop; // of a canonical loop nest where these PreInits are emitted before the; // outermost directive.; // Determine the PreInit declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:1048,Testability,log,logical,1048,"// Otherwise, we need to provide a de-sugared/transformed AST that can be; // associated with another loop directive.; //; // The canonical loop analysis return by checkTransformableLoopNest assumes; // the following structure to be the same loop without transformations or; // directives applied: \code OriginalInits; LoopHelper.PreInits;; // LoopHelper.Counters;; // for (; IV < LoopHelper.NumIterations; ++IV) {; // LoopHelper.Updates;; // Body;; // }; // \endcode; // where IV is a variable declared and initialized to 0 in LoopHelper.PreInits; // and referenced by LoopHelper.IterationVarRef.; //; // The unrolling directive transforms this into the following loop:; // \code; // OriginalInits; \; // LoopHelper.PreInits; > NewPreInits; // LoopHelper.Counters; /; // for (auto UIV = 0; UIV < LoopHelper.NumIterations; UIV+=Factor) {; // #pragma clang loop unroll_count(Factor); // for (IV = UIV; IV < UIV + Factor && UIV < LoopHelper.NumIterations; ++IV); // {; // LoopHelper.Updates;; // Body;; // }; // }; // \endcode; // where UIV is a new logical iteration counter. IV must be the same VarDecl; // as the original LoopHelper.IterationVarRef because LoopHelper.Updates; // references it. If the partially unrolled loop is associated with another; // loop directive (like an OMPForDirective), it will use checkOpenMPLoop to; // analyze this loop, i.e. the outer loop must fulfill the constraints of an; // OpenMP canonical loop. The inner loop is not an associable canonical loop; // and only exists to defer its unrolling to LLVM's LoopUnroll instead of; // doing it in the frontend (by adding loop metadata). NewPreInits becomes a; // property of the OMPLoopBasedDirective instead of statements in; // CompoundStatement. This is to allow the loop to become a non-outermost loop; // of a canonical loop nest where these PreInits are emitted before the; // outermost directive.; // Determine the PreInit declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,// Iteration variable SourceLocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:12,Modifiability,variab,variable,12,// Internal variable names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:24,Modifiability,variab,variable,24,// Create the iteration variable for the unrolled loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:13,Modifiability,variab,variable,13,// Iteration variable for the inner loop: Reuse the iteration variable created; // by checkOpenMPLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Modifiability,variab,variable,62,// Iteration variable for the inner loop: Reuse the iteration variable created; // by checkOpenMPLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:523,Safety,avoid,avoid,523,"// Unroll metadata for the inner loop.; // This needs to take into account the remainder portion of the unrolled loop,; // hence `unroll(full)` does not apply here, even though the LoopUnroll pass; // supports multiple loop exits. Instead, unroll using a factor equivalent to; // the maximum trip count, which will also generate a remainder loop. Just; // `unroll(enable)` (which could have been useful if the user has not; // specified a concrete factor; even though the outer loop cannot be; // influenced anymore, would avoid more code bloat than necessary) will refuse; // the loop because ""Won't unroll; remainder loop could not be generated when; // assuming runtime trip count"". Even if it did work, it must not choose a; // larger unroll factor than the maximum loop length, or it would always just; // execute the remainder loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Energy Efficiency,schedul,schedule-clause,18,// Do not capture schedule-clause expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:72,Safety,safe,safelen,72,"// OpenMP [2.8.1, simd construct, Description]; // The parameter of the safelen clause must be a constant; // positive integer expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:19,Energy Efficiency,allocate,allocate,19,"// OpenMP [2.11.3, allocate Directive, Description]; // allocator is an expression of omp_allocator_handle_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Performance,concurren,concurrent,18,"// Kind should be concurrent,; // Modifiers introduced in OpenMP 5.1",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:104,Energy Efficiency,schedul,schedule,104,"// OpenMP, 2.7.1, Loop Construct, Restrictions; // The nonmonotonic modifier can only be specified with schedule(dynamic) or; // schedule(guided).; // OpenMP 5.0 does not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:129,Energy Efficiency,schedul,schedule,129,"// OpenMP, 2.7.1, Loop Construct, Restrictions; // The nonmonotonic modifier can only be specified with schedule(dynamic) or; // schedule(guided).; // OpenMP 5.0 does not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:138,Usability,guid,guided,138,"// OpenMP, 2.7.1, Loop Construct, Restrictions; // The nonmonotonic modifier can only be specified with schedule(dynamic) or; // schedule(guided).; // OpenMP 5.0 does not have this restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,Integrability,depend,depend,62,"// OpenMP 5.1 [2.15.1, interop Construct, Restrictions]; // A depend clause can only appear on the directive if a targetsync; // interop-type is present or the interop-var was initialized with; // the targetsync interop-type.; // If there is any 'init' clause diagnose if there is no 'init' clause with; // interop-type of 'targetsync'. Cases involving other directives cannot be; // diagnosed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:11,Modifiability,variab,variable,11,// Interop variable should be of type omp_interop_t.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.3]; // A variable that appears in a private clause must not have an incomplete; // type or a reference type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:68,Modifiability,variab,variable,68,"// OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]; // A variable that is privatized must not have a const-qualified type; // unless it is of class type with a mutable member. This restriction does; // not apply to the firstprivate clause.; //; // OpenMP 3.1 [2.9.3.3, private clause, Restrictions]; // A variable that appears in a private clause must not have a; // const-qualified type unless it is of class type with a mutable member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:316,Modifiability,variab,variable,316,"// OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]; // A variable that is privatized must not have a const-qualified type; // unless it is of class type with a mutable member. This restriction does; // not apply to the firstprivate clause.; //; // OpenMP 3.1 [2.9.3.3, private clause, Restrictions]; // A variable that appears in a private clause must not have a; // const-qualified type unless it is of class type with a mutable member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,Variab,Variables,98,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:307,Modifiability,variab,variable,307,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:384,Modifiability,variab,variable,384,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variably,3,// Variably modified types are not supported for tasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:239,Modifiability,variab,variable,239,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:322,Modifiability,variab,variable,322,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:381,Modifiability,variab,variable,381,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:411,Modifiability,variab,variable,411,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:499,Modifiability,variab,variable,499,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Security,access,accessible,143,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.3]; // A variable that appears in a private clause must not have an incomplete; // type or a reference type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// OpenMP [2.9.3.4, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous copy constructor for the; // class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Security,access,accessible,143,"// OpenMP [2.9.3.4, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous copy constructor for the; // class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variable,31,// If an implicit firstprivate variable found it was checked already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:90,Modifiability,variab,variable,90,"// OpenMP [2.4.13, Data-sharing Attribute Clauses]; // A list item that specifies a given variable may not appear in more; // than one clause on the same directive, except that a variable may be; // specified in both firstprivate and lastprivate clauses.; // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]; // A list item may appear in a firstprivate or lastprivate clause but not; // both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:179,Modifiability,variab,variable,179,"// OpenMP [2.4.13, Data-sharing Attribute Clauses]; // A list item that specifies a given variable may not appear in more; // than one clause on the same directive, except that a variable may be; // specified in both firstprivate and lastprivate clauses.; // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]; // A list item may appear in a firstprivate or lastprivate clause but not; // both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,Variab,Variables,98,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:307,Modifiability,variab,variable,307,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:384,Modifiability,variab,variable,384,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:488,Modifiability,Variab,Variables,488,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:545,Modifiability,Variab,Variables,545,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct, C/C++, p.2]; // Variables with const-qualified type having no mutable member may be; // listed in a firstprivate clause, even if they are static data members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variably,3,// Variably modified types are not supported for tasks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Modifiability,variab,variable,27,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:89,Modifiability,variab,variable,89,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:127,Modifiability,variab,variable,127,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:186,Modifiability,variab,variable,186,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:220,Modifiability,variab,variable,220,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:312,Modifiability,variab,variable,312,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:348,Modifiability,variab,variable,348,"// Generate helper private variable and initialize it with the value of the; // original variable. The address of the original variable is replaced by; // the address of the new private variable in the CodeGen. This new variable; // is not added to IdResolver, so the code in the OpenMP region uses; // original variable for proper diagnostics and variable capturing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variable,15,// Remove temp variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,variab,variable,53,"// OpenMP [2.14.3.5, Restrictions, C/C++, p.2]; // A variable that appears in a lastprivate clause must not have an; // incomplete type or a reference type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:68,Modifiability,variab,variable,68,"// OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]; // A variable that is privatized must not have a const-qualified type; // unless it is of class type with a mutable member. This restriction does; // not apply to the firstprivate clause.; //; // OpenMP 3.1 [2.9.3.5, lastprivate clause, Restrictions]; // A variable that appears in a lastprivate clause must not have a; // const-qualified type unless it is of class type with a mutable member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:320,Modifiability,variab,variable,320,"// OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]; // A variable that is privatized must not have a const-qualified type; // unless it is of class type with a mutable member. This restriction does; // not apply to the firstprivate clause.; //; // OpenMP 3.1 [2.9.3.5, lastprivate clause, Restrictions]; // A variable that appears in a lastprivate clause must not have a; // const-qualified type unless it is of class type with a mutable member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:162,Modifiability,variab,variable,162,"// OpenMP 5.0 [2.19.4.5 lastprivate Clause, Restrictions]; // A list item that appears in a lastprivate clause with the conditional; // modifier must be a scalar variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,Variab,Variables,54,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below.; // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]; // A list item may appear in a firstprivate or lastprivate clause but not; // both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:99,Modifiability,Variab,Variables,99,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below.; // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]; // A list item may appear in a firstprivate or lastprivate clause but not; // both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,variab,variable,53,"// OpenMP [2.14.3.5, Restrictions, C++, p.1,2]; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous default; // constructor for the class type, unless the list item is also specified; // in a firstprivate clause.; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:291,Modifiability,variab,variable,291,"// OpenMP [2.14.3.5, Restrictions, C++, p.1,2]; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous default; // constructor for the class type, unless the list item is also specified; // in a firstprivate clause.; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:148,Security,access,accessible,148,"// OpenMP [2.14.3.5, Restrictions, C++, p.1,2]; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous default; // constructor for the class type, unless the list item is also specified; // in a firstprivate clause.; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:386,Security,access,accessible,386,"// OpenMP [2.14.3.5, Restrictions, C++, p.1,2]; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous default; // constructor for the class type, unless the list item is also specified; // in a firstprivate clause.; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,Variab,Variables,53,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,Variab,Variables,98,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:307,Modifiability,variab,variable,307,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:384,Modifiability,variab,variable,384,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:152,Integrability,depend,dependent,152,"// C++ [basic.lookup.argdep]p3:; // Let X be the lookup set produced by unqualified lookup (3.4.1); // and let Y be the lookup set produced by argument dependent; // lookup (defined as follows). If X contains [...] then Y is; // empty. Otherwise Y is the set of declarations found in the; // namespaces associated with the argument types as described; // below. The set of declarations found by the lookup of the name; // is the union of X and Y.; //; // Here, we compute Y and add its members to the overloaded; // candidate set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:86,Performance,perform,performed,86,"// When considering an associated namespace, the lookup is the; // same as the lookup performed when the associated namespace is; // used as a qualifier (3.4.3.2) except that:; //; // -- Any using-directives in the associated namespace are; // ignored.; //; // -- Any namespace-scope friend functions declared in; // associated classes are visible within their respective; // namespaces even if they are not visible during an ordinary; // lookup (11.4).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Performance,Perform,Perform,3,// Perform ADL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Integrability,depend,dependent,69,/// Stores reduction item and reduction operation only (required for dependent; /// reduction item).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,"// OpenMP [2.1, C/C++]; // A list item is a variable or array section, subject to the restrictions; // specified in Section 2.4 on page 42 and in each of the sections; // describing clauses and directives for which a list appears.; // OpenMP [2.14.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:278,Modifiability,variab,variable,278,"// OpenMP [2.1, C/C++]; // A list item is a variable or array section, subject to the restrictions; // specified in Section 2.4 on page 42 and in each of the sections; // describing clauses and directives for which a list appears.; // OpenMP [2.14.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:311,Modifiability,variab,variable,311,"// OpenMP [2.1, C/C++]; // A list item is a variable or array section, subject to the restrictions; // specified in Section 2.4 on page 42 and in each of the sections; // describing clauses and directives for which a list appears.; // OpenMP [2.14.3.3, Restrictions, p.1]; // A variable that is part of another variable (as an array or; // structure element) cannot appear in a private clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.3]; // A variable that appears in a private clause must not have an incomplete; // type or a reference type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Modifiability,Variab,Variables,54,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.14.3.6, Restrictions, p.3]; // Any number of reduction clauses can be specified on the directive,; // but a list item can appear only once in the reduction clauses for that; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:99,Modifiability,Variab,Variables,99,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.14.3.6, Restrictions, p.3]; // Any number of reduction clauses can be specified on the directive,; // but a list item can appear only once in the reduction clauses for that; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:308,Modifiability,variab,variable,308,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.14.3.6, Restrictions, p.3]; // Any number of reduction clauses can be specified on the directive,; // but a list item can appear only once in the reduction clauses for that; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:385,Modifiability,variab,variable,385,"// OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a Construct]; // Variables with the predetermined data-sharing attributes may not be; // listed in data-sharing attributes clauses, except for the cases; // listed below. For these exceptions only, listing a predetermined; // variable in a data-sharing attribute clause is allowed and overrides; // the variable's predetermined data-sharing attributes.; // OpenMP [2.14.3.6, Restrictions, p.3]; // Any number of reduction clauses can be specified on the directive,; // but a list item can appear only once in the reduction clauses for that; // directive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,variab,variable,98,"// Threadprivates cannot be shared between threads, so dignose if the base; // is a threadprivate variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:71,Safety,avoid,avoid,71,// Try if we can determine constant lengths for all array sections and avoid; // the VLA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:179,Modifiability,variab,variables,179,// For arrays/array sections only:; // Create pseudo array type for private copy. The size for this array will; // be generated during codegen.; // For array subscripts or single variables Private Ty is the same as Type; // (type of the variable or single array element).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:237,Modifiability,variab,variable,237,// For arrays/array sections only:; // Create pseudo array type for private copy. The size for this array will; // be generated during codegen.; // For array subscripts or single variables Private Ty is the same as Type; // (type of the variable or single array element).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variable,31,// Add initializer for private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:5,Modifiability,variab,variable,5,// A variable must not have an incomplete type or a reference type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:68,Modifiability,variab,variable,68,"// OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]; // A variable that is privatized must not have a const-qualified type; // unless it is of class type with a mutable member. This restriction does; // not apply to the firstprivate clause, nor to the linear clause on; // declarative directives (like declare simd).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Usability,simpl,simple-modifier,54,"// OpenMP 5.2 [Section 5.4.6, linear clause]; // step-simple-modifier is exclusive, can't be used with 'val', 'uval', or; // 'ref'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,Modifiability,variab,variables,98,// Warn about zero linear step (it would be probably better specified as; // making corresponding variables 'const').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:27,Deployability,update,update,27,// Walk the vars and build update/final expressions for the CodeGen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:134,Modifiability,variab,variable,134,"// OpenMP [2.15.11, distribute simd Construct]; // A list item may not appear in a linear clause, unless it is the loop; // iteration variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:9,Deployability,update,update,9,// Build update: Var = InitExpr + IV * Step,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:44,Modifiability,variab,variable,44,"// OpenMP [2.1, C/C++]; // A list item is a variable name.; // OpenMP [2.14.4.1, Restrictions, p.1]; // A list item that appears in a copyin clause must be threadprivate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,variab,variable,53,"// OpenMP [2.14.4.1, Restrictions, C/C++, p.2]; // A variable of class type (or array thereof) that appears in a; // copyin clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Security,access,accessible,143,"// OpenMP [2.14.4.1, Restrictions, C/C++, p.2]; // A variable of class type (or array thereof) that appears in a; // copyin clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variably,3,// Variably modified types are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:53,Modifiability,variab,variable,53,"// OpenMP [2.14.4.1, Restrictions, C/C++, p.2]; // A variable of class type (or array thereof) that appears in a; // copyin clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Security,access,accessible,143,"// OpenMP [2.14.4.1, Restrictions, C/C++, p.2]; // A variable of class type (or array thereof) that appears in a; // copyin clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,Integrability,depend,depended,7,// The depended loop count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:32,Integrability,depend,depend,32,"// OpenMP [2.13.9, Summary]; // depend(dependence-type : vec), where dependence-type is:; // 'sink' and where vec is the iteration vector, which has the form:; // x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]; // where n is the value specified by the ordered clause in the loop; // directive, xi denotes the loop iteration variable of the i-th nested; // loop associated with the loop directive, and di is a constant; // non-negative integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Integrability,depend,dependence-type,39,"// OpenMP [2.13.9, Summary]; // depend(dependence-type : vec), where dependence-type is:; // 'sink' and where vec is the iteration vector, which has the form:; // x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]; // where n is the value specified by the ordered clause in the loop; // directive, xi denotes the loop iteration variable of the i-th nested; // loop associated with the loop directive, and di is a constant; // non-negative integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Integrability,depend,dependence-type,69,"// OpenMP [2.13.9, Summary]; // depend(dependence-type : vec), where dependence-type is:; // 'sink' and where vec is the iteration vector, which has the form:; // x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]; // where n is the value specified by the ordered clause in the loop; // directive, xi denotes the loop iteration variable of the i-th nested; // loop associated with the loop directive, and di is a constant; // non-negative integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:321,Modifiability,variab,variable,321,"// OpenMP [2.13.9, Summary]; // depend(dependence-type : vec), where dependence-type is:; // 'sink' and where vec is the iteration vector, which has the form:; // x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]; // where n is the value specified by the ordered clause in the loop; // directive, xi denotes the loop iteration variable of the i-th nested; // loop associated with the loop directive, and di is a constant; // non-negative integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Integrability,depend,depend,23,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the depobj dependence type; // must be expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:81,Integrability,depend,depend,81,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the depobj dependence type; // must be expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:112,Integrability,depend,dependence,112,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the depobj dependence type; // must be expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,Integrability,depend,depend,61,"// OpenMP 5.0 [2.17.11, Restrictions]; // List items used in depend clauses cannot be zero-length array; // sections.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,Integrability,depend,depend,23,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the in, out, inout,; // inoutset, or mutexinoutset dependence types cannot be; // expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:81,Integrability,depend,depend,81,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the in, out, inout,; // inoutset, or mutexinoutset dependence types cannot be; // expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:152,Integrability,depend,dependence,152,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the in, out, inout,; // inoutset, or mutexinoutset dependence types cannot be; // expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:88,Modifiability,variab,variable,88,"// The base of elements of list in a map clause have to be either:; // - a reference to variable or field.; // - a member expression.; // - an array expression.; //; // E.g. if we have the expression 'r.S.Arr[:12]', we want to retrieve the; // reference to 'r'.; //; // If we have:; //; // struct SS {; // Bla S;; // foo() {; // #pragma omp target map (S.Arr[:12]);; // }; // }; //; // We want to retrieve the member expression 'this->S';; // OpenMP 5.0 [2.19.7.1, map Clause, Restrictions, p.2]; // If a list item is an array section, it must specify contiguous storage.; //; // For this restriction it is sufficient that we make sure only references; // to variables or fields and array expressions, and that no array sections; // exist except in the rightmost expression (unless they cover the whole; // dimension of the array). E.g. these would be invalid:; //; // r.ArrS[3:5].Arr[6:7]; //; // r.ArrS[3:5].x; //; // but these would be valid:; // r.ArrS[3].Arr[6:7]; //; // r.ArrS[3].x",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:659,Modifiability,variab,variables,659,"// The base of elements of list in a map clause have to be either:; // - a reference to variable or field.; // - a member expression.; // - an array expression.; //; // E.g. if we have the expression 'r.S.Arr[:12]', we want to retrieve the; // reference to 'r'.; //; // If we have:; //; // struct SS {; // Bla S;; // foo() {; // #pragma omp target map (S.Arr[:12]);; // }; // }; //; // We want to retrieve the member expression 'this->S';; // OpenMP 5.0 [2.19.7.1, map Clause, Restrictions, p.2]; // If a list item is an array section, it must specify contiguous storage.; //; // For this restriction it is sufficient that we make sure only references; // to variables or fields and array expressions, and that no array sections; // exist except in the rightmost expression (unless they cover the whole; // dimension of the array). E.g. these would be invalid:; //; // r.ArrS[3:5].Arr[6:7]; //; // r.ArrS[3:5].x; //; // but these would be valid:; // r.ArrS[3].Arr[6:7]; //; // r.ArrS[3].x",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:91,Modifiability,variab,variable,91,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.2]; // A list item cannot be a variable that is a member of a structure with; // a union type.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:237,Modifiability,variab,variable,237,"// If we got a member expression, we should not expect any array section; // before that:; //; // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.7]; // If a list item is an element of a structure, only the rightmost symbol; // of the variable reference can be an array section.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:102,Testability,test,test,102,// In order to easily check the conflicts we need to match each component of; // the expression under test with the components of the expressions that are; // already in the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variables,3,// Variables to help detecting enclosing problems in data environment nests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,Safety,detect,detecting,21,// Variables to help detecting enclosing problems in data environment nests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,Safety,detect,detect,54,// Expressions must start from the same base. Here we detect at which; // point both expressions diverge from each other and see if we can; // detect if the memory referred to both expressions is contiguous and; // do not overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Safety,detect,detect,143,// Expressions must start from the same base. Here we detect at which; // point both expressions diverge from each other and see if we can; // detect if the memory referred to both expressions is contiguous and; // do not overlap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:128,Modifiability,variab,variable,128,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.3]; // At most one list item can be an array item derived from a given; // variable in map clauses of the same construct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:33,Modifiability,variab,variables,33,// Are we dealing with different variables/fields?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:94,Availability,redundant,redundant,94,"// Check if the extra components of the expressions in the enclosing; // data environment are redundant for the current base declaration.; // If they are, the maps completely overlap, which is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:94,Safety,redund,redundant,94,"// Check if the extra components of the expressions in the enclosing; // data environment are redundant for the current base declaration.; // If they are, the maps completely overlap, which is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,Modifiability,variab,variable,69,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.1]; // A variable for which the type is pointer and an array section; // derived from that variable must not appear as list items of map; // clauses of the same construct.; //; // Also, cover one of the cases in:; // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.5]; // If any part of the original storage of a list item has corresponding; // storage in the device data environment, all of the original storage; // must have corresponding storage in the device data environment.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:151,Modifiability,variab,variable,151,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.1]; // A variable for which the type is pointer and an array section; // derived from that variable must not appear as list items of map; // clauses of the same construct.; //; // Also, cover one of the cases in:; // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.5]; // If any part of the original storage of a list item has corresponding; // storage in the device data environment, all of the original storage; // must have corresponding storage in the device data environment.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:24,Integrability,depend,dependent,24,// Defer the lookup for dependent types. The results will be passed through; // UnresolvedMapper on instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,Integrability,depend,dependent,20,// Perform argument dependent lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Performance,Perform,Perform,3,// Perform argument dependent lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:10,Availability,error,error,10,"// Report error if a mapper is specified, but cannot be found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:31,Modifiability,variab,variable,31,// The base declaration of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:80,Modifiability,variab,variable,80,// We have a list of components and base declarations for each entry in the; // variable list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,"// namespace; // Check the validity of the provided variable list for the provided clause kind; // \a CKind. In the check process the valid expressions, mappable expression; // components, variables, and user-defined mappers are extracted and used to; // fill \a ProcessedVarList, \a VarComponents, \a VarBaseDeclarations, and \a; // UDMapperList in MVLI. \a MapType, \a IsMapTypeImplicit, \a MapperIdScopeSpec,; // and \a MapperId are expected to be valid if the clause kind is 'map'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:189,Modifiability,variab,variables,189,"// namespace; // Check the validity of the provided variable list for the provided clause kind; // \a CKind. In the check process the valid expressions, mappable expression; // components, variables, and user-defined mappers are extracted and used to; // fill \a ProcessedVarList, \a VarComponents, \a VarBaseDeclarations, and \a; // UDMapperList in MVLI. \a MapType, \a IsMapTypeImplicit, \a MapperIdScopeSpec,; // and \a MapperId are expected to be valid if the clause kind is 'map'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:33,Modifiability,variab,variable,33,// Skip restriction checking for variable or field declarations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:165,Modifiability,variab,variable,165,"// For the following checks, we rely on the base declaration which is; // expected to be associated with the last component. The declaration is; // expected to be a variable or a field (if 'this' is being mapped).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:147,Deployability,update,update,147,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.10]; // threadprivate variables cannot appear in a map clause.; // OpenMP 4.5 [2.10.5, target update Construct]; // threadprivate variables cannot appear in a from clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:75,Modifiability,variab,variables,75,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.10]; // threadprivate variables cannot appear in a map clause.; // OpenMP 4.5 [2.10.5, target update Construct]; // threadprivate variables cannot appear in a from clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:183,Modifiability,variab,variables,183,"// OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.10]; // threadprivate variables cannot appear in a map clause.; // OpenMP 4.5 [2.10.5, target update Construct]; // threadprivate variables cannot appear in a from clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:30,Deployability,update,update,30,"// OpenMP 4.5 [2.10.5, target update Construct]; // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C++, p.1]; // If the type of a list item is a reference to a type T then the type will; // be considered to be T for all purposes of this clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:30,Deployability,update,update,30,"// OpenMP 4.5 [2.10.5, target update Construct, Restrictions, p.4]; // A list item in a to or from clause must have a mappable type.; // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.9]; // A list item must have a mappable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,Deployability,release,release,143,"// target exit_data; // OpenMP [2.10.3, Restrictions, p. 102]; // A map-type must be specified in all map clauses and must be either; // from, release, or delete. Starting with OpenMP 5.2 the default map; // type is `from` if no map type is present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:36,Availability,error,errors,36,"// Process map-type-modifiers, flag errors for duplicate modifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:57,Modifiability,variab,variables,57,// We need to produce a map clause even if we don't have variables so that; // other diagnostics related with non-existing map clauses are accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:335,Modifiability,variab,variable,335,"// Create 'T* omp_parm;T omp_in;'. All references to 'omp_in' will; // be replaced by '*omp_parm' during codegen. This required because 'omp_in'; // uses semantics of argument handles by value, but it should be passed by; // reference. C lang does not support references, so pass all parameters as; // pointers.; // Create 'T omp_in;' variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:339,Modifiability,variab,variable,339,"// Create 'T* omp_parm;T omp_out;'. All references to 'omp_out' will; // be replaced by '*omp_parm' during codegen. This required because 'omp_out'; // uses semantics of argument handles by value, but it should be passed by; // reference. C lang does not support references, so pass all parameters as; // pointers.; // Create 'T omp_out;' variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:343,Modifiability,variab,variable,343,"// Create 'T* omp_parm;T omp_priv;'. All references to 'omp_priv' will; // be replaced by '*omp_parm' during codegen. This required because 'omp_priv'; // uses semantics of argument handles by value, but it should be passed by; // reference. C lang does not support references, so pass all parameters as; // pointers.; // Create 'T omp_priv;' variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:343,Modifiability,variab,variable,343,"// Create 'T* omp_parm;T omp_orig;'. All references to 'omp_orig' will; // be replaced by '*omp_parm' during codegen. This required because 'omp_orig'; // uses semantics of argument handles by value, but it should be passed by; // reference. C lang does not support references, so pass all parameters as; // pointers.; // Create 'T omp_orig;' variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:60,Modifiability,variab,variable,60,"// OpenMP 5.0, 2.10.1 task Construct.; // event-handle is a variable of the omp_event_handle_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:3,Modifiability,Variab,Variable,3,// Variable category is not specified - mark all categories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:206,Modifiability,variab,variables,206,"// OpenMP 5.0, 2.12.7 declare target Directive, Restrictions; // If a lambda declaration and definition appears between a; // declare target directive and the matching end declare target; // directive, all variables that are captured by the lambda; // expression must also appear in a to clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:15,Modifiability,variab,variables,15,// Only global variables can be marked as declare target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:25,Modifiability,variab,variable,25,// 2.10.6: threadprivate variable cannot appear in a declare target; // directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,Modifiability,variab,variables,61,"/// A function that keeps a record of all the Decls that are variables, has; /// OMPDeclareTargetDeclAttr, and has global storage in the DeclVector. Pop; /// each Decl one at a time and use the inherited 'visit' functions to look; /// for DeclRefExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:194,Modifiability,inherit,inherited,194,"/// A function that keeps a record of all the Decls that are variables, has; /// OMPDeclareTargetDeclAttr, and has global storage in the DeclVector. Pop; /// each Decl one at a time and use the inherited 'visit' functions to look; /// for DeclRefExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:39,Modifiability,variab,variables,39,/// Adding OMPDeclareTargetDeclAttr to variables with static storage; /// duration that are referenced in the initializer expression list of; /// variables with static storage duration in declare target directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:146,Modifiability,variab,variables,146,/// Adding OMPDeclareTargetDeclAttr to variables with static storage; /// duration that are referenced in the initializer expression list of; /// variables with static storage duration in declare target directive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:34,Availability,error,errors,34,"// Process motion-modifiers, flag errors for duplicate modifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:34,Availability,error,errors,34,"// Process motion-modifiers, flag errors for duplicate modifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,Modifiability,variab,variable,21,// Build the private variable and the expression that refers to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:17,Modifiability,variab,variable,17,// Add temporary variable to initialize the private copy of the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_ptr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:106,Modifiability,variab,variable,106,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_ptr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:195,Modifiability,variab,variable,195,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_ptr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,Modifiability,variab,variable,52,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_addr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:106,Modifiability,variab,variable,106,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_addr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:196,Modifiability,variab,variable,196,// We need to add a data sharing attribute for this variable to make sure it; // is correctly captured. A variable that shows up in a use_device_addr has; // similar properties of a first private variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:18,Energy Efficiency,allocate,allocate,18,"// OpenMP [2.11.4 allocate Clause, Description]; // allocator is an expression of omp_allocator_handle_t type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:22,Energy Efficiency,allocate,allocate,22,"// OpenMP 5.0, 2.11.4 allocate Clause, Restrictions.; // allocate clauses that appear on a target construct or on constructs in a; // target region must specify an allocator expression unless a requires; // directive with the dynamic_allocators clause is present in the same; // compilation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:57,Energy Efficiency,allocate,allocate,57,"// OpenMP 5.0, 2.11.4 allocate Clause, Restrictions.; // allocate clauses that appear on a target construct or on constructs in a; // target region must specify an allocator expression unless a requires; // directive with the dynamic_allocators clause is present in the same; // compilation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:29,Modifiability,variab,variables,29,// Analyze and build list of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:68,Modifiability,variab,variable,68,// Do not map by default allocator traits if it is a standalone; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:407,Integrability,rout,routines,407,"//===--- SemaOverload.cpp - C++ Overloading -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides Sema routines for C++ overloading.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:18,Integrability,rout,routine,18,/// A convenience routine for creating a decayed reference to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:77,Deployability,patch,patch,77,// NOTE(gbiv): This may not be completely right --; // it was omitted by the patch that added; // ICK_Zero_Event_Conversion,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:80,Deployability,patch,patch,80,// NOTE(ctopper): This may not be completely right --; // it was omitted by the patch that added; // ICK_Zero_Queue_Conversion,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,Integrability,wrap,wrapping,24,// We can have cleanups wrapping the converted expression; these need to be; // preserved so that destructors run if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Integrability,depend,dependent,17,"// If it's value-dependent, we can't tell whether it's narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Modifiability,Variab,Variables,3,// Variables are always narrowings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Integrability,depend,dependent,17,"// If it's value-dependent, we can't tell whether it's narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Integrability,depend,dependent,17,"// If it's value-dependent, we can't tell whether it's narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:23,Modifiability,variab,variables,23,// Such conversions on variables are always narrowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,Availability,error,error,68,/// dump - Print this standard conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:72,Availability,error,error,72,/// dump - Print this user-defined conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,Availability,error,error,68,/// dump - Print this implicit conversion sequence to standard; /// error. Useful for debugging overloading issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Energy Efficiency,allocate,allocate,17,// FIXME: Should allocate from normal heap so that we can free this later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Energy Efficiency,allocate,allocate,17,// FIXME: Should allocate from normal heap so that we can free this later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:36,Energy Efficiency,allocate,allocate,36,// FIXME: It's slightly wasteful to allocate two TemplateArguments for this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Energy Efficiency,allocate,allocate,17,// FIXME: Should allocate from normal heap so that we can free this later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:107,Modifiability,rewrite,rewrite,107,"// C++2a [over.match.oper]p4:; // A non-template function or function template F named operator== is a; // rewrite target with first operand o unless a search for the name operator!=; // in the scope S from the instantiation context of the operator expression; // finds a function or function template that would correspond; // ([basic.scope.scope]) to F if its name were operator==, where S is the; // scope of the class type of o if F is a class member, and the namespace; // scope of which F is a member otherwise. A function template specialization; // named operator== is a rewrite target if its function template is a rewrite; // target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:579,Modifiability,rewrite,rewrite,579,"// C++2a [over.match.oper]p4:; // A non-template function or function template F named operator== is a; // rewrite target with first operand o unless a search for the name operator!=; // in the scope S from the instantiation context of the operator expression; // finds a function or function template that would correspond; // ([basic.scope.scope]) to F if its name were operator==, where S is the; // scope of the class type of o if F is a class member, and the namespace; // scope of which F is a member otherwise. A function template specialization; // named operator== is a rewrite target if its function template is a rewrite; // target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:624,Modifiability,rewrite,rewrite,624,"// C++2a [over.match.oper]p4:; // A non-template function or function template F named operator== is a; // rewrite target with first operand o unless a search for the name operator!=; // in the scope S from the instantiation context of the operator expression; // finds a function or function template that would correspond; // ([basic.scope.scope]) to F if its name were operator==, where S is the; // scope of the class type of o if F is a class member, and the namespace; // scope of which F is a member otherwise. A function template specialization; // named operator== is a rewrite target if its function template is a rewrite; // target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:249,Availability,error,errors,249,"/// checkPlaceholderForOverload - Do any interesting placeholder-like; /// preprocessing on the given expression.; ///; /// \param unbridgedCasts a collection to which to add unbridged casts;; /// without this, they will be immediately diagnosed as errors; ///; /// Return true on unrecoverable error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:295,Availability,error,error,295,"/// checkPlaceholderForOverload - Do any interesting placeholder-like; /// preprocessing on the given expression.; ///; /// \param unbridgedCasts a collection to which to add unbridged casts;; /// without this, they will be immediately diagnosed as errors; ///; /// Return true on unrecoverable error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:101,Integrability,rout,routine,101,"/// Determine whether the given New declaration is an overload of the; /// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if; /// New and Old cannot be overloaded, e.g., if New has the same signature as; /// some function in Old (C++ 1.3.10) or if the Old declarations aren't; /// functions (or function templates) at all. When it does return Ovl_Match or; /// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be; /// overloaded with. This decl may be a UsingShadowDecl on top of the underlying; /// declaration.; ///; /// Example: Given the following input:; ///; /// void f(int, float); // #1; /// void f(int, int); // #2; /// int f(int, int); // #3; ///; /// When we process #1, there is no previous declaration of ""f"", so IsOverload; /// will not be used.; ///; /// When we process #2, Old contains only the FunctionDecl for #1. By comparing; /// the parameter types, we see that #1 and #2 are overloaded (since they have; /// different signatures), so this routine returns Ovl_Overload; MatchedDecl is; /// unchanged.; ///; /// When we process #3, Old is an overload set containing #1 and #2. We compare; /// the signatures of #3 to #1 (they're overloaded, so we do nothing) and then; /// #3 to #2. Since the signatures of #3 and #2 are identical (return types of; /// functions are not part of the signature), IsOverload returns Ovl_Match and; /// MatchedDecl will be set to point to the FunctionDecl for #2.; ///; /// 'NewIsUsingShadowDecl' indicates that 'New' is being introduced into a class; /// by a using declaration. The rules for whether to hide shadow declarations; /// ignore some properties which otherwise figure into a function template's; /// signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:1005,Integrability,rout,routine,1005,"/// Determine whether the given New declaration is an overload of the; /// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if; /// New and Old cannot be overloaded, e.g., if New has the same signature as; /// some function in Old (C++ 1.3.10) or if the Old declarations aren't; /// functions (or function templates) at all. When it does return Ovl_Match or; /// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be; /// overloaded with. This decl may be a UsingShadowDecl on top of the underlying; /// declaration.; ///; /// Example: Given the following input:; ///; /// void f(int, float); // #1; /// void f(int, int); // #2; /// int f(int, int); // #3; ///; /// When we process #1, there is no previous declaration of ""f"", so IsOverload; /// will not be used.; ///; /// When we process #2, Old contains only the FunctionDecl for #1. By comparing; /// the parameter types, we see that #1 and #2 are overloaded (since they have; /// different signatures), so this routine returns Ovl_Overload; MatchedDecl is; /// unchanged.; ///; /// When we process #3, Old is an overload set containing #1 and #2. We compare; /// the signatures of #3 to #1 (they're overloaded, so we do nothing) and then; /// #3 to #2. Since the signatures of #3 and #2 are identical (return types of; /// functions are not part of the signature), IsOverload returns Ovl_Match and; /// MatchedDecl will be set to point to the FunctionDecl for #2.; ///; /// 'NewIsUsingShadowDecl' indicates that 'New' is being introduced into a class; /// by a using declaration. The rules for whether to hide shadow declarations; /// ignore some properties which otherwise figure into a function template's; /// signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:182,Integrability,depend,dependent,182,"// Optimistically assume that an unresolved using decl will; // overload; if it doesn't, we'll have to diagnose during; // template instantiation.; //; // Exception: if the scope is dependent and this is not a class; // member, the using declaration can only introduce an enumerator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:809,Integrability,depend,dependent,809,"// C++ [temp.friend]p1:; // For a friend function declaration that is not a template declaration:; // -- if the name of the friend is a qualified or unqualified template-id,; // [...], otherwise; // -- if the name of the friend is a qualified-id and a matching; // non-template function is found in the specified class or namespace,; // the friend declaration refers to that function, otherwise,; // -- if the name of the friend is a qualified-id and a matching function; // template is found in the specified class or namespace, the friend; // declaration refers to the deduced specialization of that function; // template, otherwise; // -- the name shall be an unqualified-id [...]; // If we get here for a qualified friend declaration, we've just reached the; // third bullet. If the type of the friend is dependent, skip this lookup; // until instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:74,Performance,perform,perform,74,"// We're not in the case above, so there is no conversion that; // we can perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:794,Availability,avail,available,794,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:325,Integrability,rout,routine,325,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:613,Integrability,rout,routine,613,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,Performance,perform,perform,39,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:220,Performance,perform,perform,220,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:668,Performance,perform,performed,668,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:700,Performance,perform,perform,700,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:161,Performance,perform,perform,161,"// We don't actually check at this point whether there is a valid; // copy/move constructor, since overloading just assumes that it; // exists. When we actually perform initialization, we'll find the; // appropriate constructor to copy the returned object, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:218,Availability,error,error,218,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:224,Integrability,message,message,224,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,PerformImplicitConversion,4,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:32,Performance,Perform,Perform,32,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:194,Performance,perform,performing,194,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:36,Modifiability,extend,extended,36,"// There are no conversions between extended vector types, only identity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:36,Modifiability,extend,extended,36,// There are no conversions between extended vector types other than the; // identity conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:290,Modifiability,polymorphi,polymorphism,290,"// We can perform the conversion between vector types in the following cases:; // 1)vector types are equivalent AltiVec and GCC vector types; // 2)lax vector conversions are permitted and the vector types are of the; // same size; // 3)the destination type does not have the ARM MVE strict-polymorphism; // attribute, which inhibits lax vector conversion for overload resolution; // only",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Performance,perform,perform,10,"// We can perform the conversion between vector types in the following cases:; // 1)vector types are equivalent AltiVec and GCC vector types; // 2)lax vector conversions are permitted and the vector types are of the; // same size; // 3)the destination type does not have the ARM MVE strict-polymorphism; // attribute, which inhibits lax vector conversion for overload resolution; // only",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:443,Integrability,rout,routine,443,"/// IsStandardConversion - Determines whether there is a standard; /// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the; /// expression From to the type ToType. Standard conversion sequences; /// only consider non-class types; for conversions that involve class; /// types, use TryImplicitConversion. If a conversion exists, SCS will; /// contain the standard conversion sequence required to perform this; /// conversion and this routine will return true. Otherwise, this; /// routine will return false and the value of SCS is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:490,Integrability,rout,routine,490,"/// IsStandardConversion - Determines whether there is a standard; /// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the; /// expression From to the type ToType. Standard conversion sequences; /// only consider non-class types; for conversions that involve class; /// types, use TryImplicitConversion. If a conversion exists, SCS will; /// contain the standard conversion sequence required to perform this; /// conversion and this routine will return true. Otherwise, this; /// routine will return false and the value of SCS is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:405,Performance,perform,perform,405,"/// IsStandardConversion - Determines whether there is a standard; /// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the; /// expression From to the type ToType. Standard conversion sequences; /// only consider non-class types; for conversions that involve class; /// types, use TryImplicitConversion. If a conversion exists, SCS will; /// contain the standard conversion sequence required to perform this; /// conversion and this routine will return true. Otherwise, this; /// routine will return false and the value of SCS is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,Safety,abort,abort,68,"// There are no standard conversions for class types in C++, so; // abort early. When overloading in C, however, we do permit them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:41,Modifiability,extend,extended,41,// Conversions between IEEE-quad and IBM-extended semantics are not; // permitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:27,Deployability,update,updated,27,// tryAtomicConversion has updated the standard conversion sequence; // appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:136,Usability,simpl,simpler,136,"// Third is Identity, because Second should rank us worse than any other; // conversion. This could also be ICK_Qualification, but it's simpler to just; // lump everything in with the second conversion, and we don't gain anything; // from making this ICK_Qualification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:606,Modifiability,extend,extended,606,"// C++11 [conv.prom]p3:; // A prvalue of an unscoped enumeration type whose underlying type is not; // fixed (7.2) can be converted to an rvalue a prvalue of the first of the; // following types that can represent all the values of the enumeration; // (i.e., the values in the range bmin to bmax as described in 7.2): int,; // unsigned int, long int, unsigned long int, long long int, or unsigned; // long long int. If none of the types in that list can represent all the; // values of the enumeration, an rvalue a prvalue of an unscoped enumeration; // type can be converted to an rvalue a prvalue of the extended integer type; // with lowest integer conversion rank (4.13) greater than the rank of long; // long in which all the values of the enumeration can be represented. If; // there are two such extended types, the signed one is chosen.; // C++11 [conv.prom]p4:; // A prvalue of an unscoped enumeration type whose underlying type is fixed; // can be converted to a prvalue of its underlying type. Moreover, if; // integral promotion can be applied to its underlying type, a prvalue of an; // unscoped enumeration type whose underlying type is fixed can also be; // converted to a prvalue of the promoted underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:803,Modifiability,extend,extended,803,"// C++11 [conv.prom]p3:; // A prvalue of an unscoped enumeration type whose underlying type is not; // fixed (7.2) can be converted to an rvalue a prvalue of the first of the; // following types that can represent all the values of the enumeration; // (i.e., the values in the range bmin to bmax as described in 7.2): int,; // unsigned int, long int, unsigned long int, long long int, or unsigned; // long long int. If none of the types in that list can represent all the; // values of the enumeration, an rvalue a prvalue of an unscoped enumeration; // type can be converted to an rvalue a prvalue of the extended integer type; // with lowest integer conversion rank (4.13) greater than the rank of long; // long in which all the values of the enumeration can be represented. If; // there are two such extended types, the signed one is chosen.; // C++11 [conv.prom]p4:; // A prvalue of an unscoped enumeration type whose underlying type is fixed; // can be converted to a prvalue of its underlying type. Moreover, if; // integral promotion can be applied to its underlying type, a prvalue of an; // unscoped enumeration type whose underlying type is fixed can also be; // converted to a prvalue of the promoted underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Performance,perform,perform,10,"// We can perform an integral promotion to the underlying type of the enum,; // even if that's not the promoted type. Note that the check for promoting; // the underlying type is based on the type alone, and does not consider; // the bitfield-ness of the actual source expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:535,Performance,perform,perform,535,"// An rvalue for an integral bit-field (9.6) can be converted to an; // rvalue of type int if int can represent all the values of the; // bit-field; otherwise, it can be converted to unsigned int if; // unsigned int can represent all the values of the bit-field. If; // the bit-field is larger yet, no integral promotion applies to; // it. If the bit-field has an enumerated type, it is treated as any; // other value of that type for promotion purposes (C++ 4.5p3).; // FIXME: We should delay checking of bit-fields until we actually perform the; // conversion.; //; // FIXME: In C, only bit-fields of types _Bool, int, or unsigned int may be; // promoted, per C11 6.3.1.1/2. We promote all bit-fields (including enum; // bit-fields and those whose underlying type is larger than int) for GCC; // compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,Integrability,depend,dependent,16,// Handle value-dependent integral null pointer constants correctly.; // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:383,Integrability,rout,routine,383,"/// IsPointerConversion - Determines whether the conversion of the; /// expression From, which has the (possibly adjusted) type FromType,; /// can be converted to the type ToType via a pointer conversion (C++; /// 4.10). If so, returns true and places the converted type (that; /// might differ from ToType in its cv-qualifiers at some level) into; /// ConvertedType.; ///; /// This routine also supports conversions to and from block pointers; /// and conversions with Objective-C's 'id', 'id<protocols...>', and; /// pointers to interfaces. FIXME: Once we've determined the; /// appropriate overloading rules for Objective-C, we may want to; /// split the Objective-C checks into a different routine; however,; /// GCC seems to consider all of these conversions to be pointer; /// conversions, so for now they live here. IncompatibleObjC will be; /// set if the conversion is an allowed Objective-C conversion that; /// should result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:494,Integrability,protocol,protocols,494,"/// IsPointerConversion - Determines whether the conversion of the; /// expression From, which has the (possibly adjusted) type FromType,; /// can be converted to the type ToType via a pointer conversion (C++; /// 4.10). If so, returns true and places the converted type (that; /// might differ from ToType in its cv-qualifiers at some level) into; /// ConvertedType.; ///; /// This routine also supports conversions to and from block pointers; /// and conversions with Objective-C's 'id', 'id<protocols...>', and; /// pointers to interfaces. FIXME: Once we've determined the; /// appropriate overloading rules for Objective-C, we may want to; /// split the Objective-C checks into a different routine; however,; /// GCC seems to consider all of these conversions to be pointer; /// conversions, so for now they live here. IncompatibleObjC will be; /// set if the conversion is an allowed Objective-C conversion that; /// should result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:531,Integrability,interface,interfaces,531,"/// IsPointerConversion - Determines whether the conversion of the; /// expression From, which has the (possibly adjusted) type FromType,; /// can be converted to the type ToType via a pointer conversion (C++; /// 4.10). If so, returns true and places the converted type (that; /// might differ from ToType in its cv-qualifiers at some level) into; /// ConvertedType.; ///; /// This routine also supports conversions to and from block pointers; /// and conversions with Objective-C's 'id', 'id<protocols...>', and; /// pointers to interfaces. FIXME: Once we've determined the; /// appropriate overloading rules for Objective-C, we may want to; /// split the Objective-C checks into a different routine; however,; /// GCC seems to consider all of these conversions to be pointer; /// conversions, so for now they live here. IncompatibleObjC will be; /// set if the conversion is an allowed Objective-C conversion that; /// should result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:694,Integrability,rout,routine,694,"/// IsPointerConversion - Determines whether the conversion of the; /// expression From, which has the (possibly adjusted) type FromType,; /// can be converted to the type ToType via a pointer conversion (C++; /// 4.10). If so, returns true and places the converted type (that; /// might differ from ToType in its cv-qualifiers at some level) into; /// ConvertedType.; ///; /// This routine also supports conversions to and from block pointers; /// and conversions with Objective-C's 'id', 'id<protocols...>', and; /// pointers to interfaces. FIXME: Once we've determined the; /// appropriate overloading rules for Objective-C, we may want to; /// split the Objective-C checks into a different routine; however,; /// GCC seems to consider all of these conversions to be pointer; /// conversions, so for now they live here. IncompatibleObjC will be; /// set if the conversion is an allowed Objective-C conversion that; /// should result in a warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:633,Availability,CheckPoint,CheckPointerConversion,633,"// C++ [conv.ptr]p3:; //; // An rvalue of type ""pointer to cv D,"" where D is a class type,; // can be converted to an rvalue of type ""pointer to cv B,"" where; // B is a base class (clause 10) of D. If B is an inaccessible; // (clause 11) or ambiguous (10.2) base class of D, a program that; // necessitates this conversion is ill-formed. The result of the; // conversion is a pointer to the base class sub-object of the; // derived class object. The null pointer value is converted to; // the null pointer value of the destination type.; //; // Note that we do not check for ambiguity or inaccessibility; // here. That is handled by CheckPointerConversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,Availability,down,downcast,39,"// Okay: this is some kind of implicit downcast of Objective-C; // interfaces, which is permitted. However, we're going to; // complain about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,Integrability,interface,interfaces,67,"// Okay: this is some kind of implicit downcast of Objective-C; // interfaces, which is permitted. However, we're going to; // complain about it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform the quick checks that will tell us whether these; // function types are obviously different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Safety,Abort,Abort,37,// Function types are too different. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Safety,Abort,Abort,37,// Argument types are too different. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:104,Performance,perform,performing,104,"/// Determine whether this is an Objective-C writeback conversion,; /// used for parameter passing when performing automatic reference counting.; ///; /// \param FromType The type we're converting form.; ///; /// \param ToType The type we're converting to.; ///; /// \param ConvertedType The type that will be produced after applying; /// this conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform the quick checks that will tell us whether these; // function types are obviously different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Safety,Abort,Abort,37,// Argument types are too different. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Integrability,rout,routine,38,"/// FunctionParamTypesAreEqual - This routine checks two function proto types; /// for equality of their parameter types. Caller has already checked that; /// they have same number of parameters. If the parameters are different,; /// ArgPos will have the parameter index of the first different parameter.; /// If `Reversed` is true, the parameters of `NewType` will be compared in; /// reverse order. That's useful if one of the functions is being used as a C++20; /// synthesized operator overload with a reversed parameter order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Availability,CheckPoint,CheckPointerConversion,4,"/// CheckPointerConversion - Check the pointer conversion from the; /// expression From to the type ToType. This routine checks for; /// ambiguous or inaccessible derived-to-base pointer; /// conversions for which IsPointerConversion has already returned; /// true. It returns true and produces a diagnostic if there was an; /// error, or returns false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:329,Availability,error,error,329,"/// CheckPointerConversion - Check the pointer conversion from the; /// expression From to the type ToType. This routine checks for; /// ambiguous or inaccessible derived-to-base pointer; /// conversions for which IsPointerConversion has already returned; /// true. It returns true and produces a diagnostic if there was an; /// error, or returns false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,Integrability,rout,routine,113,"/// CheckPointerConversion - Check the pointer conversion from the; /// expression From to the type ToType. This routine checks for; /// ambiguous or inaccessible derived-to-base pointer; /// conversions for which IsPointerConversion has already returned; /// true. It returns true and produces a diagnostic if there was an; /// error, or returns false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:361,Availability,error,error,361,"/// CheckMemberPointerConversion - Check the member pointer conversion from the; /// expression From to the type ToType. This routine checks for ambiguous or; /// virtual or inaccessible base-to-derived member pointer conversions; /// for which IsMemberPointerConversion has already returned true. It returns; /// true and produces a diagnostic if there was an error, or returns false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:126,Integrability,rout,routine,126,"/// CheckMemberPointerConversion - Check the member pointer conversion from the; /// expression From to the type ToType. This routine checks for ambiguous or; /// virtual or inaccessible base-to-derived member pointer conversions; /// for which IsMemberPointerConversion has already returned true. It returns; /// true and produces a diagnostic if there was an error, or returns false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:21,Integrability,depend,dependent,21,// FIXME: What about dependent types?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,Perform,4,"/// Perform a single iteration of the loop for checking if a qualification; /// conversion is valid.; ///; /// Specifically, check whether any change between the qualifiers of \p; /// FromType and \p ToType is permissible, given knowledge about whether every; /// outer layer is const-qualified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,Deployability,update,updates,113,"/// - Determine whether this is a conversion from a scalar type to an; /// atomic type.; ///; /// If successful, updates \c SCS's second and third steps in the conversion; /// sequence to finish the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:284,Integrability,rout,routine,284,"/// Determines whether there is a user-defined conversion sequence; /// (C++ [over.ics.user]) that converts expression From to the type; /// ToType. If such a conversion exists, User will contain the; /// user-defined conversion sequence that performs such a conversion; /// and this routine will return true. Otherwise, this routine returns; /// false and User is unspecified.; ///; /// \param AllowExplicit true if the conversion should consider C++0x; /// ""explicit"" conversion functions as well as non-explicit conversion; /// functions (C++0x [class.conv.fct]p2).; ///; /// \param AllowObjCConversionOnExplicit true if the conversion should; /// allow an extra Objective-C pointer conversion on uses of explicit; /// constructors. Requires \c AllowExplicit to also be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:326,Integrability,rout,routine,326,"/// Determines whether there is a user-defined conversion sequence; /// (C++ [over.ics.user]) that converts expression From to the type; /// ToType. If such a conversion exists, User will contain the; /// user-defined conversion sequence that performs such a conversion; /// and this routine will return true. Otherwise, this routine returns; /// false and User is unspecified.; ///; /// \param AllowExplicit true if the conversion should consider C++0x; /// ""explicit"" conversion functions as well as non-explicit conversion; /// functions (C++0x [class.conv.fct]p2).; ///; /// \param AllowObjCConversionOnExplicit true if the conversion should; /// allow an extra Objective-C pointer conversion on uses of explicit; /// constructors. Requires \c AllowExplicit to also be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:243,Performance,perform,performs,243,"/// Determines whether there is a user-defined conversion sequence; /// (C++ [over.ics.user]) that converts expression From to the type; /// ToType. If such a conversion exists, User will contain the; /// user-defined conversion sequence that performs such a conversion; /// and this routine will return true. Otherwise, this routine returns; /// false and User is unspecified.; ///; /// \param AllowExplicit true if the conversion should consider C++0x; /// ""explicit"" conversion functions as well as non-explicit conversion; /// functions (C++0x [class.conv.fct]p2).; ///; /// \param AllowObjCConversionOnExplicit true if the conversion should; /// allow an extra Objective-C pointer conversion on uses of explicit; /// constructors. Requires \c AllowExplicit to also be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:1611,Availability,failure,failure,1611,"// (C++ 13.3.3.2p2): When comparing the basic forms of implicit; // conversion sequences (as defined in 13.3.3.1); // -- a standard conversion sequence (13.3.3.1.1) is a better; // conversion sequence than a user-defined conversion sequence or; // an ellipsis conversion sequence, and; // -- a user-defined conversion sequence (13.3.3.1.2) is a better; // conversion sequence than an ellipsis conversion sequence; // (13.3.3.1.3).; //; // C++0x [over.best.ics]p10:; // For the purpose of ranking implicit conversion sequences as; // described in 13.3.3.2, the ambiguous conversion sequence is; // treated as a user-defined sequence that is indistinguishable; // from any other user-defined conversion sequence.; // String literal to 'char *' conversion has been deprecated in C++03. It has; // been removed from C++11. We still accept this conversion, if it happens at; // the best viable function. Otherwise, this conversion is considered worse; // than ellipsis conversion. Consider this as an extension; this is not in the; // standard. For example:; //; // int &f(...); // #1; // void f(char*); // #2; // void g() { int &r = f(""foo""); }; //; // In C++03, we pick #2 as the best viable function.; // In C++11, we pick #1 as the best viable function, because ellipsis; // conversion is better than string-literal to char* conversion (since there; // is no such conversion in C++11). If there was no #1 at all or #1 couldn't; // convert arguments, #2 would be the best viable function in C++11.; // If the best viable function has this conversion, a warning will be issued; // in C++03, or an ExtWarn (+SFINAE failure) will be issued in C++11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:123,Modifiability,inherit,inheritance,123,// Both conversion sequences are conversions to void; // pointers. Compare the source types to determine if there's an; // inheritance relationship in their sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:25,Integrability,interface,interface,25,"// Objective-C++: If one interface is more specific than the; // other, it is the better one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:333,Availability,error,error,333,"// In Microsoft mode (below 19.28), prefer an integral conversion to a; // floating-to-integral conversion if the integral conversion; // is between types of the same size.; // For example:; // void f(float);; // void f(int);; // int main {; // long a;; // f(a);; // }; // Here, MSVC will call f(int) instead of generating a compile error; // as clang will do in standard mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:341,Availability,error,error,341,"// Prefer a compatible vector conversion over a lax vector conversion; // For example:; //; // typedef float __v4sf __attribute__((__vector_size__(16)));; // void f(vector float);; // void f(vector signed int);; // int main() {; // __v4sf a;; // f(a);; // }; // Here, we'd like to choose f(vector float) and not; // report an ambiguous call error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,Usability,learn,learn,39,"// If the types are the same, we won't learn anything by unwrapping; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:301,Integrability,interface,interface,301,"/// CompareDerivedToBaseConversions - Compares two standard conversion; /// sequences to determine whether they can be ranked based on their; /// various kinds of derived-to-base conversions (C++; /// [over.ics.rank]p4b3). As part of these checks, we also look at; /// conversions between Objective-C interface types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:20,Performance,perform,performed,20,// Track whether we performed a qualification conversion anywhere other; // than the top level. This matters for ranking reference bindings in; // overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:103,Performance,perform,performs,103,"// FIXME: As a speculative fix to a defect introduced by CWG2352, we rank; // a reference binding that performs a non-top-level qualification; // conversion as a qualification conversion, not as an identity conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:78,Availability,down,down,78,"// Type is an aggregate, argument is an init list. At this point it comes; // down to checking whether the initialization works.; // FIXME: Find out whether this parameter is consumed or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:559,Performance,perform,perform,559,"// C++0x [over.match.funcs]p4:; // For non-static member functions, the type of the implicit object; // parameter is; //; // - ""lvalue reference to cv X"" for functions declared without a; // ref-qualifier or with the & ref-qualifier; // - ""rvalue reference to cv X"" for functions declared with the &&; // ref-qualifier; //; // where X is the class of which the function is a member and cv is the; // cv-qualification on the member function declaration.; //; // However, when finding an implicit conversion sequence for the argument, we; // are not allowed to perform user-defined conversions; // (C++ [over.match.funcs]p5). We perform a simplified version of; // reference binding here, that allows class rvalues to bind to; // non-constant references.; // First check the qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:627,Performance,perform,perform,627,"// C++0x [over.match.funcs]p4:; // For non-static member functions, the type of the implicit object; // parameter is; //; // - ""lvalue reference to cv X"" for functions declared without a; // ref-qualifier or with the & ref-qualifier; // - ""rvalue reference to cv X"" for functions declared with the &&; // ref-qualifier; //; // where X is the class of which the function is a member and cv is the; // cv-qualification on the member function declaration.; //; // However, when finding an implicit conversion sequence for the argument, we; // are not allowed to perform user-defined conversions; // (C++ [over.match.funcs]p5). We perform a simplified version of; // reference binding here, that allows class rvalues to bind to; // non-constant references.; // First check the qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:637,Usability,simpl,simplified,637,"// C++0x [over.match.funcs]p4:; // For non-static member functions, the type of the implicit object; // parameter is; //; // - ""lvalue reference to cv X"" for functions declared without a; // ref-qualifier or with the & ref-qualifier; // - ""rvalue reference to cv X"" for functions declared with the &&; // ref-qualifier; //; // where X is the class of which the function is a member and cv is the; // cv-qualification on the member function declaration.; //; // However, when finding an implicit conversion sequence for the argument, we; // are not allowed to perform user-defined conversions; // (C++ [over.match.funcs]p5). We perform a simplified version of; // reference binding here, that allows class rvalues to bind to; // non-constant references.; // First check the qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,PerformObjectArgumentInitialization,4,/// PerformObjectArgumentInitialization - Perform initialization of; /// the implicit object parameter for the given Method with the given; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:42,Performance,Perform,Perform,42,/// PerformObjectArgumentInitialization - Perform initialization of; /// the implicit object parameter for the given Method with the given; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:8,Performance,perform,performing,8,"// When performing member access on a prvalue, materialize a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Security,access,access,26,"// When performing member access on a prvalue, materialize a temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:56,Performance,perform,performing,56,// Note that we always use the true parent context when performing; // the actual argument initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,PerformContextuallyConvertToBool,4,/// PerformContextuallyConvertToBool - Perform a contextual conversion; /// of the expression From to bool (C++0x [conv]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,Performance,Perform,Perform,39,/// PerformContextuallyConvertToBool - Perform a contextual conversion; /// of the expression From to bool (C++0x [conv]p3).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,Performance,perform,perform,121,"/// BuildConvertedConstantExpression - Check that the expression From is a; /// converted constant expression of type T, perform the conversion but; /// does not evaluate the expression",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:18,Usability,simpl,simply,18,"// Usually we can simply apply the ImplicitConversionSequence we formed; // earlier, but that's not guaranteed to work when initializing an object of; // class type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:75,Integrability,depend,dependent,75,"// Implicit conversion to a narrower type, but the expression is; // value-dependent so we can't tell whether it's actually narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:74,Availability,error,errors,74,// Don't diagnose array bound narrowing here; we produce more precise; // errors by allowing the un-narrowed value through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,Performance,perform,perform,121,"/// CheckConvertedConstantExpression - Check that the expression From is a; /// converted constant expression of type T, perform the conversion and produce; /// the converted expression, per C++11 [expr.const]p3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,PerformContextuallyConvertToObjCPointer,4,/// PerformContextuallyConvertToObjCPointer - Perform a contextual; /// conversion of the expression From to an Objective-C pointer type.; /// Returns a valid but null ExprResult if no conversion sequence exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:46,Performance,Perform,Perform,46,/// PerformContextuallyConvertToObjCPointer - Perform a contextual; /// conversion of the expression From to an Objective-C pointer type.; /// Returns a valid but null ExprResult if no conversion sequence exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:116,Integrability,rout,routine,116,"/// Attempt to convert the given expression to a type which is accepted; /// by the given converter.; ///; /// This routine will attempt to convert an expression of class type to a; /// type accepted by the specified converter. In C++11 and before, the class; /// must have a single non-explicit conversion function converting to a matching; /// type. In C++1y, there can be multiple such conversion functions, but only; /// one target type.; ///; /// \param Loc The source location of the construct that requires the; /// conversion.; ///; /// \param From The expression we're converting from.; ///; /// \param Converter Used to control and diagnose the conversion process.; ///; /// \returns The expression, converted to an integral or enumeration type if; /// successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,Integrability,depend,dependent,47,// We can't perform any more checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:12,Performance,perform,perform,12,// We can't perform any more checking for type-dependent expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:74,Performance,perform,perform,74,// FIXME: Check for missing '()' if T is a function type?; // We can only perform contextual implicit conversions on objects of class; // type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,Performance,perform,perform,9,"// Then, perform overload resolution over the candidate set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:195,Integrability,rout,routine,195,"/// IsAcceptableNonMemberOperatorCandidate - Determine whether Fn is; /// an acceptable non-member overloaded operator for a call whose; /// arguments have types T1 (and, if non-empty, T2). This routine; /// implements the check in C++ [over.match.oper]p3b2 concerning; /// enumeration types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:308,Performance,perform,performing,308,"/// AddOverloadCandidate - Adds the given function to the set of; /// candidate functions, using the given function call arguments. If; /// @p SuppressUserConversions, then don't allow user-defined; /// conversions via constructors or conversion operators.; ///; /// \param PartialOverloading true if we are performing ""partial"" overloading; /// based on an incomplete set of function arguments. This feature is used by; /// code completion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:99,Security,access,access,99,"// If we get here, it's because we're calling a member function; // that is named without a member access expression (e.g.,; // ""this->f"") that was either written explicitly or created; // implicitly. This can happen with a qualified call to a member; // function, e.g., X::f(). We use an empty type for the implied; // object argument (C++ [over.call.func]p3), and the acting context; // is irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:79,Performance,perform,perform,79,// C++ [class.copy]p3:; // A member function template is never instantiated to perform the copy; // of a class object to an object of its class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:72,Modifiability,inherit,inherited,72,"// C++ [over.match.funcs]p8: (proposed DR resolution); // A constructor inherited from class type C that has a first parameter; // of type ""reference to P"" (including such a constructor instantiated; // from a template) is excluded from the set of candidate functions when; // constructing an object of type cv D if the argument list has exactly; // one argument and D is reference-related to P and P is reference-related; // to C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,Integrability,depend,dependent,43,// We can't do any type-checking on a type-dependent argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,Availability,failure,failure,113,"// This function looks for a reasonably-exact match, so we consider; // incompatible pointer conversions to be a failure here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Integrability,depend,dependent,38,"// FIXME: This doesn't consider value-dependent cases, because doing so is; // very difficult. Ideally, we should handle them more gracefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:126,Security,access,access,126,// This branch handles both standalone functions and static methods.; // Slice the first argument (which is the base) when we access; // static method as non-static.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:100,Integrability,depend,dependent,100,/// Determine whether a given function template has a simple explicit specifier; /// or a non-value-dependent explicit-specification that evaluates to true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:54,Usability,simpl,simple,54,/// Determine whether a given function template has a simple explicit specifier; /// or a non-value-dependent explicit-specification that evaluates to true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Integrability,depend,dependent,38,"// If the function template has a non-dependent explicit specification,; // exclude it now if appropriate; we are not permitted to perform deduction; // and substitution in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:131,Performance,perform,perform,131,"// If the function template has a non-dependent explicit specification,; // exclude it now if appropriate; we are not permitted to perform deduction; // and substitution in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:122,Integrability,depend,dependent,122,"/// Check that implicit conversion sequences can be formed for each argument; /// whose corresponding parameter has a non-dependent type, per DR1391's; /// [temp.deduct.call]p10.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:145,Usability,clear,clear,145,// FIXME: The cases in which we allow explicit conversions for constructor; // arguments never consider calling a constructor template. It's not clear; // that is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:138,Availability,error,error,138,"// For a method call, check the 'this' conversion here too. DR1391 doesn't; // require that, but this check should never result in a hard error, and; // overload resolution is permitted to sidestep instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:378,Energy Efficiency,allocate,allocate,378,"// To determine what the conversion from the result of calling the; // conversion function to the type we're eventually trying to; // convert to (ToType), we need to synthesize a call to the; // conversion function and attempt copy initialization from it. This; // makes sure that we get the right semantics with respect to; // lvalues/rvalues and the type. Fortunately, we can allocate this; // call on the stack and we don't need its arguments to be; // well-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:27,Energy Efficiency,allocate,allocate,27,"// Note that it is safe to allocate CallExpr on the stack here because; // there are 0 arguments (i.e., nothing is allocated using ASTContext's; // allocator).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:115,Energy Efficiency,allocate,allocated,115,"// Note that it is safe to allocate CallExpr on the stack here because; // there are 0 arguments (i.e., nothing is allocated using ASTContext's; // allocator).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:19,Safety,safe,safe,19,"// Note that it is safe to allocate CallExpr on the stack here because; // there are 0 arguments (i.e., nothing is allocated using ASTContext's; // allocator).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Integrability,depend,dependent,38,"// If the function template has a non-dependent explicit specification,; // exclude it now if appropriate; we are not permitted to perform deduction; // and substitution in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:131,Performance,perform,perform,131,"// If the function template has a non-dependent explicit specification,; // exclude it now if appropriate; we are not permitted to perform deduction; // and substitution in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:237,Integrability,rout,routine,237,"// end anonymous namespace; /// AddPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty to; /// the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:504,Modifiability,extend,extended,504,"// end anonymous namespace; /// AddPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty to; /// the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:215,Integrability,rout,routine,215,"/// AddMemberPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty; /// to the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:482,Modifiability,extend,extended,482,"/// AddMemberPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty; /// to the set of pointer types along with any more-qualified variants of; /// that type. For example, if @p Ty is ""int const *"", this routine; /// will add ""int const *"", ""int const volatile *"", ""int const; /// restrict *"", and ""int const volatile restrict *"" to the set of; /// pointer types. Returns true if the add of @p Ty itself succeeded,; /// false otherwise.; ///; /// FIXME: what to do about extended qualifiers?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:113,Integrability,depend,depending,113,/// Helper function for adjusting address spaces for the pointer or reference; /// operands of builtin operators depending on the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:31,Integrability,rout,routine,31,"/// CollectVRQualifiers - This routine returns Volatile/Restrict qualifiers,; /// if any, found in visible type conversion functions found in ArgExpr's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,Safety,safe,safe,14,"// Just to be safe, assume the worst case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,Availability,down,down,14,// Need to go down the pointer/mempointer chain and add qualifiers; // as see them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:25,Availability,avail,available,25,// Common instance state available to all overload candidate addition methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:22,Energy Efficiency,reduce,reduce,22,// Use a heuristic to reduce number of builtin candidates in the set:; // add volatile version only if there are conversions to a volatile type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:697,Availability,error,error,697,"// C++2a [over.built]p14:; //; // For every integral type T there exists a candidate operator function; // of the form; //; // std::strong_ordering operator<=>(T, T); //; // C++2a [over.built]p15:; //; // For every pair of floating-point types L and R, there exists a candidate; // operator function of the form; //; // std::partial_ordering operator<=>(L, R);; //; // FIXME: The current specification for integral types doesn't play nice with; // the direction of p0946r0, which allows mixed integral and unscoped-enum; // comparisons. Under the current spec this can lead to ambiguity during; // overload resolution. For example:; //; // enum A : int {a};; // auto x = (a <=> (long)42);; //; // error: call is ambiguous for arguments 'A' and 'long'.; // note: candidate operator<=>(int, int); // note: candidate operator<=>(long, long); //; // To avoid this error, this function deviates from the specification and adds; // the mixed overloads `operator<=>(L, R)` where L and R are promoted; // arithmetic types (the same as the generic relational overloads).; //; // For now this function acts as a placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:860,Availability,error,error,860,"// C++2a [over.built]p14:; //; // For every integral type T there exists a candidate operator function; // of the form; //; // std::strong_ordering operator<=>(T, T); //; // C++2a [over.built]p15:; //; // For every pair of floating-point types L and R, there exists a candidate; // operator function of the form; //; // std::partial_ordering operator<=>(L, R);; //; // FIXME: The current specification for integral types doesn't play nice with; // the direction of p0946r0, which allows mixed integral and unscoped-enum; // comparisons. Under the current spec this can lead to ambiguity during; // overload resolution. For example:; //; // enum A : int {a};; // auto x = (a <=> (long)42);; //; // error: call is ambiguous for arguments 'A' and 'long'.; // note: candidate operator<=>(int, int); // note: candidate operator<=>(long, long); //; // To avoid this error, this function deviates from the specification and adds; // the mixed overloads `operator<=>(L, R)` where L and R are promoted; // arithmetic types (the same as the generic relational overloads).; //; // For now this function acts as a placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:849,Safety,avoid,avoid,849,"// C++2a [over.built]p14:; //; // For every integral type T there exists a candidate operator function; // of the form; //; // std::strong_ordering operator<=>(T, T); //; // C++2a [over.built]p15:; //; // For every pair of floating-point types L and R, there exists a candidate; // operator function of the form; //; // std::partial_ordering operator<=>(L, R);; //; // FIXME: The current specification for integral types doesn't play nice with; // the direction of p0946r0, which allows mixed integral and unscoped-enum; // comparisons. Under the current spec this can lead to ambiguity during; // overload resolution. For example:; //; // enum A : int {a};; // auto x = (a <=> (long)42);; //; // error: call is ambiguous for arguments 'A' and 'long'.; // note: candidate operator<=>(int, int); // note: candidate operator<=>(long, long); //; // To avoid this error, this function deviates from the specification and adds; // the mixed overloads `operator<=>(L, R)` where L and R are promoted; // arithmetic types (the same as the generic relational overloads).; //; // For now this function acts as a placeholder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,Energy Efficiency,reduce,reduce,16,// heuristic to reduce number of builtin candidates in the set.; // Add volatile/restrict version only if there are conversions to a; // volatile/restrict type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:271,Integrability,rout,routine,271,"// end anonymous namespace; /// AddBuiltinOperatorCandidates - Add the appropriate built-in; /// operator overloads to the candidate set (C++ [over.built]), based; /// on the operator @p Op and the arguments given. For example, if the; /// operator is a binary '+', this routine might add ""int; /// operator+(int, int)"" to cover integer addition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,Integrability,depend,dependent,47,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:122,Integrability,rout,routine,122,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:148,Integrability,depend,dependent,148,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:130,Performance,perform,performs,130,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,Availability,redundant,redundant,67,"// FIXME: This approach for uniquing ADL results (and removing; // redundant candidates from the set) relies on pointer-equality,; // which means we need to key off the canonical decl. However,; // always going back to the canonical decl might not get us the; // right set of default arguments. What default arguments are; // we supposed to consider on ADL candidates, anyway?; // FIXME: Pass in the explicit template arguments?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,Safety,redund,redundant,67,"// FIXME: This approach for uniquing ADL results (and removing; // redundant candidates from the set) relies on pointer-equality,; // which means we need to key off the canonical decl. However,; // always going back to the canonical decl might not get us the; // right set of default arguments. What default arguments are; // we supposed to consider on ADL candidates, anyway?; // FIXME: Pass in the explicit template arguments?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:146,Testability,test,test,146,// TODO: It is not clear whether comparing parameters is necessary (i.e.; // different functions with same params). Consider removing this (as no test; // fail w/o it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:19,Usability,clear,clear,19,// TODO: It is not clear whether comparing parameters is necessary (i.e.; // different functions with same params). Consider removing this (as no test; // fail w/o it).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:1593,Modifiability,variab,variable,1593,"rence is marked not viable, therefore; // is never shown up here. The worst preference shown up here is 'wrong side',; // e.g. an H function called by a HD function in device compilation. This is; // valid AST as long as the HD function is not emitted, e.g. it is an inline; // function which is called only by an H function. A deferred diagnostic will; // be triggered if it is emitted. However a wrong-sided function is still; // a viable candidate here.; //; // If Cand1 can be emitted and Cand2 cannot be emitted in the current; // context, Cand1 is better than Cand2. If Cand1 can not be emitted and Cand2; // can be emitted, Cand1 is not better than Cand2. This rule should have; // precedence over other rules.; //; // If both Cand1 and Cand2 can be emitted, or neither can be emitted, then; // other rules should be used to determine which is better. This is because; // host/device based overloading resolution is mostly for determining; // viability of a function. If two functions are both viable, other factors; // should take precedence in preference, e.g. the standard-defined preferences; // like argument conversion ranks or enable_if partial-ordering. The; // preference for pass-object-size parameters is probably most similar to a; // type-based-overloading decision and so should take priority.; //; // If other rules cannot determine which is better, CUDA preference will be; // used again to determine which is better.; //; // TODO: Currently IdentifyCUDAPreference does not return correct values; // for functions called in global variable initializers due to missing; // correct context about device/host. Therefore we can only enforce this; // rule when there is a caller. We should enforce this rule for functions; // in global variable initializers once proper context is added.; //; // TODO: We can only enable the hostness based overloading resolution when; // -fgpu-exclude-wrong-side-overloads is on since this requires deferring; // overloading resolution diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:1793,Modifiability,variab,variable,1793,"rence is marked not viable, therefore; // is never shown up here. The worst preference shown up here is 'wrong side',; // e.g. an H function called by a HD function in device compilation. This is; // valid AST as long as the HD function is not emitted, e.g. it is an inline; // function which is called only by an H function. A deferred diagnostic will; // be triggered if it is emitted. However a wrong-sided function is still; // a viable candidate here.; //; // If Cand1 can be emitted and Cand2 cannot be emitted in the current; // context, Cand1 is better than Cand2. If Cand1 can not be emitted and Cand2; // can be emitted, Cand1 is not better than Cand2. This rule should have; // precedence over other rules.; //; // If both Cand1 and Cand2 can be emitted, or neither can be emitted, then; // other rules should be used to determine which is better. This is because; // host/device based overloading resolution is mostly for determining; // viability of a function. If two functions are both viable, other factors; // should take precedence in preference, e.g. the standard-defined preferences; // like argument conversion ranks or enable_if partial-ordering. The; // preference for pass-object-size parameters is probably most similar to a; // type-based-overloading decision and so should take priority.; //; // If other rules cannot determine which is better, CUDA preference will be; // used again to determine which is better.; //; // TODO: Currently IdentifyCUDAPreference does not return correct values; // for functions called in global variable initializers due to missing; // correct context about device/host. Therefore we can only enforce this; // rule when there is a caller. We should enforce this rule for functions; // in global variable initializers once proper context is added.; //; // TODO: We can only enable the hostness based overloading resolution when; // -fgpu-exclude-wrong-side-overloads is on since this requires deferring; // overloading resolution diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Modifiability,Inherit,Inherited,3,// Inherited from sibling base classes: still ambiguous.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:42,Usability,guid,guides,42,// Check C++17 tie-breakers for deduction guides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,Usability,guid,guide,39,// -- F1 is generated from a deduction-guide and F2 is not,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:242,Modifiability,variab,variables,242,"// Check that the declarations appear to be equivalent.; //; // FIXME: Checking the type isn't really enough to resolve the ambiguity.; // For constants and functions, we should check the initializer or body is; // the same. For non-constant variables, we shouldn't allow it at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:33,Safety,avoid,avoid,33,// Check viable function only to avoid unnecessary data copying/moving.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:123,Availability,error,error,123,"// This candidate has constraint that we were unable to evaluate because; // it referenced an expression that contained an error. Rather than fall; // back onto a potentially unintended candidate (made worse by; // subsuming constraints), treat this as 'no viable candidate'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,Safety,abort,abort,43,"// If we didn't find any viable functions, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,Safety,detect,detect,9,// TODO: detect and diagnose the full richness of const mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Availability,failure,failure,26,"// Special diagnostic for failure to convert an initializer list, since; // telling the user that it has type void is not useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:145,Availability,failure,failure,145,"// Diagnose references or pointers to incomplete types differently,; // since it's far from impossible that the incompleteness triggered; // the failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:207,Integrability,depend,dependent,207,"// Arg has also been canonicalized, but there's nothing we can do; // about that. It also doesn't matter as much, because it won't; // have any template parameters in it (because deduction isn't; // done on dependent types).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:142,Integrability,message,message,142,// Format the SFINAE diagnostic into the argument string.; // FIXME: Add a general mechanism to include a PartialDiagnostic *'s; // formatted message in another diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:100,Availability,error,error,100,"/// Generates a 'note' diagnostic for an overload candidate. We've; /// already generated a primary error at the call site.; ///; /// It really does need to be a single diagnostic with its caret; /// pointed at the candidate declaration. Yes, this creates some; /// major challenges of technical writing. Yes, this makes pointing; /// out problems with specific arguments quite awkward. It's still; /// better than generating twenty screens of text for every failed; /// overload.; ///; /// It would be great to be able to express per-candidate problems; /// more richly for those diagnostic clients that cared, but we'd; /// still have to be just as careful with the default diagnostics.; /// \param CtorDestAS Addr space of object being constructed (for ctor; /// candidates only).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:28,Usability,simpl,simply,28,"// Do nothing, these should simply be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Availability,down,down,37,"// Desugar the type of the surrogate down to a function type,; // retaining as many typedefs as possible while still showing; // the function type (and, therefore, its parameter types).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:11,Availability,down,down,11,// Desugar down to a function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:119,Availability,failure,failure,119,"// If there are too many or too few arguments, that's the high-order bit we; // want to sort by, even if the immediate failure kind was something else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,Availability,failure,failures,24,// Don't do anything on failures other than bad conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:54,Integrability,message,messages,54,"/// When overload resolution fails, prints diagnostic messages containing the; /// candidates in the candidate set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:89,Availability,failure,failures,89,// Assuming that both candidates are not matches...; // Sort by the ranking of deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,Availability,failure,failure,43,/// Diagnose a template argument deduction failure.; /// We are treating these failures as overload failures due to bad; /// deductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:79,Availability,failure,failures,79,/// Diagnose a template argument deduction failure.; /// We are treating these failures as overload failures due to bad; /// deductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:100,Availability,failure,failures,100,/// Diagnose a template argument deduction failure.; /// We are treating these failures as overload failures due to bad; /// deductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:92,Integrability,message,messages,92,"/// NoteCandidates - When no template specialization match is found, prints; /// diagnostic messages containing the non-matching specializations that form; /// the candidate set.; /// This is analoguous to OverloadCandidateSet::NoteCandidates() with; /// OCD == OCD_AllCandidates and Cand->Viable == false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:109,Integrability,depend,depend,109,// Set an arbitrary limit on the number of candidates we'll spam; // the user with. FIXME: This limit should depend on details of the; // candidate list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:81,Safety,avoid,avoid,81,// A helper class to help with address of function resolution; // - allows us to avoid passing around all those ugly parameters,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:133,Availability,error,error,133,"// Note: We explicitly leave Matches unmodified if there isn't a clear best; // option, so we can potentially give the user a better error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:65,Usability,clear,clear,65,"// Note: We explicitly leave Matches unmodified if there isn't a clear best; // option, so we can potentially give the user a better error",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,Safety,avoid,avoid,9,// TODO: avoid!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Availability,failure,failure,26,"// We have some deduction failure messages. Use them to diagnose; // the function templates, and diagnose the non-template candidates; // normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:34,Integrability,message,messages,34,"// We have some deduction failure messages. Use them to diagnose; // the function templates, and diagnose the non-template candidates; // normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:567,Availability,error,error,567,"/// ResolveAddressOfOverloadedFunction - Try to resolve the address of; /// an overloaded function (C++ [over.over]), where @p From is an; /// expression with overloaded function type and @p ToType is the type; /// we're trying to resolve to. For example:; ///; /// @code; /// int f(double);; /// int f(int);; ///; /// int (*pfd)(double) = f; // selects f(double); /// @endcode; ///; /// This routine returns the resulting FunctionDecl if it could be; /// resolved, and NULL otherwise. When @p Complain is true, this; /// routine will emit diagnostics if there is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:393,Integrability,rout,routine,393,"/// ResolveAddressOfOverloadedFunction - Try to resolve the address of; /// an overloaded function (C++ [over.over]), where @p From is an; /// expression with overloaded function type and @p ToType is the type; /// we're trying to resolve to. For example:; ///; /// @code; /// int f(double);; /// int f(int);; ///; /// int (*pfd)(double) = f; // selects f(double); /// @endcode; ///; /// This routine returns the resulting FunctionDecl if it could be; /// resolved, and NULL otherwise. When @p Complain is true, this; /// routine will emit diagnostics if there is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:522,Integrability,rout,routine,522,"/// ResolveAddressOfOverloadedFunction - Try to resolve the address of; /// an overloaded function (C++ [over.over]), where @p From is an; /// expression with overloaded function type and @p ToType is the type; /// we're trying to resolve to. For example:; ///; /// @code; /// int f(double);; /// int f(int);; ///; /// int (*pfd)(double) = f; // selects f(double); /// @endcode; ///; /// This routine returns the resulting FunctionDecl if it could be; /// resolved, and NULL otherwise. When @p Complain is true, this; /// routine will emit diagnostics if there is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:220,Integrability,rout,routine,220,"/// Given an expression that refers to an overloaded function, try to; /// resolve that function to a single function that can have its address taken.; /// This will modify `Pair` iff it returns non-null.; ///; /// This routine can only succeed if from all of the candidates in the overload; /// set for SrcExpr that can have their addresses taken, there is one candidate; /// that is more constrained than the rest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:32,Deployability,update,update,32,"// If we found a better result, update Result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:159,Performance,perform,perform,159,"/// Given an overloaded function, tries to turn it into a non-overloaded; /// function reference using resolveAddressOfSingleOverloadCandidate. This; /// will perform access checks, diagnose the use of the resultant decl, and, if; /// requested, potentially perform a function-to-pointer decay.; ///; /// Returns false if resolveAddressOfSingleOverloadCandidate fails.; /// Otherwise, returns true. This may emit diagnostics and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:258,Performance,perform,perform,258,"/// Given an overloaded function, tries to turn it into a non-overloaded; /// function reference using resolveAddressOfSingleOverloadCandidate. This; /// will perform access checks, diagnose the use of the resultant decl, and, if; /// requested, potentially perform a function-to-pointer decay.; ///; /// Returns false if resolveAddressOfSingleOverloadCandidate fails.; /// Otherwise, returns true. This may emit diagnostics and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:167,Security,access,access,167,"/// Given an overloaded function, tries to turn it into a non-overloaded; /// function reference using resolveAddressOfSingleOverloadCandidate. This; /// will perform access checks, diagnose the use of the resultant decl, and, if; /// requested, potentially perform a function-to-pointer decay.; ///; /// Returns false if resolveAddressOfSingleOverloadCandidate fails.; /// Otherwise, returns true. This may emit diagnostics and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:119,Availability,down,down,119,"/// Given an expression that refers to an overloaded function, try to; /// resolve that overloaded function expression down to a single function.; ///; /// This routine can only resolve template-ids that refer to a single function; /// template, where that template-id refers to a single template whose template; /// arguments are either provided by the template-id or have defaults,; /// as described in C++0x [temp.arg.explicit]p3.; ///; /// If no template-ids are found, no diagnostics are emitted and NULL is; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:161,Integrability,rout,routine,161,"/// Given an expression that refers to an overloaded function, try to; /// resolve that overloaded function expression down to a single function.; ///; /// This routine can only resolve template-ids that refer to a single function; /// template, where that template-id refers to a single template whose template; /// arguments are either provided by the template-id or have defaults,; /// as described in C++0x [temp.arg.explicit]p3.; ///; /// If no template-ids are found, no diagnostics are emitted and NULL is; /// returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,Availability,redundant,redundant,43,"// C++ [over.over]p1:; // [...] [Note: any redundant set of parentheses surrounding the; // overloaded function name is ignored (5.1). ]; // C++ [over.over]p1:; // [...] The overloaded function name can be preceded by the &; // operator.; // If we didn't actually find any template-ids, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,Safety,redund,redundant,43,"// C++ [over.over]p1:; // [...] [Note: any redundant set of parentheses surrounding the; // overloaded function name is ignored (5.1). ]; // C++ [over.over]p1:; // [...] The overloaded function name can be preceded by the &; // operator.; // If we didn't actually find any template-ids, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:236,Testability,log,logically,236,"// Resolve and fix an overloaded expression that can be resolved; // because it identifies a single function template specialization.; //; // Last three arguments should only be supplied if Complain = true; //; // Return true if it was logically possible to so resolve the; // expression, regardless of whether or not it succeeded. Always; // returns true if 'complain' is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:78,Integrability,depend,dependent,78,/// Add the overload candidates named by callee and/or found by argument; /// dependent lookup to the given overload set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:230,Integrability,depend,dependent,230,"// Verify that ArgumentDependentLookup is consistent with the rules; // in C++0x [basic.lookup.argdep]p3:; //; // Let X be the lookup set produced by unqualified lookup (3.4.1); // and let Y be the lookup set produced by argument dependent; // lookup (defined as follows). If X contains; //; // -- a declaration of a class member, or; //; // -- a block-scope function declaration that is not a; // using-declaration, or; //; // -- a declaration that is neither a function or a function; // template; //; // then Y is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:23,Safety,avoid,avoid,23,// It would be nice to avoid this copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,Availability,recover,recover,15,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:55,Integrability,depend,dependent,55,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:104,Integrability,depend,dependent,104,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,Safety,recover,recover,15,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:240,Usability,usab,usable,240,"// We either found non-function declarations or a best viable function; // at class scope. A class-scope lookup result disables ADL. Don't; // look past this, but let the caller know that we found something that; // either is, or might be, usable in this class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Availability,recover,recover,10,// Try to recover by calling this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,recover,recover,10,// Try to recover by calling this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,Availability,recover,recover,15,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:52,Integrability,depend,dependent,52,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:105,Integrability,depend,dependent,105,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,Safety,recover,recover,15,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,Availability,recover,recover,16,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:137,Availability,recover,recover,137,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:159,Availability,recover,recovery,159,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:205,Availability,recover,recover,205,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:269,Availability,recover,recover,269,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,Safety,recover,recover,16,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:137,Safety,recover,recover,137,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:159,Safety,recover,recovery,159,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:205,Safety,recover,recover,205,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:269,Safety,recover,recover,269,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Availability,recover,recover,17,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:53,Availability,recover,recovery,53,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Safety,recover,recover,17,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:53,Safety,recover,recovery,53,// Do not try to recover if it is already building a recovery call.; // This stops infinite loops for template instantiations like; //; // template <typename T> auto foo(T t) -> decltype(foo(t)) {}; // template <typename T> auto foo(T t) -> decltype(foo(&t)) {},MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Availability,recover,recover,10,// Try to recover from an empty lookup with typo correction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,recover,recover,10,// Try to recover from an empty lookup with typo correction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:50,Integrability,depend,dependent,50,// We found a usable declaration of the name in a dependent base of some; // enclosing class.; // FIXME: We should also explain why the candidates found by name lookup; // were not viable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,Usability,usab,usable,14,// We found a usable declaration of the name in a dependent base of some; // enclosing class.; // FIXME: We should also explain why the candidates found by name lookup; // were not viable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:41,Availability,recover,recover,41,// We had viable candidates and couldn't recover; let the caller diagnose; // this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:41,Safety,recover,recover,41,// We had viable candidates and couldn't recover; let the caller diagnose; // this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,Availability,recover,recovery,67,"// If we get here, we should have issued a diagnostic and formed a recovery; // lookup result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,Safety,recover,recovery,67,"// If we get here, we should have issued a diagnostic and formed a recovery; // lookup result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:6,Availability,recover,recovery,6,"// If recovery created an ambiguity, just bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:6,Safety,recover,recovery,6,"// If recovery created an ambiguity, just bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:12,Performance,perform,perform,12,// We don't perform ADL for implicit declarations of builtins.; // Verify that this was correctly set up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:12,Performance,perform,perform,12,// We don't perform ADL in C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:112,Integrability,depend,dependent,112,"// Add the functions denoted by the callee to the set of candidate; // functions, including those from argument-dependent lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:95,Integrability,depend,dependent,95,"// In Microsoft mode, if we are inside a template class member function; // then create a type dependent CallExpr. The goal is to postpone name; // lookup to instantiation time to be able to search into type dependent; // base classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:208,Integrability,depend,dependent,208,"// In Microsoft mode, if we are inside a template class member function; // then create a type dependent CallExpr. The goal is to postpone name; // lookup to instantiation time to be able to search into type dependent; // base classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Availability,recover,recover,10,// Try to recover by looking for viable functions which the user might; // have meant to call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,recover,recover,10,// Try to recover by looking for viable functions which the user might; // have meant to call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:115,Availability,error,error,115,"// If the user passes in a function that we can't take the address of, we; // generally end up emitting really bad error messages. Here, we attempt to; // emit better ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,Integrability,message,messages,121,"// If the user passes in a function that we can't take the address of, we; // generally end up emitting really bad error messages. Here, we attempt to; // emit better ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,Availability,error,error,17,// We emitted an error for the unavailable/deleted function call but keep; // the call in the AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Availability,recover,recover,38,"// Overload resolution failed, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,Safety,recover,recover,38,"// Overload resolution failed, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:204,Availability,down,down,204,"/// BuildOverloadedCallExpr - Given the call expression that calls Fn; /// (which eventually refers to the declaration Func) and the call; /// arguments Args/NumArgs, attempt to resolve the function call down; /// to a specific function. If overload resolution succeeds, returns; /// the call expression produced by overload resolution.; /// Otherwise, emits diagnostics and returns ExprError.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:187,Integrability,depend,dependent,187,// Model the case with a call to a templated function whose definition; // encloses the call and whose return type contains a placeholder type as if; // the UnresolvedLookupExpr was type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Availability,Recover,Recover,10,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,Recover,Recover,10,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:103,Availability,error,error,103,"// No viable function; fall through to handling this as a; // built-in operator, which will produce an error message for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:109,Integrability,message,message,109,"// No viable function; fall through to handling this as a; // built-in operator, which will produce an error message for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Performance,Perform,Perform,4,/// Perform lookup for an overloaded binary operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:76,Performance,perform,performed,76,"// Add candidates from ADL. Per [over.match.oper]p2, this lookup is not; // performed for an assignment operator (nor for operator[] nor operator->,; // which don't get here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:832,Modifiability,rewrite,rewrites,832,"/// Create a binary operation that may resolve to an overloaded; /// operator.; ///; /// \param OpLoc The location of the operator itself (e.g., '+').; ///; /// \param Opc The BinaryOperatorKind that describes this operator.; ///; /// \param Fns The set of non-member functions that will be; /// considered by overload resolution. The caller needs to build this; /// set based on the context using, e.g.,; /// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This; /// set should not contain any member functions; those will be added; /// by CreateOverloadedBinOp().; ///; /// \param LHS Left-hand argument.; /// \param RHS Right-hand argument.; /// \param PerformADL Whether to consider operator candidates found by ADL.; /// \param AllowRewrittenCandidates Whether to consider candidates found by; /// C++20 operator rewrites.; /// \param DefaultedFn If we are synthesizing a defaulted operator function,; /// the function in question. Such a function is never a candidate in; /// our overload resolution. This also enables synthesizing a three-way; /// comparison from < and == as described in C++20 [class.spaceship]p1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:670,Performance,Perform,PerformADL,670,"/// Create a binary operation that may resolve to an overloaded; /// operator.; ///; /// \param OpLoc The location of the operator itself (e.g., '+').; ///; /// \param Opc The BinaryOperatorKind that describes this operator.; ///; /// \param Fns The set of non-member functions that will be; /// considered by overload resolution. The caller needs to build this; /// set based on the context using, e.g.,; /// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This; /// set should not contain any member functions; those will be added; /// by CreateOverloadedBinOp().; ///; /// \param LHS Left-hand argument.; /// \param RHS Right-hand argument.; /// \param PerformADL Whether to consider operator candidates found by ADL.; /// \param AllowRewrittenCandidates Whether to consider candidates found by; /// C++20 operator rewrites.; /// \param DefaultedFn If we are synthesizing a defaulted operator function,; /// the function in question. Such a function is never a candidate in; /// our overload resolution. This also enables synthesizing a three-way; /// comparison from < and == as described in C++20 [class.spaceship]p1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Integrability,depend,dependent,26,"// If either side is type-dependent, create an appropriate dependent; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:59,Integrability,depend,dependent,59,"// If either side is type-dependent, create an appropriate dependent; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:52,Integrability,depend,dependent,52,"// If there are no functions to store, just build a dependent; // BinaryOperator or CompoundAssignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,Performance,perform,perform,47,"// If this is the assignment operator, we only perform overload resolution; // if the left-hand side is a class or enumeration type. This is actually; // a hack. The standard requires that we do overload resolution between the; // various built-in candidates, but as DR507 points out, this can lead to; // problems. So we do it this way, which pretty much follows what GCC does.; // Note that we go the traditional code path for compound assignment forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,Security,Access,Access,9,// Best->Access is only meaningful for class members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:106,Modifiability,rewrite,rewrite,106,"// For a rewritten candidate, we've already reversed the arguments; // if needed. Perform the rest of the rewrite now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:82,Performance,Perform,Perform,82,"// For a rewritten candidate, we've already reversed the arguments; // if needed. Perform the rest of the rewrite now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:2,Performance,Perform,PerformADL,2,/*PerformADL=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Availability,Recover,Recover,10,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,Recover,Recover,10,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:85,Availability,error,error,85,"// No viable function; try to create a built-in operation, which will; // produce an error. Then, show the non-viable candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:22,Performance,perform,perform,22,"// If we ever want to perform this synthesis more generally, we will need to; // apply the temporary materialization conversion to the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:47,Performance,perform,perform,47,// Form the list of comparisons we're going to perform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Integrability,depend,dependent,26,"// If either side is type-dependent, create an appropriate dependent; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:59,Integrability,depend,dependent,59,"// If either side is type-dependent, create an appropriate dependent; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:295,Security,validat,validate,295,"/// BuildCallToMemberFunction - Build a call to a member; /// function. MemExpr is the expression that refers to the member; /// function (and includes the object parameter), Args/NumArgs are the; /// arguments to the function call (not including the object; /// parameter). The caller needs to validate that the member; /// expression refers to a non-static member function or an overloaded; /// member function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Availability,recover,recovery,26,"// We only try to build a recovery expr at this level if we can preserve; // the return type, otherwise we return ExprError() and let the caller; // recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:149,Availability,recover,recover,149,"// We only try to build a recovery expr at this level if we can preserve; // the return type, otherwise we return ExprError() and let the caller; // recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Safety,recover,recovery,26,"// We only try to build a recovery expr at this level if we can preserve; // the return type, otherwise we return ExprError() and let the caller; // recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:149,Safety,recover,recover,149,"// We only try to build a recovery expr at this level if we can preserve; // the return type, otherwise we return ExprError() and let the caller; // recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,avoid,avoid,10,// FIXME: avoid copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Availability,recover,recover,37,"// Overload resolution fails, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Safety,recover,recover,37,"// Overload resolution fails, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:214,Availability,error,errors,214,"// In the case the method to call was not selected by the overloading; // resolution process, we still need to handle the enable_if attribute. Do; // that here, so it will not hide previous -- and more relevant -- errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:193,Performance,perform,performing,193,"/// BuildCallToObjectOfClassType - Build a call to an object of class; /// type (C++ [over.call.object]), which can end up invoking an; /// overloaded function call operator (@c operator()) or performing a; /// user-defined conversion on the object argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:383,Availability,error,error,383,"// When calling a lambda, both the call operator, and; // the conversion operator to function pointer; // are considered. But when constraint checking; // on the call operator fails, it will also fail on the; // conversion operator as the constraints are always the same.; // As the user probably does not intend to perform a surrogate call,; // we filter them out to produce better error diagnostics, ie to avoid; // showing 2 failed overloads instead of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:316,Performance,perform,perform,316,"// When calling a lambda, both the call operator, and; // the conversion operator to function pointer; // are considered. But when constraint checking; // on the call operator fails, it will also fail on the; // conversion operator as the constraints are always the same.; // As the user probably does not intend to perform a surrogate call,; // we filter them out to produce better error diagnostics, ie to avoid; // showing 2 failed overloads instead of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:408,Safety,avoid,avoid,408,"// When calling a lambda, both the call operator, and; // the conversion operator to function pointer; // are considered. But when constraint checking; // on the call operator fails, it will also fail on the; // conversion operator as the constraints are always the same.; // As the user probably does not intend to perform a surrogate call,; // we filter them out to produce better error diagnostics, ie to avoid; // showing 2 failed overloads instead of one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:753,Security,access,accessible,753,"// C++ [over.call.object]p2:; // In addition, for each (non-explicit in C++0x) conversion function; // declared in T of the form; //; // operator conversion-type-id () cv-qualifier;; //; // where cv-qualifier is the same cv-qualification as, or a; // greater cv-qualification than, cv, and where conversion-type-id; // denotes the type ""pointer to function of (P1,...,Pn) returning; // R"", or the type ""reference to pointer to function of; // (P1,...,Pn) returning R"", or the type ""reference to function; // of (P1,...,Pn) returning R"", a surrogate call function [...]; // is also considered as a candidate function. Similarly,; // surrogate call functions are added to the set of candidate; // functions for each conversion function declared in an; // accessible base class provided the function is not hidden; // within T by another intervening declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:83,Availability,down,down,83,// Strip the reference type (if any) and then the pointer type (if; // any) to get down to what might be a function type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:108,Performance,Perform,Perform,108,"// We selected one of the surrogate functions that converts the; // object parameter to a function pointer. Perform the conversion; // on the object argument, then let BuildCallExpr finish the job.; // Create an implicit member expr to refer to the conversion operator.; // and then call it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:6,Availability,error,error,6,// An error diagnostic has already been printed when parsing the declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,// Perform overload resolution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:24,Availability,error,error,24,"// Report this specific error to the caller instead of emitting a; // diagnostic, as requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:3,Performance,Perform,Perform,3,"// Perform overload resolution. This will usually be trivial, but might need; // to perform substitutions for a literal operator template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:84,Performance,perform,perform,84,"// Perform overload resolution. This will usually be trivial, but might need; // to perform substitutions for a literal operator template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:234,Integrability,depend,dependent,234,"/// Build a call to 'begin' or 'end' for a C++11 for-range statement. If the; /// given LookupResult is non-empty, it is assumed to describe a member which; /// will be invoked. Otherwise, the function will be found via argument; /// dependent lookup.; /// CallExpr is set to a valid expression and FRS_Success returned on success,; /// otherwise CallExpr is set to ExprError() and some non-success value; /// is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:250,Deployability,patch,patch,250,"/// FixOverloadedFunctionReference - E is an expression that refers to; /// a C++ overloaded function (possibly with some parentheses and; /// perhaps a '&' around it). We have resolved the overloaded function; /// to the function declaration Fn, so patch up the expression E to; /// refer (possibly indirectly) to Fn. Returns the new expr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:66,Performance,Perform,Perform,66,// We have taken the address of a pointer to member; // function. Perform the computation here so that we get the; // appropriate pointer to member type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,Availability,down,down,26,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:35,Modifiability,inherit,inheritance,35,"// Under the MS ABI, lock down the inheritance model now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,avoid,avoid,10,// FIXME: avoid copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Safety,avoid,avoid,10,// FIXME: avoid copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:92,Modifiability,rewrite,rewrite,92,"// If we're filling in a static method where we used to have an; // implicit member access, rewrite to a simple decl ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:84,Security,access,access,84,"// If we're filling in a static method where we used to have an; // implicit member access, rewrite to a simple decl ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:105,Usability,simpl,simple,105,"// If we're filling in a static method where we used to have an; // implicit member access, rewrite to a simple decl ref.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:990,Integrability,message,message-send,990,"//===--- SemaPseudoObject.cpp - Semantic Analysis for Pseudo-Objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis for expressions involving; // pseudo-object references. Pseudo-objects are conceptual objects; // whose storage is entirely abstract and all accesses to which are; // translated through some sort of abstraction barrier.; //; // For example, Objective-C objects can have ""properties"", either; // declared or undeclared. A property may be accessed by writing; // expr.prop; // where 'expr' is an r-value of Objective-C pointer type and 'prop'; // is the name of the property. If this expression is used in a context; // needing an r-value, it is treated as if it were a message-send; // of the associated 'getter' selector, typically:; // [expr prop]; // If it is used as the LHS of a simple assignment, it is treated; // as a message-send of the associated 'setter' selector, typically:; // [expr setProp: RHS]; // If it is used as the LHS of a compound assignment, or the operand; // of a unary increment or decrement, both are required; for example,; // 'expr.prop *= 100' would be translated to:; // [expr setProp: [expr prop] * 100]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:1147,Integrability,message,message-send,1147,"//===--- SemaPseudoObject.cpp - Semantic Analysis for Pseudo-Objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis for expressions involving; // pseudo-object references. Pseudo-objects are conceptual objects; // whose storage is entirely abstract and all accesses to which are; // translated through some sort of abstraction barrier.; //; // For example, Objective-C objects can have ""properties"", either; // declared or undeclared. A property may be accessed by writing; // expr.prop; // where 'expr' is an r-value of Objective-C pointer type and 'prop'; // is the name of the property. If this expression is used in a context; // needing an r-value, it is treated as if it were a message-send; // of the associated 'getter' selector, typically:; // [expr prop]; // If it is used as the LHS of a simple assignment, it is treated; // as a message-send of the associated 'setter' selector, typically:; // [expr setProp: RHS]; // If it is used as the LHS of a compound assignment, or the operand; // of a unary increment or decrement, both are required; for example,; // 'expr.prop *= 100' would be translated to:; // [expr setProp: [expr prop] * 100]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:563,Security,access,accesses,563,"//===--- SemaPseudoObject.cpp - Semantic Analysis for Pseudo-Objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis for expressions involving; // pseudo-object references. Pseudo-objects are conceptual objects; // whose storage is entirely abstract and all accesses to which are; // translated through some sort of abstraction barrier.; //; // For example, Objective-C objects can have ""properties"", either; // declared or undeclared. A property may be accessed by writing; // expr.prop; // where 'expr' is an r-value of Objective-C pointer type and 'prop'; // is the name of the property. If this expression is used in a context; // needing an r-value, it is treated as if it were a message-send; // of the associated 'getter' selector, typically:; // [expr prop]; // If it is used as the LHS of a simple assignment, it is treated; // as a message-send of the associated 'setter' selector, typically:; // [expr setProp: RHS]; // If it is used as the LHS of a compound assignment, or the operand; // of a unary increment or decrement, both are required; for example,; // 'expr.prop *= 100' would be translated to:; // [expr setProp: [expr prop] * 100]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:759,Security,access,accessed,759,"//===--- SemaPseudoObject.cpp - Semantic Analysis for Pseudo-Objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis for expressions involving; // pseudo-object references. Pseudo-objects are conceptual objects; // whose storage is entirely abstract and all accesses to which are; // translated through some sort of abstraction barrier.; //; // For example, Objective-C objects can have ""properties"", either; // declared or undeclared. A property may be accessed by writing; // expr.prop; // where 'expr' is an r-value of Objective-C pointer type and 'prop'; // is the name of the property. If this expression is used in a context; // needing an r-value, it is treated as if it were a message-send; // of the associated 'getter' selector, typically:; // [expr prop]; // If it is used as the LHS of a simple assignment, it is treated; // as a message-send of the associated 'setter' selector, typically:; // [expr setProp: RHS]; // If it is used as the LHS of a compound assignment, or the operand; // of a unary increment or decrement, both are required; for example,; // 'expr.prop *= 100' would be translated to:; // [expr setProp: [expr prop] * 100]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:1105,Usability,simpl,simple,1105,"//===--- SemaPseudoObject.cpp - Semantic Analysis for Pseudo-Objects ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements semantic analysis for expressions involving; // pseudo-object references. Pseudo-objects are conceptual objects; // whose storage is entirely abstract and all accesses to which are; // translated through some sort of abstraction barrier.; //; // For example, Objective-C objects can have ""properties"", either; // declared or undeclared. A property may be accessed by writing; // expr.prop; // where 'expr' is an r-value of Objective-C pointer type and 'prop'; // is the name of the property. If this expression is used in a context; // needing an r-value, it is treated as if it were a message-send; // of the associated 'getter' selector, typically:; // [expr prop]; // If it is used as the LHS of a simple assignment, it is treated; // as a message-send of the associated 'setter' selector, typically:; // [expr setProp: RHS]; // If it is used as the LHS of a compound assignment, or the operand; // of a unary increment or decrement, both are required; for example,; // 'expr.prop *= 100' would be translated to:; // [expr setProp: [expr prop] * 100]; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:311,Usability,simpl,simple,311,"/// Should the result of an assignment be the formal result of the; /// setter call or the value that was passed to the setter?; ///; /// Different pseudo-object language features use different language rules; /// for this.; /// The default is to use the set value. Currently, this affects the; /// behavior of simple assignments, compound assignments, and prefix; /// increment and decrement.; /// Postfix increment and decrement always use the getter result as the; /// expression result.; ///; /// If this method returns true, and the set value isn't capturable for; /// some reason, the result of the expression will be void.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:90,Integrability,rout,routine,90,"/// Capture the given expression as the result of this pseudo-object; /// operation. This routine is safe against expressions which may; /// already be captured.; ///; /// \returns the captured expression, which will be the; /// same as the input if the input was already captured",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:101,Safety,safe,safe,101,"/// Capture the given expression as the result of this pseudo-object; /// operation. This routine is safe against expressions which may; /// already be captured.; ///; /// \returns the captured expression, which will be the; /// same as the input if the input was already captured",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:8,Integrability,rout,routine,8,/// The routine which creates the final PseudoObjectExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:38,Usability,simpl,simple,38,/// The basic skeleton for building a simple or compound; /// assignment operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:144,Safety,safe,safely,144,"// In some very specific cases, semantic analysis of the RHS as an; // expression may require it to be rewritten. In these cases, we; // cannot safely keep the OVE around. Fortunately, we don't really; // need to: we don't use this particular OVE in multiple places, and; // no clients rely that closely on matching up expressions in the; // semantic expression with expressions from the syntactic form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:3,Performance,Load,Load,3,// Load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:16,Safety,safe,safe,16,// This cast is safe because isSelfExpr is only true within; // methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:80,Integrability,message,message,80,// That can fail in the somewhat crazy situation that we're; // type-checking a message send within the @interface declaration; // that declared the @property. But it's not clear that that's; // valuable to support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:105,Integrability,interface,interface,105,// That can fail in the somewhat crazy situation that we're; // type-checking a message send within the @interface declaration; // that declared the @property. But it's not clear that that's; // valuable to support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:173,Usability,clear,clear,173,// That can fail in the somewhat crazy situation that we're; // type-checking a message send within the @interface declaration; // that declared the @property. But it's not clear that that's; // valuable to support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:4,Performance,Load,Load,4,/// Load from an Objective-C property reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:11,Integrability,message,message-send,11,// Build a message-send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:11,Integrability,message,message-send,11,// Build a message-send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:89,Availability,Error,Error,89,// The property has no setter and no getter! This can happen if the type is; // invalid. Error have already been reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:22,Availability,error,error,22,"// Otherwise, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:22,Availability,error,error,22,"// Otherwise, it's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:150,Integrability,rout,routine,150,// ObjCSubscript build stuff.; //; /// objective-c subscripting-specific behavior for doing lvalue-to-rvalue; /// conversion.; /// FIXME. Remove this routine if it is proven that no additional; /// specifity is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:33,Integrability,rout,routine,33,"/// CheckSubscriptingKind - This routine decide what type; /// of indexing represented by ""FromE"" is being done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:40,Integrability,rout,routine,40,/// CheckKeyForObjCARCConversion - This routine suggests bridge casting of CF; /// objects used as dictionary subscript key objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:57,Integrability,bridg,bridge,57,/// CheckKeyForObjCARCConversion - This routine suggests bridge casting of CF; /// objects used as dictionary subscript key objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:11,Integrability,message,message-send,11,// Build a message-send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:11,Integrability,message,message-send,11,// Build a message-send.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:98,Integrability,rout,routines,98,//===----------------------------------------------------------------------===//; // General Sema routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:32,Integrability,depend,dependent,32,// Do nothing if the operand is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:36,Integrability,depend,dependent,36,// Do nothing if either argument is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:91,Usability,undo,undo,91,"/// Given a pseudo-object reference, rebuild it without the opaque; /// values. Basically, undo the behavior of rebuildAndCaptureObject.; /// This should never operate in-place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:14,Availability,mask,masked,14,// Create non-masked intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:14,Availability,mask,masked,14,// Create non-masked policy intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:10,Availability,mask,masked,10,// Create masked intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp:10,Availability,mask,masked,10,// Create masked policy intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaRISCVVectorLookup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:46,Availability,error,error,46,"// If we have an invalid decl, just return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:8,Modifiability,variab,variable,8,// Only variable declarations are permitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:11,Modifiability,variab,variables,11,// foreach variables are never actually initialized in the way that; // the parser came up with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:49,Modifiability,variab,variable,49,"// In ARC, we don't need to retain the iteration variable of a fast; // enumeration loop. Rather than actually trying to catch that; // during declaration processing, we remove the consequences here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,Modifiability,variab,variable,28,// Add 'const' and mark the variable as pseudo-strong.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:181,Integrability,wrap,wrappers,181,"/// Diagnose unused comparisons, both builtin and overloaded operators.; /// For '==' and '!=', suggest fixits for '=' or '|='.; ///; /// Adding a cast to void (or other expression wrappers) will prevent the; /// warning from firing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:366,Testability,test,test,366,"// In most cases, we don't want to warn if the expression is written in a; // macro body, or if the macro comes from a system header. If the offending; // expression is a call to a function with the warn_unused_result attribute,; // we warn no matter the location. Because of the order in which the various; // checks need to happen, we factor out the macro-related test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:35,Integrability,Depend,Depending,35,"// Okay, we have an unused result. Depending on what the base expression is,; // we might want to make a more specific diagnostic. Check for one of these; // cases now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:97,Integrability,message,message,97,"// If the callee has attribute pure, const, or warn_unused_result, warn with; // a more specific message to make it clear what is happening. If the call; // is written in a macro body, only warn if it has the warn_unused_result; // attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:116,Usability,clear,clear,116,"// If the callee has attribute pure, const, or warn_unused_result, warn with; // a more specific message to make it clear what is happening. If the call; // is written in a macro body, only warn if it has the warn_unused_result; // attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:37,Modifiability,variab,variable,37,// Tell the user to assign it into a variable to force a volatile load if this; // isn't an array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:66,Performance,load,load,66,// Tell the user to assign it into a variable to force a volatile load if this; // isn't an array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:29,Deployability,install,installs,29,/// ActOnCaseStmtBody - This installs a statement as the body of a case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:9,Deployability,update,update,9,"// Don't update the location of MS ASM labels. These will result in; // a diagnostic, and changing the location here will mess that up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:47,Modifiability,refactor,refactoring,47,// FIXME: this code should move when a planned refactoring around statement; // attributes lands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:58,Availability,recover,recover,58,"// If none of the attributes applied, that's fine, we can recover by; // returning the substatement directly instead of making an AttributedStmt; // with no attributes on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:58,Safety,recover,recover,58,"// If none of the attributes applied, that's fine, we can recover by; // returning the substatement directly instead of making an AttributedStmt; // with no attributes on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:60,Modifiability,rewrite,rewrite,60,"// Now that we have verified that 'musttail' is valid here, rewrite the; // return value to remove all implicit nodes, but retain parentheses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:10,Performance,Perform,PerformContextualImplicitConversion,10,// FIXME: PerformContextualImplicitConversion doesn't always tell us if it; // failed and produced a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:42,Performance,perform,performed,42,// C99 6.8.4.2p5 - Integer promotions are performed on the controlling expr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:271,Availability,error,error,271,"// We have already converted the expression to an integral or enumeration; // type, when we parsed the switch condition. There are cases where we don't; // have an appropriate type, e.g. a typo-expr Cond was corrected to an; // inappropriate-type expr, we just return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:49,Availability,error,error,49,"// switch(bool_expr) {...} is often a programmer error, e.g.; // switch(n && mask) { ... } // Doh - should be ""n & mask"".; // One can always use an if statement instead of switch(bool_expr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:77,Availability,mask,mask,77,"// switch(bool_expr) {...} is often a programmer error, e.g.; // switch(n && mask) { ... } // Doh - should be ""n & mask"".; // One can always use an if statement instead of switch(bool_expr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:115,Availability,mask,mask,115,"// switch(bool_expr) {...} is often a programmer error, e.g.; // switch(n && mask) { ... } // Doh - should be ""n & mask"".; // One can always use an if statement instead of switch(bool_expr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:45,Performance,perform,performed,45,"// C++ 6.4.2.p2:; // Integral promotions are performed (on the switch condition).; //; // A case value unrepresentable by the original switch condition; // type (before the promotion) doesn't make sense, even when it can; // be represented by the promoted type. Therefore we need to find; // the pre-promotion type of the switch condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:82,Safety,detect,detect,82,// Accumulate all of the case values in a vector so that we can sort them; // and detect duplicates. This vector contains the APInt for the case after; // it has been converted to the condition type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:83,Integrability,depend,dependent,83,// FIXME: We'd better diagnose missing or duplicate default labels even; // in the dependent case. Because default labels themselves are never; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:147,Integrability,depend,dependent,147,// FIXME: We'd better diagnose missing or duplicate default labels even; // in the dependent case. Because default labels themselves are never; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:123,Availability,down,down,123,"// FIXME: Remove the default statement from the switch block so that; // we'll return a valid AST. This requires recursing down the AST and; // finding it, not something we are set up to do right now. For now,; // just lop the entire switch stmt out of the AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:36,Performance,perform,performed,36,// FIXME: This duplicates the check performed for warn_not_in_enum below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:52,Safety,detect,detect,52,// Sort all the scalar case values so we can easily detect duplicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Safety,Detect,Detect,3,"// Detect duplicate case ranges, which usually don't exist at all in; // the first place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:64,Safety,detect,detect,64,// Sort all the case ranges by their low value so we can easily detect; // overlaps between ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:13,Availability,avail,available,13,// Partially available enum constants should be present. Note that we; // suppress -Wunguarded-availability diagnostics for such uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:95,Availability,avail,availability,95,// Partially available enum constants should be present. Note that we; // suppress -Wunguarded-availability diagnostics for such uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:86,Deployability,patch,patch,86,"// FIXME: If the case list was broken is some way, we don't have a good system; // to patch it up. Instead, just return the whole substmt as broken.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:107,Usability,Simpl,Simple,107,// This visitor will traverse a conditional statement and store all; // the evaluated decls into a vector. Simple is set to true if none; // of the excluded constructs are used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:45,Modifiability,variab,variables,45,"// Don't warn on volatile, static, or global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Performance,Load,Load,3,// Load decl names into diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:76,Modifiability,variab,variables,76,"// If Statement is an incemement or decrement, return true and sets the; // variables Increment and DRE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:306,Modifiability,variab,variable,306,// end class BreakContinueFinder; // Emit a warning when a loop increment/decrement appears twice per loop; // iteration. The conditions which trigger this warning are:; // 1) The last statement in the loop body and the third expression in the; // for loop are both increment or both decrement of the same variable; // 2) No continue statements in the loop body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:88,Modifiability,variab,variable,88,// Check that the two statements are both increments or both decrements; // on the same variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:31,Modifiability,variab,variable,31,"// Keep track of the first non-variable declaration we saw so that; // we can diagnose if we don't see any variable declarations. This; // covers a case like declaring a typedef, function, or structure; // type rather than a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:107,Modifiability,variab,variable,107,"// Keep track of the first non-variable declaration we saw so that; // we can diagnose if we don't see any variable declarations. This; // covers a case like declaring a typedef, function, or structure; // type rather than a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:225,Modifiability,variab,variable,225,"// Keep track of the first non-variable declaration we saw so that; // we can diagnose if we don't see any variable declarations. This; // covers a case like declaring a typedef, function, or structure; // type rather than a variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,Modifiability,variab,variable,28,// Diagnose if we saw a non-variable declaration but no variable; // declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:56,Modifiability,variab,variable,56,// Diagnose if we saw a non-variable declaration but no variable; // declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce placeholder expressions here. Note that this rejects the; // use of pseudo-object l-values in this position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:38,Integrability,depend,dependent,38,// Bail out early if we've got a type-dependent expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Performance,Perform,Perform,3,// Perform normal l-value conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:87,Availability,error,error,87,"// If we have a forward-declared type, we can't do this check.; // Under ARC, it is an error not to have a forward-declared class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:17,Integrability,interface,interface,17,"// If there's an interface, look in both the public and private APIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:14,Integrability,protocol,protocol,14,// Also check protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Integrability,Wrap,Wrap,3,// Wrap up any cleanups in the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:94,Availability,error,error,94,/// Finish building a variable declaration for a for-range statement.; /// \return true if an error occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:22,Modifiability,variab,variable,22,/// Finish building a variable declaration for a for-range statement.; /// \return true if an error occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:36,Modifiability,variab,variable,36,"// Deduce the type for the iterator variable now rather than leaving it to; // AddInitializerToDecl, so we can produce a more suitable diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:12,Modifiability,variab,variable,12,/// Build a variable declaration for a for-range statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:409,Availability,avail,available,409,"/// ActOnCXXForRangeStmt - Check and build a C++11 for-range statement.; ///; /// C++11 [stmt.ranged]:; /// A range-based for statement is equivalent to; ///; /// {; /// auto && __range = range-init;; /// for ( auto __begin = begin-expr,; /// __end = end-expr;; /// __begin != __end;; /// ++__begin ) {; /// for-range-declaration = *__begin;; /// statement; /// }; /// }; ///; /// The body of the loop is not available yet, since it cannot be analysed until; /// we have determined the type of the for-range-declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:10,Availability,recover,recover,10,// FIXME: recover in order to allow the body to be parsed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:10,Safety,recover,recover,10,// FIXME: recover in order to allow the body to be parsed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:65,Modifiability,variab,variables,65,"// Build auto && __range = range-init; // Divide by 2, since the variables are in the inner scope (loop body).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:289,Availability,error,error,289,"/// Create the initialization, compare, and increment steps for; /// the range-based for loop expression.; /// This function does not handle array-based for loops,; /// which are created in Sema::BuildCXXForRangeStmt.; ///; /// \returns a ForRangeStatus indicating success or what kind of error occurred.; /// BeginExpr and EndExpr are set and FRS_Success is returned on success;; /// CandidateSet and BEF are set and some non-success value is returned on; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:461,Availability,failure,failure,461,"/// Create the initialization, compare, and increment steps for; /// the range-based for loop expression.; /// This function does not handle array-based for loops,; /// which are created in Sema::BuildCXXForRangeStmt.; ///; /// \returns a ForRangeStatus indicating success or what kind of error occurred.; /// BeginExpr and EndExpr are set and FRS_Success is returned on success;; /// CandidateSet and BEF are set and some non-success value is returned on; /// failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:137,Security,access,access,137,"// - if _RangeT is a class type, the unqualified-ids begin and end are; // looked up in the scope of class _RangeT as if by class member access; // lookup (3.4.5), and if either (or both) finds at least one; // declaration, begin-expr and end-expr are __range.begin() and; // __range.end(), respectively;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:147,Integrability,depend,dependent,147,"// - otherwise, begin-expr and end-expr are begin(__range) and; // end(__range), respectively, where begin and end are looked up with; // argument-dependent lookup (3.4.2). For the purposes of this name; // lookup, namespace std is an associated namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:186,Testability,Test,Testcase,186,"// FIXME: This should not be used during template instantiation. We should; // pick up the set of unqualified lookup results for the != and + operators; // in the initial parse.; //; // Testcase (accepts-invalid):; // template<typename T> void f() { for (auto x : T()) {} }; // namespace N { struct X { X begin(); X end(); int operator*(); }; }; // bool operator!=(N::X, N::X); void operator++(N::X);; // void g() { f<N::X>(); }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:60,Integrability,depend,dependent,60,// The range is implicitly used as a placeholder when it is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:47,Integrability,Depend,DependentTy,47,// Deduce any 'auto's in the loop variable as 'DependentTy'. We'll fill; // them in properly when we instantiate the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:34,Modifiability,variab,variable,34,// Deduce any 'auto's in the loop variable as 'DependentTy'. We'll fill; // them in properly when we instantiate the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:81,Modifiability,variab,variables,81,"// Build auto __begin = begin-expr, __end = end-expr.; // Divide by 2, since the variables are in the inner scope (loop body).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:65,Modifiability,variab,variables,65,// Build begin-expr and end-expr and attach to __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:9,Modifiability,variab,variably,9,"// For a variably modified type we can't just use the expression within; // the array bounds, since we don't want that to be re-evaluated here.; // Rather, we need to determine what it was when the array was first; // created - so we resort to using sizeof(vla)/sizeof(element).; // For e.g.; // void f(int b) {; // int vla[b];; // b = -1; <-- This should not affect the num of iterations below; // for (int &c : vla) { .. }; // }; // FIXME: This results in codegen generating IR that recalculates the; // run-time number of elements (as opposed to just using the IR Value; // that corresponds to the run-time value of each bound that was; // generated when the array was created.) If this proves too embarrassing; // even for unoptimized IR, consider passing a magic-value/cookie to; // codegen that then knows to simply use that initial llvm::Value (that; // corresponds to the bound at time of array creation) within; // getelementptr. But be prepared to pay the price of increasing a; // customized form of coupling between the two components - which could; // be hard to maintain as the codebase evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:1011,Modifiability,coupling,coupling,1011,"// For a variably modified type we can't just use the expression within; // the array bounds, since we don't want that to be re-evaluated here.; // Rather, we need to determine what it was when the array was first; // created - so we resort to using sizeof(vla)/sizeof(element).; // For e.g.; // void f(int b) {; // int vla[b];; // b = -1; <-- This should not affect the num of iterations below; // for (int &c : vla) { .. }; // }; // FIXME: This results in codegen generating IR that recalculates the; // run-time number of elements (as opposed to just using the IR Value; // that corresponds to the run-time value of each bound that was; // generated when the array was created.) If this proves too embarrassing; // even for unoptimized IR, consider passing a magic-value/cookie to; // codegen that then knows to simply use that initial llvm::Value (that; // corresponds to the bound at time of array creation) within; // getelementptr. But be prepared to pay the price of increasing a; // customized form of coupling between the two components - which could; // be hard to maintain as the codebase evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:1101,Modifiability,evolve,evolves,1101,"// For a variably modified type we can't just use the expression within; // the array bounds, since we don't want that to be re-evaluated here.; // Rather, we need to determine what it was when the array was first; // created - so we resort to using sizeof(vla)/sizeof(element).; // For e.g.; // void f(int b) {; // int vla[b];; // b = -1; <-- This should not affect the num of iterations below; // for (int &c : vla) { .. }; // }; // FIXME: This results in codegen generating IR that recalculates the; // run-time number of elements (as opposed to just using the IR Value; // that corresponds to the run-time value of each bound that was; // generated when the array was created.) If this proves too embarrassing; // even for unoptimized IR, consider passing a magic-value/cookie to; // codegen that then knows to simply use that initial llvm::Value (that; // corresponds to the bound at time of array creation) within; // getelementptr. But be prepared to pay the price of increasing a; // customized form of coupling between the two components - which could; // be hard to maintain as the codebase evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:815,Usability,simpl,simply,815,"// For a variably modified type we can't just use the expression within; // the array bounds, since we don't want that to be re-evaluated here.; // Rather, we need to determine what it was when the array was first; // created - so we resort to using sizeof(vla)/sizeof(element).; // For e.g.; // void f(int b) {; // int vla[b];; // b = -1; <-- This should not affect the num of iterations below; // for (int &c : vla) { .. }; // }; // FIXME: This results in codegen generating IR that recalculates the; // run-time number of elements (as opposed to just using the IR Value; // that corresponds to the run-time value of each bound that was; // generated when the array was created.) If this proves too embarrassing; // even for unoptimized IR, consider passing a magic-value/cookie to; // codegen that then knows to simply use that initial llvm::Value (that; // corresponds to the bound at time of array creation) within; // getelementptr. But be prepared to pay the price of increasing a; // customized form of coupling between the two components - which could; // be hard to maintain as the codebase evolves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:14,Integrability,Depend,DependentSizedArrayType,14,// Can't be a DependentSizedArrayType or an IncompleteArrayType since; // UnqAT is not incomplete and Range is not type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:120,Integrability,depend,dependent,120,// Can't be a DependentSizedArrayType or an IncompleteArrayType since; // UnqAT is not incomplete and Range is not type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:13,Availability,error,error,13,// Return an error if no fix was discovered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,Energy Efficiency,allocate,allocate,28,// Don't bother to actually allocate the result if we're just trying to; // determine whether it would be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:38,Modifiability,variab,variable,38,// In OpenMP loop region loop control variable must be private. Perform; // analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:64,Performance,Perform,Perform,64,// In OpenMP loop region loop control variable must be private. Perform; // analysis of first part (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:22,Modifiability,variab,variable,22,"// Warn when the loop variable is a const reference that creates a copy.; // Suggest using the non-reference type for copies. If a copy can be prevented; // suggest the const reference type that would do so.; // For instance, given ""for (const &Foo : Range)"", suggest; // ""for (const Foo : Range)"" to denote a copy is made for the loop. If; // possible, also suggest ""for (const &Bar : Range)"" if this type prevents; // the copy altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:8,Modifiability,variab,variable,8,"// Loop variable creates a temporary. Suggest either to go with; // non-reference loop variable to indicate a copy is made, or; // the correct type to bind a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:87,Modifiability,variab,variable,87,"// Loop variable creates a temporary. Suggest either to go with; // non-reference loop variable to indicate a copy is made, or; // the correct type to bind a const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:119,Modifiability,variab,variable,119,"// The range always returns a copy, so a temporary is always created.; // Suggest removing the reference from the loop variable.; // If the type is a rvalue reference do not warn since that changes the; // semantic of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:30,Modifiability,Variab,VariableType,30,/// Determines whether the @p VariableType's declaration is a record with the; /// clang::trivial_abi attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:23,Modifiability,variab,variable,23,"// Warns when the loop variable can be changed to a reference type to; // prevent a copy. For instance, if given ""for (const Foo x : Range)"" suggest; // ""for (const Foo &x : Range)"" if this form does not make a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:136,Performance,cache,cache,136,// Small trivially copyable types are cheap to copy. Do not emit the; // diagnostic for these instances. 64 bytes is a common size of a cache line.; // (The function `getTypeSize` returns the size in bits.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:33,Modifiability,variab,variable,33,// Suggest changing from a const variable to a const reference variable; // if doing so will prevent a copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:63,Modifiability,variab,variable,63,// Suggest changing from a const variable to a const reference variable; // if doing so will prevent a copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:219,Modifiability,variab,variable,219,/// FinishCXXForRangeStmt - Attach the body to a C++0x for-range statement.; /// This is a separate step from ActOnCXXForRangeStmt because analysis of the; /// body cannot be performed until after the type of the range variable is; /// determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:175,Performance,perform,performed,175,/// FinishCXXForRangeStmt - Attach the body to a C++0x for-range statement.; /// This is a separate step from ActOnCXXForRangeStmt because analysis of the; /// body cannot be performed until after the type of the range variable is; /// determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:98,Modifiability,variab,variable,98,// We cannot 'continue;' from within a statement expression in the; // initializer of a condition variable because we would jump past the; // initialization of that variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:165,Modifiability,variab,variable,165,// We cannot 'continue;' from within a statement expression in the; // initializer of a condition variable because we would jump past the; // initialization of that variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:434,Safety,detect,detection,434,"/// Determine whether the given expression might be move-eligible or; /// copy-elidable in either a (co_)return statement or throw expression,; /// without considering function return type, if applicable.; ///; /// \param E The expression being returned from the function or block,; /// being thrown, or being co_returned from a coroutine. This expression; /// might be modified by the implementation.; ///; /// \param Mode Overrides detection of current language mode; /// and uses the rules for C++23.; ///; /// \returns An aggregate which contains the Candidate and isMoveEligible; /// and isCopyElidable methods. If Candidate is non-null, it means; /// isMoveEligible() would be true under the most permissive language standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:47,Modifiability,variab,variable,47,"/// Determine whether the given NRVO candidate variable is move-eligible or; /// copy-elidable, without considering function return type.; ///; /// \param VD The NRVO candidate variable.; ///; /// \returns An aggregate which contains the Candidate and isMoveEligible; /// and isCopyElidable methods. If Candidate is non-null, it means; /// isMoveEligible() would be true under the most permissive language standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:177,Modifiability,variab,variable,177,"/// Determine whether the given NRVO candidate variable is move-eligible or; /// copy-elidable, without considering function return type.; ///; /// \param VD The NRVO candidate variable.; ///; /// \returns An aggregate which contains the Candidate and isMoveEligible; /// and isCopyElidable methods. If Candidate is non-null, it means; /// isMoveEligible() would be true under the most permissive language standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,Modifiability,variab,variable,53,// We don't want to implicitly move out of a __block variable during a return; // because we cannot assume the variable will no longer be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:111,Modifiability,variab,variable,111,// We don't want to implicitly move out of a __block variable during a return; // because we cannot assume the variable will no longer be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Modifiability,Variab,Variables,3,// Variables with higher required alignment than their type's ABI; // alignment cannot use NRVO.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:4,Deployability,Update,Updates,4,"/// Updates given NamedReturnInfo's move-eligible and; /// copy-elidable statuses, considering the function; /// return type criteria as applicable to return statements.; ///; /// \param Info The NamedReturnInfo object to update.; ///; /// \param ReturnType This is the return type of the function.; /// \returns The copy elision candidate, in case the initial return expression; /// was copy elidable, or nullptr otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:222,Deployability,update,update,222,"/// Updates given NamedReturnInfo's move-eligible and; /// copy-elidable statuses, considering the function; /// return type criteria as applicable to return statements.; ///; /// \param Info The NamedReturnInfo object to update.; ///; /// \param ReturnType This is the return type of the function.; /// \returns The copy elision candidate, in case the initial return expression; /// was copy elidable, or nullptr otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:56,Integrability,depend,dependent,56,"// If we got a non-deduced auto ReturnType, we are in a dependent context and; // there is no point in allowing copy elision since we won't have it deduced; // by the point the VardDecl is instantiated, which is the last chance we have; // of deciding if the candidate is really copy elidable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:120,Integrability,rout,routine,120,"/// Perform the initialization of a potentially-movable value, which; /// is the result of return value.; ///; /// This routine implements C++20 [class.copy.elision]p3, which attempts to; /// treat returned lvalues as rvalues in certain cases (to prefer move; /// construction), then falls back to treating them as lvalues if that failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:4,Performance,Perform,Perform,4,"/// Perform the initialization of a potentially-movable value, which; /// is the result of return value.; ///; /// This routine implements C++20 [class.copy.elision]p3, which attempts to; /// treat returned lvalues as rvalues in certain cases (to prefer move; /// construction), then falls back to treating them as lvalues if that failed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:38,Integrability,rout,routine,38,/// ActOnCapScopeReturnStmt - Utility routine to type-check return statements; /// for capturing scopes.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:111,Availability,error,error,111,"// If we've already decided this lambda is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:130,Availability,error,error,130,"// Although we'll properly infer the type of the block once it's completed,; // make sure we provide a return type now for better error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:136,Availability,recover,recovery,136,"// Although we'll properly infer the type of the block once it's completed,; // make sure we provide a return type now for better error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:136,Safety,recover,recovery,136,"// Although we'll properly infer the type of the block once it's completed,; // make sure we provide a return type now for better error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,Integrability,depend,dependent,53,// Delay processing for now. TODO: there are lots of dependent; // types we can conclusively prove aren't void.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:337,Availability,down,down,337,"// we have a non-void block with an expression, continue checking; // C99 6.8.6.4p3(136): The return statement is not an assignment. The; // overlap restriction of subclause 6.5.16.1 does not apply to the case of; // function return.; // In C++ the return statement is handled via a copy initialization.; // the C version of which boils down to CheckSingleAssignmentConstraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:50,Performance,optimiz,optimization,50,"// If we need to check for the named return value optimization,; // or if we need to infer the return type,; // save the return statement in our scope for later processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:182,Integrability,depend,dependent,182,// C++1y [dcl.spec.auto]p12:; // Return type deduction [...] occurs when the definition is; // instantiated even if the function body contains a return; // statement with a non-type-dependent operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:2,Integrability,Depend,DependentDeduction,2,/*DependentDeduction=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Deployability,Update,Update,3,// Update all declarations of the function to have the deduced return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:2,Availability,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:2,Safety,Recover,RecoverUncorrectedTypos,2,/*RecoverUncorrectedTypos=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:21,Usability,simpl,simpler,21,"// HACK: We suppress simpler implicit move here in msvc compatibility mode; // just as a temporary work around, as the MSVC STL has issues with; // this change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:64,Performance,perform,performing,64,// FIXME: Add a flag to the ScopeInfo to indicate whether we're performing; // deduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:113,Availability,error,error,113,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:222,Availability,Recover,RecoveryExpr,222,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:211,Integrability,wrap,wrapped,211,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:222,Safety,Recover,RecoveryExpr,222,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:17,Availability,failure,failure,17,"// The deduction failure is diagnosed and marked, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:57,Availability,recover,recover,57,"// The deduction failure is diagnosed and marked, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:57,Safety,recover,recover,57,"// The deduction failure is diagnosed and marked, try to recover.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,Availability,recover,recovery,28,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:99,Integrability,Depend,DependentTy,99,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,Safety,recover,recovery,28,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,Availability,recover,recovery,53,// Nothing to do: a ReturnStmt with no value is fine recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,Safety,recover,recovery,53,// Nothing to do: a ReturnStmt with no value is fine recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:6,Usability,simpl,simply,6,"// We simply never allow init lists as the return value of void; // functions. This is compatible because this was never allowed before,; // so there's no legacy code to deal with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:270,Availability,down,down,270,"// C99 6.8.6.4p3(136): The return statement is not an assignment. The; // overlap restriction of subclause 6.5.16.1 does not apply to the case of; // function return.; // In C++ the return statement is handled via a copy initialization,; // the C version of which boils down to CheckSingleAssignmentConstraints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:50,Performance,optimiz,optimization,50,"// If we need to check for the named return value optimization, save the; // return statement in our scope for later processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:19,Integrability,synchroniz,synchronized,19,// The operand to @synchronized is a full-expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:49,Integrability,synchroniz,synchronized,49,// We can't jump into or indirect-jump out of a @synchronized block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:22,Testability,test,test,22,// There's nothing to test that ActOnExceptionDecl didn't already test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:66,Testability,test,test,66,// There's nothing to test that ActOnExceptionDecl didn't already test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:19,Availability,error,error,19,// Don't report an error if 'try' is used in system headers or in an OpenMP; // target region compiled for a GPU architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:9,Availability,error,error,9,// Delay error emission for the OpenMP device code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Deployability,Update,Update,3,// Update parent expressions to have same ValueType as the underlying.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:262,Usability,guid,guidance,262,"/// CheckAsmLValue - GNU C has an extremely ugly extension whereby they silently; /// ignore ""noop"" casts in places where an lvalue is required by an inline asm.; /// We emulate this behavior when -fheinous-gnu-extensions is specified, but; /// provide a strong guidance to not use it.; ///; /// This method checks to see if the argument is an acceptable l-value and; /// returns false if it is a case we can handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:8,Integrability,depend,dependent,8,// Type dependent expressions will be checked during instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:33,Availability,error,error,33,"// Accept, even if we emitted an error diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:50,Modifiability,variab,variables,50,"// Bitfields, vector elements and global register variables are not; // compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:42,Modifiability,variab,variable,42,// Handle cases where the expression is a variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:55,Modifiability,extend,extended,55,// Collect all the input and output registers from the extended asm; // statement in order to check for conflicts with the clobber list,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:14,Integrability,depend,dependent,14,"// If this is dependent, just continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:33,Availability,error,error,33,"// Accept, even if we emitted an error diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Security,Validat,Validate,3,"// Validate the asm string, ensuring it makes sense given the operands we; // have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Security,Validat,Validate,3,// Validate constraints and modifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Security,Validat,Validate,3,// Validate tied input operands for type mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:103,Modifiability,extend,extend,103,"// If the smaller value wasn't mentioned in the asm string, and if the; // output was a register, just extend the shorter one to the size of the; // larger one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:225,Availability,down,down,225,"// Either both of the operands were mentioned or the smaller one was; // mentioned. One more special case that we'll allow: if the tied input is; // integer, unmentioned, and is a constant, then we'll allow truncating it; // down to the size of the destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:33,Security,access,access,33,// FIXME: Diagnose this as field access into a scalar type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:3,Security,Validat,Validation,3,// Validation is in Sema::ActOnAttributedStmt().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:67,Energy Efficiency,power,power,67,// This attribute requires an integer argument which is a constant power of; // two between 1 and 4096 inclusive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:99,Availability,error,errors,99,// Diagnose non-identical duplicates as a 'conflicting' loop attributes; // and suppress duplicate errors in cases where the two match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:49,Integrability,depend,dependent,49,"// Return early if first alignment expression is dependent (since we don't; // know what the effective size will be), and skip the loop entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:19,Integrability,depend,dependent,19,"// If the value is dependent, we can not test anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:41,Testability,test,test,41,"// If the value is dependent, we can not test anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:3,Testability,Test,Test,3,// Test the attribute values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:74,Security,expose,exposed,74,// The loop distribution transformation only has a state form that is; // exposed by #pragma clang loop distribute (enable | disable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:56,Security,expose,exposed,56,// The vector predication only has a state form that is exposed by; // #pragma clang loop vectorize_predicate (enable | disable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:3,Performance,Perform,Perform,3,// Perform the check for duplicated 'distribute' hints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp:131,Availability,error,error,131,// Emit notes only for the first discovered declaration of unsupported type; // to avoid mess of notes. This flag is to track that error already happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp:83,Safety,avoid,avoid,83,// Emit notes only for the first discovered declaration of unsupported type; // to avoid mess of notes. This flag is to track that error already happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaSYCL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,Integrability,inject,injected-class-name,91,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:127,Integrability,inject,injected-class-name,127,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:287,Integrability,inject,injected-class-name,287,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,Security,inject,injected-class-name,91,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:127,Security,inject,injected-class-name,127,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:287,Security,inject,injected-class-name,287,"// C++ [temp.local]p1:; // Like normal (non-template) classes, class templates have an; // injected-class-name (Clause 9). The injected-class-name; // can be used with or without a template-argument-list. When; // it is used without a template-argument-list, it is; // equivalent to the injected-class-name followed by the; // template-parameters of the class template enclosed in; // <>. When it is used with a template-argument-list, it; // refers to the specified class template specialization,; // which could be the current specialization or another; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Integrability,Depend,Dependent,10,// 'using Dependent::foo;' can resolve to a template name.; // 'using typename Dependent::foo;' cannot (not even if 'foo' is an; // injected-class-name).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:79,Integrability,Depend,Dependent,79,// 'using Dependent::foo;' can resolve to a template name.; // 'using typename Dependent::foo;' cannot (not even if 'foo' is an; // injected-class-name).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:132,Integrability,inject,injected-class-name,132,// 'using Dependent::foo;' can resolve to a template name.; // 'using typename Dependent::foo;' cannot (not even if 'foo' is an; // injected-class-name).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:132,Security,inject,injected-class-name,132,// 'using Dependent::foo;' can resolve to a template name.; // 'using typename Dependent::foo;' cannot (not even if 'foo' is an; // injected-class-name).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:131,Availability,error,error,131,"// If we got an ambiguity involving a non-function template, treat this; // as a template name, and pick an arbitrary template for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,Availability,recover,recovery,137,"// If we got an ambiguity involving a non-function template, treat this; // as a template name, and pick an arbitrary template for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,Safety,recover,recovery,137,"// If we got an ambiguity involving a non-function template, treat this; // as a template name, and pick an arbitrary template for error recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:103,Usability,guid,guide,103,"// We could use redeclaration lookup here, but we don't need to: the; // syntactic form of a deduction guide is enough to identify it even; // if we can't look up the template name at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:80,Usability,guid,guide,80,// We only treat template-names that name type templates as valid deduction; // guide names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Availability,recover,recover,12,// We can't recover unless there's a dependent scope specifier preceding the; // template name.; // FIXME: Typo correction?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:37,Integrability,depend,dependent,37,// We can't recover unless there's a dependent scope specifier preceding the; // template name.; // FIXME: Typo correction?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Safety,recover,recover,12,// We can't recover unless there's a dependent scope specifier preceding the; // template name.; // FIXME: Typo correction?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:57,Integrability,depend,dependent,57,// The code is missing a 'template' keyword prior to the dependent template; // name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,Performance,perform,perform,22,// Determine where to perform name lookup,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:49,Security,access,access,49,"// This nested-name-specifier occurs in a member access expression, e.g.,; // x->B::f, and we are looking into the type of the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Deployability,Update,Update,3,// Update the DeclContext to point to the Tag definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Performance,Perform,Perform,3,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:130,Security,access,access,130,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:106,Integrability,depend,dependent,106,"// FIXME: The C++ standard does not clearly specify what happens in the; // case where the object type is dependent, and implementations vary. In; // Clang, we treat a name after a . or -> as a template-name if lookup; // finds a non-dependent member or member of the current instantiation that; // is a type template, or finds no such members and lookup in the context; // of the postfix-expression finds a type template. In the latter case, the; // name is nonetheless dependent, and we may resolve it to a member of an; // unknown specialization when we come to instantiate the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:234,Integrability,depend,dependent,234,"// FIXME: The C++ standard does not clearly specify what happens in the; // case where the object type is dependent, and implementations vary. In; // Clang, we treat a name after a . or -> as a template-name if lookup; // finds a non-dependent member or member of the current instantiation that; // is a type template, or finds no such members and lookup in the context; // of the postfix-expression finds a type template. In the latter case, the; // name is nonetheless dependent, and we may resolve it to a member of an; // unknown specialization when we come to instantiate the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:471,Integrability,depend,dependent,471,"// FIXME: The C++ standard does not clearly specify what happens in the; // case where the object type is dependent, and implementations vary. In; // Clang, we treat a name after a . or -> as a template-name if lookup; // finds a non-dependent member or member of the current instantiation that; // is a type template, or finds no such members and lookup in the context; // of the postfix-expression finds a type template. In the latter case, the; // name is nonetheless dependent, and we may resolve it to a member of an; // unknown specialization when we come to instantiate the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,Usability,clear,clearly,36,"// FIXME: The C++ standard does not clearly specify what happens in the; // case where the object type is dependent, and implementations vary. In; // Clang, we treat a name after a . or -> as a template-name if lookup; // finds a non-dependent member or member of the current instantiation that; // is a type template, or finds no such members and lookup in the context; // of the postfix-expression finds a type template. In the latter case, the; // name is nonetheless dependent, and we may resolve it to a member of an; // unknown specialization when we come to instantiate the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:56,Security,access,access,56,"// C++ [basic.lookup.classref]p1:; // In a class member access expression (5.2.5), if the . or -> token is; // immediately followed by an identifier followed by a <, the; // identifier must be looked up to determine whether the < is the; // beginning of a template argument list (14.2) or a less-than operator.; // The identifier is first looked up in the class of the object; // expression. If the identifier is not found, it is then looked up in; // the context of the entire postfix-expression and shall name a class; // template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:77,Modifiability,variab,variable,77,"// FIXME: We should filter out all non-type templates here, particularly; // variable templates and concepts. But the exclusion of alias templates; // and template template parameters is a wording defect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Usability,Simpl,Simple,3,"// Simple filter callback that, for keywords, only accepts the C++ *_cast",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,Availability,error,error,91,"// If a 'template' keyword was used, a lookup that finds only non-template; // names is an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:238,Performance,perform,perform,238,"// C++03 [basic.lookup.classref]p1:; // [...] If the lookup in the class of the object expression finds a; // template, the name is also looked up in the context of the entire; // postfix-expression and [...]; //; // Note: C++11 does not perform this second lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Availability,Recover,Recover,3,// Recover by taking the template that we found in the object; // expression's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Safety,Recover,Recover,3,// Recover by taking the template that we found in the object; // expression's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:16,Integrability,depend,dependent-scope,16,"// If this is a dependent-scope lookup, diagnose that the 'template' keyword; // was missing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:42,Integrability,depend,dependent,42,/// ActOnDependentIdExpression - Handle a dependent id-expression that; /// was just parsed. This is only possible with an explicit scope; /// specifier naming a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:162,Integrability,depend,dependent,162,/// ActOnDependentIdExpression - Handle a dependent id-expression that; /// was just parsed. This is only possible with an explicit scope; /// specifier naming a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:314,Integrability,Depend,DependentScopeDeclRefExpr,314,"// C++11 [expr.prim.general]p12:; // An id-expression that denotes a non-static data member or non-static; // member function of a class can only be used:; // (...); // - if that id-expression denotes a non-static data member and it; // appears in an unevaluated operand.; //; // If this might be the case, form a DependentScopeDeclRefExpr instead of a; // CXXDependentScopeMemberExpr. The former can instantiate to either; // DeclRefExpr or MemberExpr depending on lookup results, while the latter is; // always a MemberExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:453,Integrability,depend,depending,453,"// C++11 [expr.prim.general]p12:; // An id-expression that denotes a non-static data member or non-static; // member function of a class can only be used:; // (...); // - if that id-expression denotes a non-static data member and it; // appears in an unevaluated operand.; //; // If this might be the case, form a DependentScopeDeclRefExpr instead of a; // CXXDependentScopeMemberExpr. The former can instantiate to either; // DeclRefExpr or MemberExpr depending on lookup results, while the latter is; // always a MemberExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:68,Performance,perform,perform,68,"// Since the 'this' expression is synthesized, we don't need to; // perform the double-lookup check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Integrability,Depend,DependentScopeDeclRefExpr,3,// DependentScopeDeclRefExpr::Create requires a valid QualifierLoc,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:41,Availability,recover,recover,41,"// If we're allowed to diagnose this and recover, do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:41,Safety,recover,recover,41,"// If we're allowed to diagnose this and recover, do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:75,Availability,error,error,75,"// In general, Instantiation isn't marked invalid to get more than one; // error for multiple undefined instantiations. But the code that does; // explicit declaration -> explicit definition conversion can't handle; // invalid declarations, so mark as invalid in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:222,Availability,error,error,222,"/// DiagnoseTemplateParameterShadow - Produce a diagnostic complaining; /// that the template parameter 'PrevDecl' is being shadowed by a new; /// declaration at location Loc. Returns true to indicate that this is; /// an error, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:90,Integrability,inject,injected-class-name,90,"// This is a normal type template argument. Note, if the type template; // argument is an injected-class-name for a template, it has a dual nature; // and can be used as either a type or a template. We handle that in; // convertTypeTemplateArgumentToTemplate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:90,Security,inject,injected-class-name,90,"// This is a normal type template argument. Note, if the type template; // argument is an injected-class-name for a template, it has a dual nature; // and can be used as either a type or a template. We handle that in; // convertTypeTemplateArgumentToTemplate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:79,Availability,error,error,79,/// Attach a type-constraint to a template parameter.; /// \returns true if an error occurred. This can happen if the; /// immediately-declared constraint could not be formed (e.g. incorrect number; /// of arguments for the named concept).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:57,Integrability,depend,dependent,57,"// C++17 [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains; // - an identifier associated by name lookup with a non-type; // template-parameter declared with a type that contains a; // placeholder type (7.1.7.4),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,Availability,error,error,111,"/// Require the given type to be a structural type, and diagnose if it is not.; ///; /// \return \c true if an error was produced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:9,Availability,down,down,9,// Drill down into the reason why the class is non-structural.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:18,Modifiability,variab,variably-modified,18,// We don't allow variably-modified types as the type of non-type template; // parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,Integrability,depend,dependent,13,"// If T is a dependent type, we can't do the check now, so we; // assume that it is well-formed. Note that stripping off the; // qualifiers here is not really correct if T turns out to be; // an array type, but we'll recompute the type everywhere it's; // used during instantiation, so that should be OK. (Using the; // qualified type is equally wrong.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:106,Modifiability,variab,variable,106,// [dcl.inline]p1:; // The inline specifier can be applied only to the declaration or; // definition of a variable or function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:99,Modifiability,variab,variable,99,// [dcl.constexpr]p1:; // The constexpr specifier shall be applied only to the definition of a; // variable or variable template or the declaration of a function or; // function template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,Modifiability,variab,variable,111,// [dcl.constexpr]p1:; // The constexpr specifier shall be applied only to the definition of a; // variable or variable template or the declaration of a function or; // function template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Availability,Recover,Recover,3,// Recover with an 'int' type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Safety,Recover,Recover,3,// Recover with an 'int' type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:167,Integrability,depend,dependent,167,"// Check only that we have a template template argument. We don't want to; // try to check well-formedness now, because our template template parameter; // might have dependent types in its template parameters, which we wouldn't; // be able to match now.; //; // If none of the template template parameter's template arguments mention; // other template parameters, we could actually perform more checking here.; // However, it isn't worth doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:384,Performance,perform,perform,384,"// Check only that we have a template template argument. We don't want to; // try to check well-formedness now, because our template template parameter; // might have dependent types in its template parameters, which we wouldn't; // be able to match now.; //; // If none of the template template parameter's template arguments mention; // other template parameters, we could actually perform more checking here.; // However, it isn't worth doing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:203,Availability,avail,available,203,"// FIXME : This is possibly an incomplete list, but it is unclear what other; // Decl kinds could be used to refer to the template parameters. This is a; // best guess so far based on examples currently available, but the; // unreachable should catch future instances/cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:35,Integrability,depend,dependent,35,"// If we're adding a template to a dependent context, we may need to; // rebuilding some of the types used within the template parameter list,; // now that we know what the current instantiation is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,Integrability,inject,injected-class-name,25,"// We may have found the injected-class-name of a class template,; // class template partial specialization, or class template specialization.; // In these cases, grab the template that is being defined or specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,Security,inject,injected-class-name,25,"// We may have found the injected-class-name of a class template,; // class template partial specialization, or class template specialization.; // In these cases, grab the template that is being defined or specialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Availability,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Safety,Recover,Recover,3,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:98,Integrability,depend,dependent,98,// Ensure that the template parameter lists are compatible. Skip this check; // for a friend in a dependent context: the template parameter list itself; // could be dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:165,Integrability,depend,dependent,165,// Ensure that the template parameter lists are compatible. Skip this check; // for a friend in a dependent context: the template parameter list itself; // could be dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:72,Usability,simpl,simply,72,"// If we have a prior definition that is not visible, treat this as; // simply making that previous definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:89,Availability,error,error,89,"// FIXME: Would it make sense to try to ""forget"" the previous; // definition, as part of error recovery?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:95,Availability,recover,recovery,95,"// FIXME: Would it make sense to try to ""forget"" the previous; // definition, as part of error recovery?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:95,Safety,recover,recovery,95,"// FIXME: Would it make sense to try to ""forget"" the previous; // definition, as part of error recovery?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:194,Integrability,depend,dependent,194,"// Check the template parameter list of this declaration, possibly; // merging in the template parameter list from the previous class; // template declaration. Skip this check for a friend in a dependent; // context, because the template parameter list might be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:262,Integrability,depend,dependent,262,"// Check the template parameter list of this declaration, possibly; // merging in the template parameter list from the previous class; // template declaration. Skip this check for a friend in a dependent; // context, because the template parameter list might be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Integrability,depend,dependent,38,"// If this is a templated friend in a dependent context we should not put it; // on the redecl chain. In some cases, the templated friend can be the most; // recent declaration tricking the template instantiator to make substitutions; // there.; // FIXME: Figure out how to combine with shouldLinkDependentDeclWithPrevious",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:11,Security,access,access,11,// Set the access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:107,Usability,guid,guide,107,"/// Tree transform to ""extract"" a transformed type from a class template's; /// constructor to a deduction guide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:97,Integrability,depend,dependent,97,// Transform the underlying type of the typedef and clone the Decl only if; // the typedef has a dependent context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,Usability,guid,guide,101,"/// Transform to convert portions of a constructor declaration into the; /// corresponding deduction guide, per C++1z [over.match.class.deduct]p1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:57,Usability,guid,guide,57,/// Transform a constructor declaration into a deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,Usability,guid,guide,22,/// Build a deduction guide with the specified parameter types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:64,Usability,guid,guide,64,"/// Transform a constructor template parameter into a deduction guide template; /// parameter, rebuilding any internal references to earlier parameters and; /// renumbering as we go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:216,Integrability,inject,injected-class-name,216,"// -- The return type is the class template specialization designated by; // the template-name and template arguments corresponding to the; // template parameters obtained from the class template.; //; // We use the injected-class-name type of the primary template instead.; // This has the convenient property that it is different from any type that; // the user can write in a deduction-guide (because they cannot enter the; // context of the template), so implicit deduction guides can never collide; // with explicit ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:216,Security,inject,injected-class-name,216,"// -- The return type is the class template specialization designated by; // the template-name and template arguments corresponding to the; // template parameters obtained from the class template.; //; // We use the injected-class-name type of the primary template instead.; // This has the convenient property that it is different from any type that; // the user can write in a deduction-guide (because they cannot enter the; // context of the template), so implicit deduction guides can never collide; // with explicit ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:389,Usability,guid,guide,389,"// -- The return type is the class template specialization designated by; // the template-name and template arguments corresponding to the; // template parameters obtained from the class template.; //; // We use the injected-class-name type of the primary template instead.; // This has the convenient property that it is different from any type that; // the user can write in a deduction-guide (because they cannot enter the; // context of the template), so implicit deduction guides can never collide; // with explicit ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:478,Usability,guid,guides,478,"// -- The return type is the class template specialization designated by; // the template-name and template arguments corresponding to the; // template parameters obtained from the class template.; //; // We use the injected-class-name type of the primary template instead.; // This has the convenient property that it is different from any type that; // the user can write in a deduction-guide (because they cannot enter the; // context of the template), so implicit deduction guides can never collide; // with explicit ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:39,Modifiability,inherit,inherit,39,"// Resolving a wording defect, we also inherit the variadicness of the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:158,Safety,avoid,avoiding,158,"// Extract the type. This (for instance) replaces references to typedef; // members of the current instantiations with the definitions of those; // typedefs, avoiding triggering instantiation of the deduced type during; // deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:39,Modifiability,inherit,inherit,39,"// Resolving a wording defect, we also inherit default arguments from the; // constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:32,Usability,guid,guide,32,// Build the implicit deduction guide template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:79,Usability,guid,guides,79,"// In case we were expanding a pack when we attempted to declare deduction; // guides, turn off pack expansion for everything we're about to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:106,Usability,guid,guides,106,"// Create a template instantiation record to track the ""instantiation"" of; // constructors into deduction guides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:50,Usability,guid,guides,50,// Check whether we've already declared deduction guides for this template.; // FIXME: Consider storing a flag on the template to indicate this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:79,Usability,guid,guides,79,"// In case we were expanding a pack when we attempted to declare deduction; // guides, turn off pack expansion for everything we're about to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:106,Usability,guid,guides,106,"// Create a template instantiation record to track the ""instantiation"" of; // constructors into deduction guides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Usability,guid,guide,48,// Convert declared constructors into deduction guide templates.; // FIXME: Skip constructors for which deduction must necessarily fail (those; // for which some class template parameter without a default argument never; // appears in a deduced context).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:159,Usability,guid,guides,159,"// Within C++20 modules, we may have multiple same constructors in; // multiple same RecordDecls. And it doesn't make sense to create; // duplicated deduction guides for the duplicated constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:86,Usability,guid,guides,86,// Class-scope explicit specializations (MS extension) do not result in; // deduction guides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:27,Usability,guid,guide,27,// Cannot make a deduction guide when unparsed arguments are present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:1101,Availability,error,error,1101,"/// Checks the validity of a template parameter list, possibly; /// considering the template parameter list from a previous; /// declaration.; ///; /// If an ""old"" template parameter list is provided, it must be; /// equivalent (per TemplateParameterListsAreEqual) to the ""new""; /// template parameter list.; ///; /// \param NewParams Template parameter list for a new template; /// declaration. This template parameter list will be updated with any; /// default arguments that are carried through from the previous; /// template parameter list.; ///; /// \param OldParams If provided, template parameter list from a; /// previous declaration of the same template. Default template; /// arguments will be merged from the old template parameter list to; /// the new template parameter list.; ///; /// \param TPC Describes the context in which we are checking the given; /// template parameter list.; ///; /// \param SkipBody If we might have already made a prior merged definition; /// of this template visible, the corresponding body-skipping information.; /// Default argument redefinition is not an error when skipping such a body,; /// because (under the ODR) we can assume the default arguments are the same; /// as the prior merged definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:1279,Availability,error,error,1279,"/// Checks the validity of a template parameter list, possibly; /// considering the template parameter list from a previous; /// declaration.; ///; /// If an ""old"" template parameter list is provided, it must be; /// equivalent (per TemplateParameterListsAreEqual) to the ""new""; /// template parameter list.; ///; /// \param NewParams Template parameter list for a new template; /// declaration. This template parameter list will be updated with any; /// default arguments that are carried through from the previous; /// template parameter list.; ///; /// \param OldParams If provided, template parameter list from a; /// previous declaration of the same template. Default template; /// arguments will be merged from the old template parameter list to; /// the new template parameter list.; ///; /// \param TPC Describes the context in which we are checking the given; /// template parameter list.; ///; /// \param SkipBody If we might have already made a prior merged definition; /// of this template visible, the corresponding body-skipping information.; /// Default argument redefinition is not an error when skipping such a body,; /// because (under the ODR) we can assume the default arguments are the same; /// as the prior merged definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:433,Deployability,update,updated,433,"/// Checks the validity of a template parameter list, possibly; /// considering the template parameter list from a previous; /// declaration.; ///; /// If an ""old"" template parameter list is provided, it must be; /// equivalent (per TemplateParameterListsAreEqual) to the ""new""; /// template parameter list.; ///; /// \param NewParams Template parameter list for a new template; /// declaration. This template parameter list will be updated with any; /// default arguments that are carried through from the previous; /// template parameter list.; ///; /// \param OldParams If provided, template parameter list from a; /// previous declaration of the same template. Default template; /// arguments will be merged from the old template parameter list to; /// the new template parameter list.; ///; /// \param TPC Describes the context in which we are checking the given; /// template parameter list.; ///; /// \param SkipBody If we might have already made a prior merged definition; /// of this template visible, the corresponding body-skipping information.; /// Default argument redefinition is not an error when skipping such a body,; /// because (under the ODR) we can assume the default arguments are the same; /// as the prior merged definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:66,Availability,avail,available,66,// C++ [temp.param]p10:; // The set of default template-arguments available for use with a; // template declaration or definition is obtained by merging the; // default arguments from the definition (if in scope) and all; // declarations in scope in the same way default function; // arguments are (8.3.6).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:27,Safety,avoid,avoid,27,// Dummy initialization to avoid warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Modifiability,Variab,Variable,3,// Variable used to diagnose missing default arguments,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Modifiability,Variab,Variable,3,// Variable used to diagnose non-final parameter packs,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:287,Usability,Simpl,Simply,287,"// [basic.def.odr]/13:; // There can be more than one definition of a; // ...; // default template argument; // ...; // in a program provided that each definition appears in a different; // translation unit and the definitions satisfy the [same-meaning; // criteria of the ODR].; //; // Simply, the design of modules allows the definition of template default; // argument to be repeated across translation unit. Note that the ODR is; // checked elsewhere. But it is still not allowed to repeat template default; // argument in the same translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,Integrability,depend,dependent,101,// Whether we're looking for a use of a template parameter that makes the; // overall construct type-dependent / a dependent type. This is strictly; // best-effort for now; we may fail to match at all for a dependent type; // in some cases if this is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:115,Integrability,depend,dependent,115,// Whether we're looking for a use of a template parameter that makes the; // overall construct type-dependent / a dependent type. This is strictly; // best-effort for now; we may fail to match at all for a dependent type; // in some cases if this is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:207,Integrability,depend,dependent,207,// Whether we're looking for a use of a template parameter that makes the; // overall construct type-dependent / a dependent type. This is strictly; // best-effort for now; we may fail to match at all for a dependent type; // in some cases if this is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,Integrability,depend,dependent,22,"// Prune out non-type-dependent expressions if requested. This can; // sometimes result in us failing to find a template parameter reference; // (if a value-dependent expression creates a dependent type), but this; // mode is best-effort only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:157,Integrability,depend,dependent,157,"// Prune out non-type-dependent expressions if requested. This can; // sometimes result in us failing to find a template parameter reference; // (if a value-dependent expression creates a dependent type), but this; // mode is best-effort only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:188,Integrability,depend,dependent,188,"// Prune out non-type-dependent expressions if requested. This can; // sometimes result in us failing to find a template parameter reference; // (if a value-dependent expression creates a dependent type), but this; // mode is best-effort only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:64,Integrability,depend,depends,64,// end anonymous namespace; /// Determines whether a given type depends on the given parameter; /// list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,Integrability,depend,dependent,28,// Look one step prior in a dependent template specialization type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,Integrability,depend,dependent,28,// Look one step prior in a dependent name type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:9,Integrability,depend,dependent,9,"// For a dependent type, the set of template parameters that we; // expect to see.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:67,Integrability,depend,depend,67,// In friend declarations we can have template-ids which don't; // depend on the corresponding template parameter lists. But; // assume that empty parameter lists are supposed to match this; // template-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:176,Integrability,depend,dependent,176,"// We have a template parameter list with no corresponding scope, which; // means that the resulting template declaration can't be instantiated; // properly (we'll end up with dependent nodes when we shouldn't).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,Integrability,wrap,wrapped,22,"// The type argument, wrapped in substitution sugar, gets reused as the; // first template argument in the synthetic template argument list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:6,Usability,simpl,simply,6,// We simply return the type at index `Index`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:150,Testability,log,logical,150,"/// Collect all of the separable terms in the given condition, which; /// might be a conjunction.; ///; /// FIXME: The right answer is to convert the logical expression into; /// disjunctive normal form, so we can find the first failed term; /// within each possible clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,Integrability,depend,dependent,105,"// The ranges-v3 library uses an odd pattern of a top-level ""||"" with; // a left-hand side that is value-dependent but never true. Identify; // the idiom and ignore that term.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,Modifiability,variab,variable,22,"// This is a template variable, print the expanded template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,Integrability,depend,dependent,58,"// When building a template-id where the template-name is dependent,; // assume the template is a type template. Either our assumption is; // correct, or the code is ill-formed and will be diagnosed when the; // dependent name is substituted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:212,Integrability,depend,dependent,212,"// When building a template-id where the template-name is dependent,; // assume the template is a type template. Either our assumption is; // correct, or the code is ill-formed and will be diagnosed when the; // dependent name is substituted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:43,Integrability,depend,dependent,43,"// This class template specialization is a dependent; // type. Therefore, its canonical type is another class template; // specialization type that contains all of the converted; // arguments in canonical form. This ensures that, e.g., A<T> and; // A<T, T> have identical types when A is declared as:; //; // template<typename T, typename U = T> struct A;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:107,Integrability,Inject,InjectedClassNameType,107,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:107,Security,Inject,InjectedClassNameType,107,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:177,Security,hash,hashtable,177,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:170,Usability,simpl,simple,170,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Integrability,Inject,InjectedClassNameTypes,38,// Look for one of the two cases with InjectedClassNameTypes; // and check whether it's the same template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Security,Inject,InjectedClassNameTypes,38,// Look for one of the two cases with InjectedClassNameTypes; // and check whether it's the same template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,Integrability,inject,injected,13,// Fetch the injected class name type and check whether its; // injected type is equal to the type we just built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:64,Integrability,inject,injected,64,// Fetch the injected class name type and check whether its; // injected type is equal to the type we just built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,Security,inject,injected,13,// Fetch the injected class name type and check whether its; // injected type is equal to the type we just built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:64,Security,inject,injected,64,// Fetch the injected class name type and check whether its; // injected type is equal to the type we just built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Integrability,inject,injected,48,"// If so, the canonical type of this TST is the injected; // class name type of the record we just found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Security,inject,injected,48,"// If so, the canonical type of this TST is the injected; // class name type of the record we just found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,Integrability,depend,depends,105,"// C++ [temp.res]p3:; // A qualified-id that refers to a type and in which the; // nested-name-specifier depends on a template-parameter (14.6.2); // shall be prefixed by the keyword typename to indicate that the; // qualified-id denotes a type, forming an; // elaborated-type-specifier (7.1.5.3).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,Availability,recover,recovery,36,// FIXME: This is not quite correct recovery as we don't transform SS; // into the corresponding dependent form (and we don't diagnose missing; // 'template' keywords within SS as a result).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:97,Integrability,depend,dependent,97,// FIXME: This is not quite correct recovery as we don't transform SS; // into the corresponding dependent form (and we don't diagnose missing; // 'template' keywords within SS as a result).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,Safety,recover,recovery,36,// FIXME: This is not quite correct recovery as we don't transform SS; // into the corresponding dependent form (and we don't diagnose missing; // 'template' keywords within SS as a result).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:53,Integrability,inject,injected-class-name,53,"// Per C++ [class.qual]p2, if the template-id was an injected-class-name,; // it's not actually allowed to be used as a type in most cases. Because; // we annotate it before we know whether it's valid, we have to check for; // this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:53,Security,inject,injected-class-name,53,"// Per C++ [class.qual]p2, if the template-id was an injected-class-name,; // it's not actually allowed to be used as a type in most cases. Because; // we annotate it before we know whether it's valid, we have to check for; // this case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Integrability,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Security,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:84,Usability,simpl,simple-template-id,84,"// C++0x [dcl.type.elab]p2:; // If the identifier resolves to a typedef-name or the simple-template-id; // resolves to an alias template specialization, the; // elaborated-type-specifier is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,Availability,failure,failure,101,// FIXME: Get the TDK from deduction in order to provide better diagnostics; // for non-substitution-failure issues?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:66,Usability,guid,guide,66,// C++1z [temp.param]p11:; // A template parameter of a deduction guide template that does not have a; // default-argument shall be deducible from the parameter-type-list of the; // deduction guide template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:192,Usability,guid,guide,192,// C++1z [temp.param]p11:; // A template parameter of a deduction guide template that does not have a; // default-argument shall be deducible from the parameter-type-list of the; // deduction guide template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,Modifiability,variab,variable,13,// D must be variable template id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:31,Modifiability,variab,variable,31,// The template-id must name a variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Modifiability,variab,variable,12,// Find the variable template (partial) specialization declaration that; // corresponds to these arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Modifiability,variab,variable,2,/*variable template*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Availability,Recover,Recover,10,// FIXME: Recover from this by treating the declaration as a redeclaration; // of the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Safety,Recover,Recover,10,// FIXME: Recover from this by treating the declaration as a redeclaration; // of the primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Modifiability,variab,variable,34,// Check whether we can declare a variable template specialization in; // the current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:24,Modifiability,variab,variable,24,"// Since the only prior variable template specialization with these; // arguments was referenced but not declared, reuse that; // declaration node as our own, updating its source location and; // the list of outer template parameters to reflect our new declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:62,Modifiability,variab,variable,62,"// If we are providing an explicit specialization of a member variable; // template specialization, make a note of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:56,Integrability,depend,dependent,56,// Produce a placeholder value if the specialization is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Modifiability,variab,variable,12,// Find the variable template specialization declaration that; // corresponds to these arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:24,Modifiability,variab,variable,24,"// If we already have a variable template specialization, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:50,Modifiability,variab,variable,50,"// This is the first time we have referenced this variable template; // specialization. Create the canonical declaration and add it to; // the set of specializations, based on the closest partial specialization; // that it represents. That is,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:325,Modifiability,variab,variable,325,"// -- If more than one matching specialization is found, the; // partial order rules (14.5.4.2) are used to determine; // whether one of the specializations is more specialized; // than the others. If none of the specializations is more; // specialized than all of the other matching; // specializations, then the use of the variable template is; // ambiguous and the program is ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:30,Modifiability,variab,variable,30,// Instantiate using the best variable template partial specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Usability,clear,clear,38,// Partial ordering did not produce a clear winner. Complain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:19,Modifiability,variab,variable,19,"// In C++1y, check variable template ids.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,Integrability,depend,dependent,13,// Result is dependent. Carry on to build an UnresolvedLookupEpxr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:557,Integrability,depend,dependent,557,"/// Form a template name from a name that is syntactically required to name a; /// template, either due to use of the 'template' keyword or because a name in; /// this syntactic context is assumed to name a template (C++ [temp.names]p2-4).; ///; /// This action forms a template name given the name of the template and its; /// optional scope specifier. This is used when the 'template' keyword is used; /// or when the parsing context unambiguously treats a following '<' as; /// introducing a template argument list. Note that this may produce a; /// non-dependent template name if we can perform the lookup now and identify; /// the named template.; ///; /// For example, given ""x.MetaFun::template apply"", the scope specifier; /// \p SS will be ""MetaFun::"", \p TemplateKWLoc contains the location; /// of the ""template"" keyword, and ""apply"" is the \p Name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:591,Performance,perform,perform,591,"/// Form a template name from a name that is syntactically required to name a; /// template, either due to use of the 'template' keyword or because a name in; /// this syntactic context is assumed to name a template (C++ [temp.names]p2-4).; ///; /// This action forms a template name given the name of the template and its; /// optional scope specifier. This is used when the 'template' keyword is used; /// or when the parsing context unambiguously treats a following '<' as; /// introducing a template argument list. Note that this may produce a; /// non-dependent template name if we can perform the lookup now and identify; /// the named template.; ///; /// For example, given ""x.MetaFun::template apply"", the scope specifier; /// \p SS will be ""MetaFun::"", \p TemplateKWLoc contains the location; /// of the ""template"" keyword, and ""apply"" is the \p Name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:475,Integrability,depend,dependent,475,"// C++0x [temp.names]p5:; // If a name prefixed by the keyword template is not the name of; // a template, the program is ill-formed. [Note: the keyword; // template may not be applied to non-template members of class; // templates. -end note ] [ Note: as is the case with the; // typename prefix, the template prefix is allowed in cases; // where it is not strictly necessary; i.e., when the; // nested-name-specifier or the expression on the left of the ->; // or . is not dependent on a template-parameter, or the use; // does not appear in the scope of a template. -end note]; //; // Note: C++03 was more strict here, because it banned the use of; // the ""template"" keyword prior to a template-name that was not a; // dependent name. C++ DR468 relaxed this requirement (the; // ""template"" keyword is now permitted). We follow the C++0x; // rules, even in C++03 mode with a warning, retroactively applying the DR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:722,Integrability,depend,dependent,722,"// C++0x [temp.names]p5:; // If a name prefixed by the keyword template is not the name of; // a template, the program is ill-formed. [Note: the keyword; // template may not be applied to non-template members of class; // templates. -end note ] [ Note: as is the case with the; // typename prefix, the template prefix is allowed in cases; // where it is not strictly necessary; i.e., when the; // nested-name-specifier or the expression on the left of the ->; // or . is not dependent on a template-parameter, or the use; // does not appear in the scope of a template. -end note]; //; // Note: C++03 was more strict here, because it banned the use of; // the ""template"" keyword prior to a template-name that was not a; // dependent name. C++ DR468 relaxed this requirement (the; // ""template"" keyword is now permitted). We follow the C++0x; // rules, even in C++03 mode with a warning, retroactively applying the DR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:30,Integrability,depend,dependent,30,// We resolved this to a (non-dependent) template name. Return it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:372,Availability,recover,recover,372,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:175,Integrability,inject,injected-class-name,175,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:400,Integrability,inject,injected-class-name,400,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:372,Safety,recover,recover,372,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:175,Security,inject,injected-class-name,175,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:400,Security,inject,injected-class-name,400,"// C++14 [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // [...] is the injected-class-name of C, [...] the name is instead; // considered to name the constructor; //; // We don't get here if naming the constructor would be valid, so we; // just reject immediately and recover by treating the; // injected-class-name as naming the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Integrability,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Security,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:54,Integrability,depend,dependent,54,"// Didn't find a template name, and the lookup wasn't dependent.; // Do the lookup again to determine if this is a ""nothing found"" case or; // a ""not a template"" case. FIXME: Refactor isTemplateName so we don't; // need to do this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:175,Modifiability,Refactor,Refactor,175,"// Didn't find a template name, and the lookup wasn't dependent.; // Do the lookup again to determine if this is a ""nothing found"" case or; // a ""not a template"" case. FIXME: Refactor isTemplateName so we don't; // need to do this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:61,Integrability,depend,dependent,61,"// This is a kind of template name, but can never occur in a dependent; // scope (literal operators can only be declared at namespace scope).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,Integrability,depend,dependent,36,// This name cannot possibly name a dependent template. Diagnose this now; // rather than building a dependent template name that can never be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,Integrability,depend,dependent,101,// This name cannot possibly name a dependent template. Diagnose this now; // rather than building a dependent template name that can never be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Availability,Recover,Recover,3,// Recover by synthesizing a type using the location information that we; // already have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Safety,Recover,Recover,3,// Recover by synthesizing a type using the location information that we; // already have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,Availability,recover,recover,58,// Overwrite our input TemplateArgumentLoc so that we can recover; // properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,Safety,recover,recover,58,// Overwrite our input TemplateArgumentLoc so that we can recover; // properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:849,Availability,error,error,849,"/// Substitute template arguments into the default template argument for; /// the given template type parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:184,Performance,perform,performing,184,"/// Substitute template arguments into the default template argument for; /// the given template type parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:27,Integrability,depend,dependent,27,"// If the argument type is dependent, instantiate it now based; // on the previously-computed template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:858,Availability,error,error,858,"/// Substitute template arguments into the default template argument for; /// the given non-type template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the non-type template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:188,Performance,perform,performing,188,"/// Substitute template arguments into the default template argument for; /// the given non-type template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the non-type template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:1002,Availability,error,error,1002,"/// Substitute template arguments into the default template argument for; /// the given template template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \param QualifierLoc Will be set to the nested-name-specifier (with; /// source-location information) that precedes the template name.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:188,Performance,perform,performing,188,"/// Substitute template arguments into the default template argument for; /// the given template template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \param QualifierLoc Will be set to the nested-name-specifier (with; /// source-location information) that precedes the template name.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:104,Integrability,inject,injected-class-names,104,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:128,Performance,perform,perform,128,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:104,Security,inject,injected-class-names,104,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Integrability,inject,injected-class-name,34,"// If this type was written as an injected-class-name, it can be used as a; // template template argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Security,inject,injected-class-name,34,"// If this type was written as an injected-class-name, it can be used as a; // template template argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Integrability,inject,injected-class-name,34,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:155,Integrability,wrap,wrapped,155,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:270,Integrability,inject,injected-class-name,270,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Security,inject,injected-class-name,34,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:270,Security,inject,injected-class-name,270,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:1011,Availability,error,error,1011,"/// Check that the given template argument corresponds to the given; /// template parameter.; ///; /// \param Param The template parameter against which the argument will be; /// checked.; ///; /// \param Arg The template argument, which may be updated due to conversions.; ///; /// \param Template The template in which the template argument resides.; ///; /// \param TemplateLoc The location of the template name for the template; /// whose argument list we're matching.; ///; /// \param RAngleLoc The location of the right angle bracket ('>') that closes; /// the template argument list.; ///; /// \param ArgumentPackIndex The index into the argument pack where this; /// argument will be placed. Only valid if the parameter is a parameter pack.; ///; /// \param Converted The checked, converted argument will be added to the; /// end of this small vector.; ///; /// \param CTAK Describes how we arrived at this particular template argument:; /// explicitly written, deduced, etc.; ///; /// \returns true on error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:245,Deployability,update,updated,245,"/// Check that the given template argument corresponds to the given; /// template parameter.; ///; /// \param Param The template parameter against which the argument will be; /// checked.; ///; /// \param Arg The template argument, which may be updated due to conversions.; ///; /// \param Template The template in which the template argument resides.; ///; /// \param TemplateLoc The location of the template name for the template; /// whose argument list we're matching.; ///; /// \param RAngleLoc The location of the right angle bracket ('>') that closes; /// the template argument list.; ///; /// \param ArgumentPackIndex The index into the argument pack where this; /// argument will be placed. Only valid if the parameter is a parameter pack.; ///; /// \param Converted The checked, converted argument will be added to the; /// end of this small vector.; ///; /// \param CTAK Describes how we arrived at this particular template argument:; /// explicitly written, deduced, etc.; ///; /// \returns true on error, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:149,Integrability,depend,dependent,149,// Do substitution on the type of the non-type template parameter; // with the template arguments we've seen thus far. But if the; // template has a dependent context then we cannot substitute yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,Availability,error,error,46,"// If the current template argument causes an error, give up now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:42,Integrability,Depend,DependentTemplateName,42,"// FIXME: the template-template arg was a DependentTemplateName,; // so it was provided with a template keyword. However, its source; // location is not stored in the template argument structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:251,Integrability,depend,dependent,251,"// Substitute into the template parameter list of the template; // template parameter, since previously-supplied template arguments; // may appear within the template template parameter.; //; // FIXME: Skip this if the parameters aren't instantiation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Integrability,inject,injected-class-name,48,// C++1z [temp.local]p1: (DR1004); // When [the injected-class-name] is used [...] as a template-argument for; // a template template-parameter [...] it refers to the class template; // itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Security,inject,injected-class-name,48,// C++1z [temp.local]p1: (DR1004); // When [the injected-class-name] is used [...] as a template-argument for; // a template template-parameter [...] it refers to the class template; // itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Availability,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Safety,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:223,Integrability,depend,dependent,223,"// If we're performing a partial argument substitution, allow any trailing; // pack expansions; they might be empty. This can happen even if; // PartialTemplateArgs is false (the list of arguments is complete but; // still dependent).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Performance,perform,performing,12,"// If we're performing a partial argument substitution, allow any trailing; // pack expansions; they might be empty. This can happen even if; // PartialTemplateArgs is false (the list of arguments is complete but; // still dependent).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:185,Availability,error,error,185,"/// Check a template argument against its corresponding; /// template type parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.type]. It; /// returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:101,Integrability,rout,routine,101,"/// Check a template argument against its corresponding; /// template type parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.type]. It; /// returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,Availability,avail,available,48,// dllimport'd entities aren't constant but are available inside of template; // arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:145,Availability,redundant,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:145,Safety,redund,redundant,145,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,Availability,recover,recover,81,"// The types didn't match, but we know we got a null pointer; complain,; // then recover as if the types were correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,Safety,recover,recover,81,"// The types didn't match, but we know we got a null pointer; complain,; // then recover as if the types were correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:146,Integrability,message,message,146,"// We found a pointer that isn't null, but doesn't refer to an object.; // We could just return NPV_NotNullPointer, but we can print a better; // message with the information we have here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Performance,perform,perform,12,// We can't perform this conversion or binding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:67,Integrability,depend,dependent,67,"// Stop checking the precise nature of the argument if it is value dependent,; // it should be checked when instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:120,Availability,recover,recover,120,"// If the template parameter has pointer type but the address of; // this object was not taken, complain and (possibly) recover by; // taking the address of the entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:120,Safety,recover,recover,120,"// If the template parameter has pointer type but the address of; // this object was not taken, complain and (possibly) recover by; // taking the address of the entity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Performance,perform,perform,12,// We can't perform this conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:176,Availability,error,error,176,"/// Check a template argument against its corresponding; /// non-type template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.nontype].; /// If an error occurred, it returns ExprError(); otherwise, it; /// returns the converted template argument. \p ParamType is the; /// type of the non-type template parameter after it has been instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,Integrability,rout,routine,105,"/// Check a template argument against its corresponding; /// non-type template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.nontype].; /// If an error occurred, it returns ExprError(); otherwise, it; /// returns the converted template argument. \p ParamType is the; /// type of the non-type template parameter after it has been instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,Integrability,depend,dependent,91,"// During template argument deduction, we allow 'decltype(auto)' to; // match an arbitrary dependent argument.; // FIXME: The language rules don't say what happens in this case.; // FIXME: We get an opaque dependent type out of decltype(auto) if the; // expression is merely instantiation-dependent; is this enough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:206,Integrability,depend,dependent,206,"// During template argument deduction, we allow 'decltype(auto)' to; // match an arbitrary dependent argument.; // FIXME: The language rules don't say what happens in this case.; // FIXME: We get an opaque dependent type out of decltype(auto) if the; // expression is merely instantiation-dependent; is this enough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:289,Integrability,depend,dependent,289,"// During template argument deduction, we allow 'decltype(auto)' to; // match an arbitrary dependent argument.; // FIXME: The language rules don't say what happens in this case.; // FIXME: We get an opaque dependent type out of decltype(auto) if the; // expression is merely instantiation-dependent; is this enough?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:91,Integrability,depend,dependent,91,"// When checking a deduced template argument, deduce from its type even if; // the type is dependent, in order to check the types of non-type template; // arguments line up properly in partial ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Integrability,Depend,DependentDeduction,2,/*DependentDeduction=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,Availability,error,error,81,"// CheckNonTypeTemplateParameterType will produce a diagnostic if there's; // an error. The error message normally references the parameter; // declaration, but here we'll pass the argument location because that's; // where the parameter type is deduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:92,Availability,error,error,92,"// CheckNonTypeTemplateParameterType will produce a diagnostic if there's; // an error. The error message normally references the parameter; // declaration, but here we'll pass the argument location because that's; // where the parameter type is deduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:98,Integrability,message,message,98,"// CheckNonTypeTemplateParameterType will produce a diagnostic if there's; // an error. The error message normally references the parameter; // declaration, but here we'll pass the argument location because that's; // where the parameter type is deduced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,Integrability,depend,dependent,28,"// FIXME: If either type is dependent, we skip the check. This isn't; // correct, since during deduction we're supposed to have replaced each; // template parameter with some unique (non-dependent) placeholder.; // FIXME: If the argument type contains 'auto', we carry on and fail the; // type check in order to force specific types to be more specialized than; // 'auto'. It's not clear how partial ordering with 'auto' is supposed to; // work. Similarly for CTAD, when comparing 'A<x>' against 'A'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:187,Integrability,depend,dependent,187,"// FIXME: If either type is dependent, we skip the check. This isn't; // correct, since during deduction we're supposed to have replaced each; // template parameter with some unique (non-dependent) placeholder.; // FIXME: If the argument type contains 'auto', we carry on and fail the; // type check in order to force specific types to be more specialized than; // 'auto'. It's not clear how partial ordering with 'auto' is supposed to; // work. Similarly for CTAD, when comparing 'A<x>' against 'A'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:382,Usability,clear,clear,382,"// FIXME: If either type is dependent, we skip the check. This isn't; // correct, since during deduction we're supposed to have replaced each; // template parameter with some unique (non-dependent) placeholder.; // FIXME: If the argument type contains 'auto', we carry on and fail the; // type check in order to force specific types to be more specialized than; // 'auto'. It's not clear how partial ordering with 'auto' is supposed to; // work. Similarly for CTAD, when comparing 'A<x>' against 'A'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:33,Integrability,depend,dependent,33,"// If either the parameter has a dependent type or the argument is; // type-dependent, there's nothing we can check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:76,Integrability,depend,dependent,76,"// If either the parameter has a dependent type or the argument is; // type-dependent, there's nothing we can check now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:323,Integrability,inject,inject,323,"// Avoid making a copy when initializing a template parameter of class type; // from a template parameter object of the same type. This is going beyond; // the standard, but is required for soundness: in; // template<A a> struct X { X *p; X<a> *q; };; // ... we need p and q to have the same type.; //; // Similarly, don't inject a call to a copy constructor when initializing; // from a template parameter of the same type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Safety,Avoid,Avoid,3,"// Avoid making a copy when initializing a template parameter of class type; // from a template parameter object of the same type. This is going beyond; // the standard, but is required for soundness: in; // template<A a> struct X { X *p; X<a> *q; };; // ... we need p and q to have the same type.; //; // Similarly, don't inject a call to a copy constructor when initializing; // from a template parameter of the same type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:323,Security,inject,inject,323,"// Avoid making a copy when initializing a template parameter of class type; // from a template parameter object of the same type. This is going beyond; // the standard, but is required for soundness: in; // template<A a> struct X { X *p; X<a> *q; };; // ... we need p and q to have the same type.; //; // Similarly, don't inject a call to a copy constructor when initializing; // from a template parameter of the same type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,Integrability,depend,dependent,15,"// For a value-dependent argument, CheckConvertedConstantExpression is; // permitted (and expected) to be unable to determine a value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:123,Modifiability,variab,variable,123,"// -- a temporary object; // -- a string literal; // -- the result of a typeid expression, or; // -- a predefined __func__ variable",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:63,Performance,perform,performed,63,// C++ [temp.arg.nontype]p5:; // The following conversions are performed on each expression used; // as a non-type template-argument. If a non-type; // template-argument cannot be converted to the type of the; // corresponding template-parameter then the program is; // ill-formed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,Integrability,depend,dependent,34,// We can't check arbitrary value-dependent arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:157,Modifiability,extend,extend,157,"// Widen the argument value to sizeof(parameter type). This is almost; // always a no-op, except when the parameter type is bool. In; // that case, this may extend the argument from 1 bit to 8 bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,Performance,perform,perform,12,// We can't perform this conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,Integrability,depend,dependent,25,// The argument is value-dependent. Create a new; // TemplateArgument with the converted expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:193,Availability,error,error,193,"/// Check a template argument against its corresponding; /// template template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.template].; /// It returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,Integrability,rout,routine,105,"/// Check a template argument against its corresponding; /// template template parameter.; ///; /// This routine implements the semantics of C++ [temp.arg.template].; /// It returns true if an error occurred, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:7,Integrability,depend,dependent,7,// Any dependent template name is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:51,Availability,failure,failures,51,// FIXME: Produce better diagnostics for deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:152,Integrability,rout,routine,152,/// Construct a new expression that refers to the given; /// integral template argument with the given source-location; /// information.; ///; /// This routine takes care of the mapping from an integral template; /// argument (which may have any integral type) to the appropriate; /// literal value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:204,Integrability,wrap,wrapped,204,"// There isn't necessarily a valid equivalent source-level syntax for; // these; in particular, a naive lowering might violate access control.; // So for now we lower to a ConstantExpr holding the value, wrapped around; // an OpaqueValueExpr.; // FIXME: We should have a better representation for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:127,Security,access,access,127,"// There isn't necessarily a valid equivalent source-level syntax for; // these; in particular, a naive lowering might violate access control.; // So for now we lower to a ConstantExpr holding the value, wrapped around; // an OpaqueValueExpr.; // FIXME: We should have a better representation for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:144,Integrability,depend,dependent,144,"// If we are matching a template template argument to a template; // template parameter and one of the non-type template parameter types; // is dependent, then we must wait until template instantiation time; // to actually compare the arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:409,Integrability,rout,routine,409,"/// Determine whether the given template parameter lists are; /// equivalent.; ///; /// \param New The new template parameter list, typically written in the; /// source code as part of a new template declaration.; ///; /// \param Old The old template parameter list, typically found via; /// name lookup of the template declared with this template parameter; /// list.; ///; /// \param Complain If true, this routine will produce a diagnostic if; /// the template parameter lists are not equivalent.; ///; /// \param Kind describes how we are to match the template parameter lists.; ///; /// \param TemplateArgLoc If this source location is valid, then we; /// are actually checking the template parameter list of a template; /// argument (New) against the template parameter list of its; /// corresponding template template parameter (Old). We produce; /// slightly different diagnostics in this scenario.; ///; /// \returns True if the template parameter lists are equal, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:886,Availability,error,error,886,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:907,Availability,recover,recover,907,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:94,Integrability,rout,routine,94,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:300,Performance,perform,performed,300,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:907,Safety,recover,recover,907,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:112,Integrability,rout,routine,112,"// Keep these ""kind"" numbers in sync with the %select statements in the; // various diagnostics emitted by this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:54,Availability,error,error,54,"// Don't allow specializing in the wrong class during error recovery.; // Otherwise, things can go horribly wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:60,Availability,recover,recovery,60,"// Don't allow specializing in the wrong class during error recovery.; // Otherwise, things can go horribly wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:60,Safety,recover,recovery,60,"// Don't allow specializing in the wrong class during error recovery.; // Otherwise, things can go horribly wrong.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:446,Integrability,depend,dependent,446,"// C++ [temp.class.spec]p9:; // Within the argument list of a class template partial; // specialization, the following restrictions apply:; // -- A partially specialized non-type argument expression; // shall not involve a template parameter of the partial; // specialization except when the argument expression is a; // simple identifier.; // -- The type of a template parameter corresponding to a; // specialized non-type argument shall not be dependent on a; // parameter of the specialization.; // DR1315 removes the first bullet, leaving an incoherent set of rules.; // We implement a compromise between the original rules and DR1315:; // -- A specialized non-type template argument shall not be; // type-dependent and the corresponding template parameter; // shall have a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:710,Integrability,depend,dependent,710,"// C++ [temp.class.spec]p9:; // Within the argument list of a class template partial; // specialization, the following restrictions apply:; // -- A partially specialized non-type argument expression; // shall not involve a template parameter of the partial; // specialization except when the argument expression is a; // simple identifier.; // -- The type of a template parameter corresponding to a; // specialized non-type argument shall not be dependent on a; // parameter of the specialization.; // DR1315 removes the first bullet, leaving an incoherent set of rules.; // We implement a compromise between the original rules and DR1315:; // -- A specialized non-type template argument shall not be; // type-dependent and the corresponding template parameter; // shall have a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:782,Integrability,depend,dependent,782,"// C++ [temp.class.spec]p9:; // Within the argument list of a class template partial; // specialization, the following restrictions apply:; // -- A partially specialized non-type argument expression; // shall not involve a template parameter of the partial; // specialization except when the argument expression is a; // simple identifier.; // -- The type of a template parameter corresponding to a; // specialized non-type argument shall not be dependent on a; // parameter of the specialization.; // DR1315 removes the first bullet, leaving an incoherent set of rules.; // We implement a compromise between the original rules and DR1315:; // -- A specialized non-type template argument shall not be; // type-dependent and the corresponding template parameter; // shall have a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:321,Usability,simpl,simple,321,"// C++ [temp.class.spec]p9:; // Within the argument list of a class template partial; // specialization, the following restrictions apply:; // -- A partially specialized non-type argument expression; // shall not involve a template parameter of the partial; // specialization except when the argument expression is a; // simple identifier.; // -- The type of a template parameter corresponding to a; // specialized non-type argument shall not be dependent on a; // parameter of the specialization.; // DR1315 removes the first bullet, leaving an incoherent set of rules.; // We implement a compromise between the original rules and DR1315:; // -- A specialized non-type template argument shall not be; // type-dependent and the corresponding template parameter; // shall have a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:505,Availability,error,error,505,"/// Check the non-type template arguments of a class template; /// partial specialization according to C++ [temp.class.spec]p9.; ///; /// \param TemplateNameLoc the location of the template name.; /// \param PrimaryTemplate the template parameters of the primary class; /// template.; /// \param NumExplicit the number of explicitly-specified template arguments.; /// \param TemplateArgs the template arguments of the class template; /// partial specialization.; ///; /// \returns \c true if there was an error, \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:60,Integrability,depend,dependent,60,// We have to be conservative when checking a template in a dependent; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:218,Availability,redundant,redundant,218,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:304,Availability,recover,recovery,304,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:218,Safety,redund,redundant,218,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:304,Safety,recover,recovery,304,"// C++ [temp.class.spec]p9b3:; //; // -- The argument list of the specialization shall not be identical; // to the implicit argument list of the primary template.; //; // This rule has since been removed, because it's redundant given DR1495,; // but we keep it because it produces better diagnostics and recovery.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:31,Availability,error,error,31,// FIXME: we should produce an error in case of ambig and failed lookups.; // Other decls (e.g. namespaces) also have this shortcoming.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:949,Availability,error,error,949,"/// Diagnose cases where we have an explicit template specialization; /// before/after an explicit template instantiation, producing diagnostics; /// for those cases where they are required and determining whether the; /// new specialization/instantiation will have any effect.; ///; /// \param NewLoc the location of the new explicit specialization or; /// instantiation.; ///; /// \param NewTSK the kind of the new explicit specialization or instantiation.; ///; /// \param PrevDecl the previous declaration of the entity.; ///; /// \param PrevTSK the kind of the old explicit specialization or instantiatin.; ///; /// \param PrevPointOfInstantiation if valid, indicates where the previous; /// declaration was instantiated (either implicitly or explicitly).; ///; /// \param HasNoEffect will be set to true to indicate that the new; /// specialization or instantiation has no effect and should be ignored.; ///; /// \returns true if there was an error that should prevent the introduction of; /// the new declaration into the AST, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,Availability,redundant,redundant,46,// This explicit instantiation declaration is redundant (that's okay).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,Safety,redund,redundant,46,// This explicit instantiation declaration is redundant (that's okay).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:44,Integrability,depend,dependent,44,"/// Perform semantic analysis for the given dependent function; /// template specialization.; ///; /// The only possible way to get a dependent function template specialization; /// is with a friend declaration, like so:; ///; /// \code; /// template \<class T> void foo(T);; /// template \<class T> class A {; /// friend void foo<>(T);; /// };; /// \endcode; ///; /// There really isn't any useful analysis we can do here, so we; /// just store the information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:134,Integrability,depend,dependent,134,"/// Perform semantic analysis for the given dependent function; /// template specialization.; ///; /// The only possible way to get a dependent function template specialization; /// is with a friend declaration, like so:; ///; /// \code; /// template \<class T> void foo(T);; /// template \<class T> class A {; /// friend void foo<>(T);; /// };; /// \endcode; ///; /// There really isn't any useful analysis we can do here, so we; /// just store the information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic analysis for the given dependent function; /// template specialization.; ///; /// The only possible way to get a dependent function template specialization; /// is with a friend declaration, like so:; ///; /// \code; /// template \<class T> void foo(T);; /// template \<class T> class A {; /// friend void foo<>(T);; /// };; /// \endcode; ///; /// There really isn't any useful analysis we can do here, so we; /// just store the information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:383,Deployability,update,updated,383,"/// Perform semantic analysis for the given function template; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit function template specialization. On successful completion,; /// the function declaration \p FD will become a function template; /// specialization.; ///; /// \param FD the function declaration, which will be updated to become a; /// function template specialization.; ///; /// \param ExplicitTemplateArgs the explicitly-provided template arguments,; /// if any. Note that this may be valid info even when 0 arguments are; /// explicitly provided as in, e.g., \c void sort<>(char*, char*);; /// as it anyway contains info on the angle brackets locations.; ///; /// \param Previous the set of declarations that may be specialized by; /// this function specialization.; ///; /// \param QualifiedFriend whether this is a lookup for a qualified friend; /// declaration with no explicit template argument list that might be; /// befriending a function template specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:98,Integrability,rout,routine,98,"/// Perform semantic analysis for the given function template; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit function template specialization. On successful completion,; /// the function declaration \p FD will become a function template; /// specialization.; ///; /// \param FD the function declaration, which will be updated to become a; /// function template specialization.; ///; /// \param ExplicitTemplateArgs the explicitly-provided template arguments,; /// if any. Note that this may be valid info even when 0 arguments are; /// explicitly provided as in, e.g., \c void sort<>(char*, char*);; /// as it anyway contains info on the angle brackets locations.; ///; /// \param Previous the set of declarations that may be specialized by; /// this function specialization.; ///; /// \param QualifiedFriend whether this is a lookup for a qualified friend; /// declaration with no explicit template argument list that might be; /// befriending a function template specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic analysis for the given function template; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit function template specialization. On successful completion,; /// the function declaration \p FD will become a function template; /// specialization.; ///; /// \param FD the function declaration, which will be updated to become a; /// function template specialization.; ///; /// \param ExplicitTemplateArgs the explicitly-provided template arguments,; /// if any. Note that this may be valid info even when 0 arguments are; /// explicitly provided as in, e.g., \c void sort<>(char*, char*);; /// as it anyway contains info on the angle brackets locations.; ///; /// \param Previous the set of declarations that may be specialized by; /// this function specialization.; ///; /// \param QualifiedFriend whether this is a lookup for a qualified friend; /// declaration with no explicit template argument list that might be; /// befriending a function template specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:106,Performance,perform,performs,106,"/// Perform semantic analysis for the given function template; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit function template specialization. On successful completion,; /// the function declaration \p FD will become a function template; /// specialization.; ///; /// \param FD the function declaration, which will be updated to become a; /// function template specialization.; ///; /// \param ExplicitTemplateArgs the explicitly-provided template arguments,; /// if any. Note that this may be valid info even when 0 arguments are; /// explicitly provided as in, e.g., \c void sort<>(char*, char*);; /// as it anyway contains info on the angle brackets locations.; ///; /// \param Previous the set of declarations that may be specialized by; /// this function specialization.; ///; /// \param QualifiedFriend whether this is a lookup for a qualified friend; /// declaration with no explicit template argument list that might be; /// befriending a function template specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:228,Performance,Perform,Perform,228,// C++ [temp.expl.spec]p11:; // A trailing template-argument can be left unspecified in the; // template-id naming an explicit function template specialization; // provided it can be deduced from the function argument type.; // Perform template argument deduction to determine whether we may be; // specializing this template.; // FIXME: It is somewhat wasteful to build,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Security,access,access,10,// Ignore access information; it doesn't figure into redeclaration checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:191,Deployability,update,update,191,"// C++11 [dcl.constexpr]p1: An explicit specialization of a constexpr; // function can differ from the template declaration with respect to; // the constexpr specifier.; // FIXME: We need an update record for this AST mutation.; // FIXME: What if there are multiple such prior declarations (for instance,; // from different modules)?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:41,Modifiability,inherit,inherit,41,"// Since explicit specializations do not inherit '=delete' from their; // primary function template - check if the 'specialization' that was; // implicitly generated (during template argument deduction for partial; // ordering) from the most specialized of all the function templates that; // 'FD' could have been specializing, has a 'deleted' definition. If so,; // first check that it was implicitly generated during template argument; // deduction by making sure it wasn't referenced, and then reset the deleted; // flag to not-deleted, so that we can inherit that information from 'FD'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:555,Modifiability,inherit,inherit,555,"// Since explicit specializations do not inherit '=delete' from their; // primary function template - check if the 'specialization' that was; // implicitly generated (during template argument deduction for partial; // ordering) from the most specialized of all the function templates that; // 'FD' could have been specializing, has a 'deleted' definition. If so,; // first check that it was implicitly generated during template argument; // deduction by making sure it wasn't referenced, and then reset the deleted; // flag to not-deleted, so that we can inherit that information from 'FD'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,Testability,assert,assert,15,// FIXME: This assert will not hold in the presence of modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:21,Deployability,update,update,21,// FIXME: We need an update record for this AST mutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:21,Deployability,update,update,21,// FIXME: We need an update record for this AST mutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Modifiability,inherit,inherits,38,"// A function template specialization inherits the target attributes; // of its template. (We require the attributes explicitly in the; // code to match, but a template may have implicit attributes by; // virtue e.g. of being constexpr, and it passes these implicit; // attributes on to its specializations.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:383,Deployability,update,updated,383,"/// Perform semantic analysis for the given non-template member; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit member function specialization. On successful completion,; /// the function declaration \p FD will become a member function; /// specialization.; ///; /// \param Member the member declaration, which will be updated to become a; /// specialization.; ///; /// \param Previous the set of declarations, one of which may be specialized; /// by this function specialization; the set will be modified to contain the; /// redeclared member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:100,Integrability,rout,routine,100,"/// Perform semantic analysis for the given non-template member; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit member function specialization. On successful completion,; /// the function declaration \p FD will become a member function; /// specialization.; ///; /// \param Member the member declaration, which will be updated to become a; /// specialization.; ///; /// \param Previous the set of declarations, one of which may be specialized; /// by this function specialization; the set will be modified to contain the; /// redeclared member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Performance,Perform,Perform,4,"/// Perform semantic analysis for the given non-template member; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit member function specialization. On successful completion,; /// the function declaration \p FD will become a member function; /// specialization.; ///; /// \param Member the member declaration, which will be updated to become a; /// specialization.; ///; /// \param Previous the set of declarations, one of which may be specialized; /// by this function specialization; the set will be modified to contain the; /// redeclared member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:108,Performance,perform,performs,108,"/// Perform semantic analysis for the given non-template member; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit member function specialization. On successful completion,; /// the function declaration \p FD will become a member function; /// specialization.; ///; /// \param Member the member declaration, which will be updated to become a; /// specialization.; ///; /// \param Previous the set of declarations, one of which may be specialized; /// by this function specialization; the set will be modified to contain the; /// redeclared member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:78,Modifiability,inherit,inherit,78,// Explicit specializations of member functions of class templates do not; // inherit '=delete' from the member function they are specializing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,Testability,assert,assert,15,// FIXME: This assert will not hold in the presence of modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:21,Deployability,update,update,21,// FIXME: We need an update record for this AST mutation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:230,Deployability,update,update,230,"// FIXME: Inform AST mutation listeners of this AST mutation.; // FIXME: If there are multiple in-class declarations of the member (from; // multiple modules, or a declaration and later definition of a member type),; // should we update all of them?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:87,Availability,error,error,87,"/// Check the scope of an explicit instantiation.; ///; /// \returns true if a serious error occurs, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:272,Usability,simpl,simple-template-id,272,"// C++11 [temp.explicit]p3:; // If the explicit instantiation is for a member function, a member class; // or a static data member of a class template specialization, the name of; // the class template specialization in the qualified-id for the member; // name shall be a simple-template-id.; //; // C++98 has the same restriction, just worded differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:279,Deployability,update,updated,279,"// Since the only prior class template specialization with these; // arguments was referenced but not declared, reuse that; // declaration node as our own, updating the source location; // for the template name to reflect our new declaration.; // (Other source locations will be updated later.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:254,Performance,perform,perform,254,// C++ [temp.explicit]p3:; // A definition of a class template or class member template; // shall be in scope at the point of the explicit instantiation of; // the class template or class member template.; //; // This check comes when we actually try to perform the; // instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:263,Modifiability,extend,extend,263,"// An explicit instantiation definition can add a dll attribute to a; // template with a previous implicit instantiation. MinGW doesn't allow; // this. We limit clang to only adding dllexport, to avoid potentially; // strange codegen behavior. For example, if we extend this conditional; // to dllimport, and we have a source file calling a method on an; // implicitly instantiated template class instance and then declaring a; // dllimport explicit instantiation definition for the same template; // class, the codegen for the method call will not respect the dllimport,; // while it will with cl. The Def will already have the DLL attribute,; // since the Def and Specialization will be the same in the case of; // Old_TSK == TSK_ImplicitInstantiation, and we already added the; // attribute to the Specialization; we just need to make it take effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:196,Safety,avoid,avoid,196,"// An explicit instantiation definition can add a dll attribute to a; // template with a previous implicit instantiation. MinGW doesn't allow; // this. We limit clang to only adding dllexport, to avoid potentially; // strange codegen behavior. For example, if we extend this conditional; // to dllimport, and we have a source file calling a method on an; // implicitly instantiated template class instance and then declaring a; // dllimport explicit instantiation definition for the same template; // class, the codegen for the method call will not respect the dllimport,; // while it will with cl. The Def will already have the DLL attribute,; // since the Def and Specialization will be the same in the case of; // Old_TSK == TSK_ImplicitInstantiation, and we already added the; // attribute to the Specialization; we just need to make it take effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:167,Usability,simpl,simple-template-id,167,"// C++0x [temp.explicit]p2:; // If the explicit instantiation is for a class or member class, the; // elaborated-type-specifier in the declaration shall include a; // simple-template-id.; //; // C++98 has the same restriction, just worded differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:168,Availability,avail,available,168,"// FIXME: We don't have any representation for explicit instantiations of; // member classes. Such a representation is not needed for compilation, but it; // should be available for clients that want to see all of the declarations in; // the source code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,Usability,guid,guide,15,// A deduction guide is not on the list of entities that can be explicitly; // instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:220,Modifiability,variab,variable,220,// C++ [temp.explicit]p1:; // A [...] static data member of a class template can be explicitly; // instantiated from the member definition associated with its class; // template.; // C++1y [temp.explicit]p1:; // A [...] variable [...] template specialization can be explicitly; // instantiated from its template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,Modifiability,variab,variable,28,// Explicitly instantiate a variable template.; // C++1y [dcl.spec.auto]p6:; // ... A program that uses auto or decltype(auto) in a context not; // explicitly allowed in this section is ill-formed.; //; // This includes auto-typed variable template instantiations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:231,Modifiability,variab,variable,231,// Explicitly instantiate a variable template.; // C++1y [dcl.spec.auto]p6:; // ... A program that uses auto or decltype(auto) in a context not; // explicitly allowed in this section is ill-formed.; //; // This includes auto-typed variable template instantiations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:71,Modifiability,variab,variable,71,"// C++1y [temp.explicit]p3:; // If the explicit instantiation is for a variable, the unqualified-id; // in the declaration shall be a template-id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:127,Availability,error,error,127,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,Availability,recover,recovery,137,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:24,Integrability,depend,dependent,24,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,Safety,recover,recovery,137,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Security,access,access,10,"// Ignore access control bits, we don't need them for redeclaration; // checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:388,Modifiability,variab,variable,388,"// C++0x [temp.explicit]p2:; // If the explicit instantiation is for a member function, a member class; // or a static data member of a class template specialization, the name of; // the class template specialization in the qualified-id for the member; // name shall be a simple-template-id.; //; // C++98 has the same restriction, just worded differently.; //; // This does not apply to variable template specializations, where the; // template-id is in the unqualified-id instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:272,Usability,simpl,simple-template-id,272,"// C++0x [temp.explicit]p2:; // If the explicit instantiation is for a member function, a member class; // or a static data member of a class template specialization, the name of; // the class template specialization in the qualified-id for the member; // name shall be a simple-template-id.; //; // C++98 has the same restriction, just worded differently.; //; // This does not apply to variable template specializations, where the; // template-id is in the unqualified-id instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:37,Modifiability,variab,variable,37,// Instantiate static data member or variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:17,Modifiability,variab,variable,17,// Check the new variable specialization against the parsed input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:19,Testability,assert,assert,19,// FIXME: Can this assert ever happen? Needs a test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:47,Testability,test,test,47,// FIXME: Can this assert ever happen? Needs a test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Security,access,access,10,"// Ignore access control bits, we don't need them for redeclaration checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:272,Usability,simpl,simple-template-id,272,"// C++0x [temp.explicit]p2:; // If the explicit instantiation is for a member function, a member class; // or a static data member of a class template specialization, the name of; // the class template specialization in the qualified-id for the member; // name shall be a simple-template-id.; //; // C++98 has the same restriction, just worded differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,Integrability,inject,injected-class-name,111,"// Strangely, non-type results are not ignored by this lookup, so the; // program is ill-formed if it finds an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,Security,inject,injected-class-name,111,"// Strangely, non-type results are not ignored by this lookup, so the; // program is ill-formed if it finds an injected-class-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Integrability,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:2,Security,inject,injected-class-name,2,/*injected-class-name used as template name*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,Integrability,depend,dependent,15,// Construct a dependent template specialization type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:35,Integrability,depend,dependent,35,"// If the nested-name-specifier is dependent and couldn't be; // resolved to a type, build a typename type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:37,Availability,down,down,37,"// If we have a condition, narrow it down to the specific failed; // condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:71,Availability,recover,recover,71,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,Integrability,depend,dependent,28,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:71,Safety,recover,recover,71,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:225,Integrability,inject,injected-class-name,225,"// C++ [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // after the nested-name-specifier, when looked up in C, is the; // injected-class-name of C [...] then the name is instead considered; // to name the constructor of class C.; //; // Unlike in an elaborated-type-specifier, function names are not ignored; // in typename-specifier lookup. However, they are ignored in all the; // contexts where we form a typename type with no keyword (that is, in; // mem-initializer-ids, base-specifiers, and elaborated-type-specifiers).; //; // FIXME: That's not strictly true: mem-initializer-id lookup does not; // ignore functions, but that appears to be an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:225,Security,inject,injected-class-name,225,"// C++ [class.qual]p2:; // In a lookup in which function names are not ignored and the; // nested-name-specifier nominates a class C, if the name specified; // after the nested-name-specifier, when looked up in C, is the; // injected-class-name of C [...] then the name is instead considered; // to name the constructor of class C.; //; // Unlike in an elaborated-type-specifier, function names are not ignored; // in typename-specifier lookup. However, they are ignored in all the; // contexts where we form a typename type with no keyword (that is, in; // mem-initializer-ids, base-specifiers, and elaborated-type-specifiers).; //; // FIXME: That's not strictly true: mem-initializer-id lookup does not; // ignore functions, but that appears to be an oversight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:17,Usability,simpl,simple,17,// C++ [dcl.type.simple]p2:; // A type-specifier of the form; // typename[opt] nested-name-specifier[opt] template-name; // is a placeholder for a deduced class type [...].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:114,Availability,error,error,114,"// If we get here, it's because name lookup did not find a; // type. Emit an appropriate diagnostic and return an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:199,Integrability,depend,dependent,199,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// For the purposes of type reconstruction, a type has already been; /// transformed if it is NULL or if it is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:379,Integrability,rout,routine,379,"// end anonymous namespace; /// Rebuilds a type within the context of the current instantiation.; ///; /// The type \p T is part of the type of an out-of-line member definition of; /// a class template (or class template partial specialization) that was parsed; /// and constructed before we entered the scope of the class template (or; /// partial specialization thereof). This routine will rebuild that type now; /// that we have entered the declarator's scope, which may produce different; /// canonical types, e.g.,; ///; /// \code; /// template<typename T>; /// struct X {; /// typedef T* pointer;; /// pointer data();; /// };; ///; /// template<typename T>; /// typename X<T>::pointer X<T>::data() { ... }; /// \endcode; ///; /// Here, the type ""typename X<T>::pointer"" will be created as a DependentNameType,; /// since we do not know that we can look into X<T> when we parsed the type.; /// This function will rebuild the type, performing the lookup of ""pointer""; /// in X<T> and returning an ElaboratedType whose canonical type is the same; /// as the canonical type of T*, allowing the return types of the out-of-line; /// definition and the declaration to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:797,Integrability,Depend,DependentNameType,797,"// end anonymous namespace; /// Rebuilds a type within the context of the current instantiation.; ///; /// The type \p T is part of the type of an out-of-line member definition of; /// a class template (or class template partial specialization) that was parsed; /// and constructed before we entered the scope of the class template (or; /// partial specialization thereof). This routine will rebuild that type now; /// that we have entered the declarator's scope, which may produce different; /// canonical types, e.g.,; ///; /// \code; /// template<typename T>; /// struct X {; /// typedef T* pointer;; /// pointer data();; /// };; ///; /// template<typename T>; /// typename X<T>::pointer X<T>::data() { ... }; /// \endcode; ///; /// Here, the type ""typename X<T>::pointer"" will be created as a DependentNameType,; /// since we do not know that we can look into X<T> when we parsed the type.; /// This function will rebuild the type, performing the lookup of ""pointer""; /// in X<T> and returning an ElaboratedType whose canonical type is the same; /// as the canonical type of T*, allowing the return types of the out-of-line; /// definition and the declaration to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:936,Performance,perform,performing,936,"// end anonymous namespace; /// Rebuilds a type within the context of the current instantiation.; ///; /// The type \p T is part of the type of an out-of-line member definition of; /// a class template (or class template partial specialization) that was parsed; /// and constructed before we entered the scope of the class template (or; /// partial specialization thereof). This routine will rebuild that type now; /// that we have entered the declarator's scope, which may produce different; /// canonical types, e.g.,; ///; /// \code; /// template<typename T>; /// struct X {; /// typedef T* pointer;; /// pointer data();; /// };; ///; /// template<typename T>; /// typename X<T>::pointer X<T>::data() { ... }; /// \endcode; ///; /// Here, the type ""typename X<T>::pointer"" will be created as a DependentNameType,; /// since we do not know that we can look into X<T> when we parsed the type.; /// This function will rebuild the type, performing the lookup of ""pointer""; /// in X<T> and returning an ElaboratedType whose canonical type is the same; /// as the canonical type of T*, allowing the return types of the out-of-line; /// definition and the declaration to match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:57,Integrability,depend,dependent,57,"// C++17 [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains; // - an identifier associated by name lookup with a non-type; // template-parameter declared with a type that contains a; // placeholder type (7.1.7.4),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:18,Safety,avoid,avoid,18,// Take tokens to avoid allocations,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:105,Performance,perform,perform,105,"/// Within template argument deduction from a function call,; /// we are matching in a case where we can perform template argument; /// deduction from a template-id of a derived class of the argument type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:14,Integrability,depend,dependent,14,"/// Allow non-dependent types to differ, e.g., when performing; /// template argument deduction from a function call where conversions; /// may apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:52,Performance,perform,performing,52,"/// Allow non-dependent types to differ, e.g., when performing; /// template argument deduction from a function call where conversions; /// may apply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:19,Performance,perform,performing,19,/// Whether we are performing template argument deduction for; /// parameters and arguments in a top-level template argument,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:25,Modifiability,extend,extending,25,"/// Compare two APSInts, extending and switching the sign as; /// necessary to compare their values regardless of underlying type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:53,Integrability,depend,dependent,53,"// If we deduced a constant in one case and either a dependent expression or; // declaration in another case, keep the integral constant.; // If both are integral constants with the same value, keep that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:31,Integrability,depend,dependent,31,"// If we deduced a value and a dependent expression, keep the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:13,Integrability,depend,dependent,13,// Differing dependent expressions are incompatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:37,Integrability,depend,dependent,37,"// If we deduced a declaration and a dependent expression, keep the; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:38,Integrability,depend,dependent,38,"// If we deduced a null pointer and a dependent expression, keep the; // null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:59,Integrability,depend,dependent,59,"// Get the type of the parameter for deduction. If it's a (dependent) array; // or function type, we will not have decayed it yet, so do that now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:127,Performance,perform,performed,127,"// FIXME: It's not clear how deduction of a parameter of reference; // type from an argument (of non-reference type) should be performed.; // For now, we just remove reference types from both sides and let; // the final check for matching types sort out the mess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:19,Usability,clear,clear,19,"// FIXME: It's not clear how deduction of a parameter of reference; // type from an argument (of non-reference type) should be performed.; // For now, we just remove reference types from both sides and let; // the final check for matching types sort out the mess.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:97,Integrability,depend,dependent,97,"/// Deduce the value of the given non-type template parameter; /// from the given type- or value-dependent expression.; ///; /// \returns true if deduction succeeded, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:25,Integrability,depend,dependent,25,"// The parameter type is dependent and is not a template template parameter,; // so there is nothing that we can deduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:19,Integrability,depend,dependent,19,// Mismatch of non-dependent template parameter to argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:12,Integrability,inject,injected-class-name,12,// Treat an injected-class-name as its underlying template-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:12,Security,inject,injected-class-name,12,// Treat an injected-class-name as its underlying template-id.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,Integrability,depend,dependent,44,// Check whether the template argument is a dependent template-id.; // FIXME: Should not lose sugar here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction for the template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform template argument deduction on each template; // argument. Ignore any missing/extra arguments, since they could be; // filled in by default arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:67,Performance,perform,perform,67,"// If the argument type is a class template specialization, we; // perform template argument deduction using its template; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction for the template name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform template argument deduction for the template arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:27,Performance,perform,performing,27,/// A scope in which we're performing pack deduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:103,Usability,clear,clear,103,"// Save the deduced template argument for the parameter pack expanded; // by this pack expansion, then clear out the deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:431,Safety,avoid,avoid,431,"// We pre-populate the deduced value of the partially-substituted; // pack with the specified value. This is not entirely correct: the; // value is supposed to have been substituted, not deduced, but the; // cases where this is observable require an exact type match anyway.; //; // FIXME: If we could represent a ""depth i, index j, pack elem k""; // parameter, we could substitute the partially-substituted pack; // everywhere and avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:175,Usability,clear,clear,175,"// Capture the deduced template arguments for each parameter pack expanded; // by this pack expansion, add them to the list of arguments we've deduced; // for that pack, then clear out the deduced argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:410,Availability,error,errors,410,"// Always make sure the size of this pack is correct, even if we didn't; // deduce any values for it.; //; // FIXME: This isn't required by the normative wording, but substitution; // and post-substitution checking will always fail if the arity of any; // pack is not equal to the number of elements we processed. (Either that; // or something else has gone *very* wrong.) We're permitted to skip any; // hard errors from those follow-on steps by the intent (but not the; // wording) of C++ [temp.inst]p8:; //; // If the function selected by overload resolution can be determined; // without instantiating a class template definition, it is unspecified; // whether that instantiation actually takes place",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:835,Performance,perform,performed,835,"// namespace; /// Deduce the template arguments by comparing the list of parameter; /// types to the list of argument types, as in the parameter-type-lists of; /// function types (C++ [temp.deduct.type]p10).; ///; /// \param S The semantic analysis object within which we are deducing; ///; /// \param TemplateParams The template parameters that we are deducing; ///; /// \param Params The list of parameter types; ///; /// \param NumParams The number of types in \c Params; ///; /// \param Args The list of argument types; ///; /// \param NumArgs The number of types in \c Args; ///; /// \param Info information about the template argument deduction itself; ///; /// \param Deduced the deduced template arguments; ///; /// \param TDF bitwise OR of the TemplateDeductionFlags bits that describe; /// how template argument deduction is performed.; ///; /// \param PartialOrdering If true, we are performing template argument; /// deduction for during partial ordering for a call; /// (C++0x [temp.deduct.partial]).; ///; /// \returns the result of template argument deduction so far. Note that a; /// ""success"" result means that template argument deduction has not yet failed,; /// but it may still fail, later, for other reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:895,Performance,perform,performing,895,"// namespace; /// Deduce the template arguments by comparing the list of parameter; /// types to the list of argument types, as in the parameter-type-lists of; /// function types (C++ [temp.deduct.type]p10).; ///; /// \param S The semantic analysis object within which we are deducing; ///; /// \param TemplateParams The template parameters that we are deducing; ///; /// \param Params The list of parameter types; ///; /// \param NumParams The number of types in \c Params; ///; /// \param Args The list of argument types; ///; /// \param NumArgs The number of types in \c Args; ///; /// \param Info information about the template argument deduction itself; ///; /// \param Deduced the deduced template arguments; ///; /// \param TDF bitwise OR of the TemplateDeductionFlags bits that describe; /// how template argument deduction is performed.; ///; /// \param PartialOrdering If true, we are performing template argument; /// deduction for during partial ordering for a call; /// (C++0x [temp.deduct.partial]).; ///; /// \returns the result of template argument deduction so far. Note that a; /// ""success"" result means that template argument deduction has not yet failed,; /// but it may still fail, later, for other reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Usability,Simpl,Simple,3,// Simple case: compare the parameter and argument types at this point.; // Make sure we have an argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:202,Performance,perform,perform,202,"/// Compare types for equality with respect to possibly compatible; /// function types (noreturn adjustment, implicit calling conventions). If any; /// of parameter and argument is not a function, just perform type comparison.; ///; /// \param P the template parameter type.; ///; /// \param A the argument type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:277,Usability,guid,guide,277,/// Get the index of the first template parameter that was originally from the; /// innermost template-parameter-list. This is 0 except when we concatenate; /// the template parameter lists of a class template and a constructor template; /// when forming an implicit deduction guide.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:73,Usability,simpl,simple-template-id,73,"// C++14 [temp.deduct.call] p4b3:; // If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. Likewise if; // P is a pointer to a class of the form simple-template-id, the; // transformed A can be a pointer to a derived class pointed to by the; // deduced A. However, if there is a class C that is a (direct or; // indirect) base class of D and derived (directly or indirectly) from a; // class B and that would be a valid deduced A, the deduced A cannot be; // B or pointer to B, respectively.; //; // These alternatives are considered only if type deduction would; // otherwise fail. If they yield more than one possible deduced A, the; // type deduction fails.; // Use a breadth-first search through the bases to collect the set of; // successful matches. Visited contains the set of nodes we have already; // visited, while ToVisit is our stack of records that we still need to; // visit. Matches contains a list of matches that have yet to be; // disqualified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:215,Usability,simpl,simple-template-id,215,"// C++14 [temp.deduct.call] p4b3:; // If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. Likewise if; // P is a pointer to a class of the form simple-template-id, the; // transformed A can be a pointer to a derived class pointed to by the; // deduced A. However, if there is a class C that is a (direct or; // indirect) base class of D and derived (directly or indirectly) from a; // class B and that would be a valid deduced A, the deduced A cannot be; // B or pointer to B, respectively.; //; // These alternatives are considered only if type deduction would; // otherwise fail. If they yield more than one possible deduced A, the; // type deduction fails.; // Use a breadth-first search through the bases to collect the set of; // successful matches. Visited contains the set of nodes we have already; // visited, while ToVisit is our stack of records that we still need to; // visit. Matches contains a list of matches that have yet to be; // disqualified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:388,Modifiability,inherit,inherits,388,"// At this point, 'Matches' contains a list of seemingly valid bases, however; // in the event that we have more than 1 match, it is possible that the base; // of one of the matches might be disqualified for being a base of another; // valid match. We can count on cyclical instantiations being invalid to; // simplify the disqualifications. That is, if A & B are both matches, and B; // inherits from A (disqualifying A), we know that A cannot inherit from B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:445,Modifiability,inherit,inherit,445,"// At this point, 'Matches' contains a list of seemingly valid bases, however; // in the event that we have more than 1 match, it is possible that the base; // of one of the matches might be disqualified for being a base of another; // valid match. We can count on cyclical instantiations being invalid to; // simplify the disqualifications. That is, if A & B are both matches, and B; // inherits from A (disqualifying A), we know that A cannot inherit from B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:310,Usability,simpl,simplify,310,"// At this point, 'Matches' contains a list of seemingly valid bases, however; // in the event that we have more than 1 match, it is possible that the base; // of one of the matches might be disqualified for being a base of another; // valid match. We can count on cyclical instantiations being invalid to; // simplify the disqualifications. That is, if A & B are both matches, and B; // inherits from A (disqualifying A), we know that A cannot inherit from B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:102,Modifiability,inherit,inheritance,102,// We can give up once we have a single item (or have run out of things to; // search) since cyclical inheritance isn't valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:35,Modifiability,inherit,inheritance,35,"// Always add all bases, since the inheritance tree can contain; // disqualifications for multiple matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:604,Performance,perform,performed,604,"/// Deduce the template arguments by comparing the parameter type and; /// the argument type (C++ [temp.deduct.type]).; ///; /// \param S the semantic analysis object within which we are deducing; ///; /// \param TemplateParams the template parameters that we are deducing; ///; /// \param P the parameter type; ///; /// \param A the argument type; ///; /// \param Info information about the template argument deduction itself; ///; /// \param Deduced the deduced template arguments; ///; /// \param TDF bitwise OR of the TemplateDeductionFlags bits that describe; /// how template argument deduction is performed.; ///; /// \param PartialOrdering Whether we're performing template argument deduction; /// in the context of partial ordering (C++0x [temp.deduct.partial]).; ///; /// \returns the result of template argument deduction so far. Note that a; /// ""success"" result means that template argument deduction has not yet failed,; /// but it may still fail, later, for other reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:662,Performance,perform,performing,662,"/// Deduce the template arguments by comparing the parameter type and; /// the argument type (C++ [temp.deduct.type]).; ///; /// \param S the semantic analysis object within which we are deducing; ///; /// \param TemplateParams the template parameters that we are deducing; ///; /// \param P the parameter type; ///; /// \param A the argument type; ///; /// \param Info information about the template argument deduction itself; ///; /// \param Deduced the deduced template arguments; ///; /// \param TDF bitwise OR of the TemplateDeductionFlags bits that describe; /// how template argument deduction is performed.; ///; /// \param PartialOrdering Whether we're performing template argument deduction; /// in the context of partial ordering (C++0x [temp.deduct.partial]).; ///; /// \returns the result of template argument deduction so far. Note that a; /// ""success"" result means that template argument deduction has not yet failed,; /// but it may still fail, later, for other reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:107,Performance,perform,performed,107,"// C++11 [temp.deduct.partial]p5:; // Before the partial ordering is done, certain transformations are; // performed on the types used for partial ordering:; // - If P is a reference type, P is replaced by the type referred to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:826,Availability,failure,failure,826,"// C++11 [temp.deduct.partial]p9:; // If, for a given type, deduction succeeds in both directions (i.e.,; // the types are identical after the transformations above) and both; // P and A were reference types [...]:; // - if [one type] was an lvalue reference and [the other type] was; // not, [the other type] is not considered to be at least as; // specialized as [the first type]; // - if [one type] is more cv-qualified than [the other type],; // [the other type] is not considered to be at least as specialized; // as [the first type]; // Objective-C ARC adds:; // - [one type] has non-trivial lifetime, [the other type] has; // __unsafe_unretained lifetime, and the types are otherwise; // identical; //; // A is ""considered to be at least as specialized"" as P iff deduction; // succeeds, so we model this as a deduction failure. Note that; // [the first type] is P and [the other type] is A here; the standard; // gets this backwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:527,Usability,simpl,simply,527,"// C++0x [temp.deduct.type]p10:; // If P and A are function types that originated from deduction when; // taking the address of a function template (14.8.2.2) or when deducing; // template arguments from a function declaration (14.8.2.6) and Pi and; // Ai are parameters of the top-level parameter-type-list of P and A,; // respectively, Pi is adjusted if it is a forwarding reference and Ai; // is an lvalue reference, in; // which case the type of Pi is changed to be the template parameter; // type (i.e., T&& is changed to simply T). [ Note: As a result, when; // Pi is T&& and Ai is X&, the adjusted Pi will be T, causing T to be; // deduced as X&. - end note ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:60,Availability,failure,failure,60,// Set up the template argument deduction information for a failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:32,Integrability,depend,dependent,32,"// If the parameter type is not dependent, there is nothing to deduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:186,Integrability,depend,dependent,186,"// Otherwise, when ignoring qualifiers, the types not having the same; // unqualified type does not mean they do not match, so in this case we; // must keep going and analyze with a non-dependent parameter type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:10,Performance,perform,perform,10,// We can perform template argument deduction for the given non-type; // template parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:36,Integrability,depend,dependently-sized,36,// Incomplete type does not match a dependently-sized array type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:10,Safety,Detect,Detect,10,"// FIXME: Detect non-deduced exception specification mismatches?; //; // Careful about [temp.deduct.call] and [temp.deduct.conv], which allow; // top-level differences in noexcept-specifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:22,Integrability,inject,injected-class-name,22,// Treat a template's injected-class-name as if the template; // specialization type had been used.; // template-name<T> (where template-name refers to a class template); // template-name<i>; // TT<T>; // TT<i>; // TT<>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:22,Security,inject,injected-class-name,22,// Treat a template's injected-class-name as if the template; // specialization type had been used.; // template-name<T> (where template-name refers to a class template); // template-name<i>; // TT<T>; // TT<i>; // TT<>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:71,Integrability,depend,dependent,71,"// We can't check the number of elements, since the argument has a; // dependent number of elements. This can only occur during partial; // ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the vector size, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the vector size, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the vector size, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the vector size, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on element types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the address space, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction on the pointer types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,"// Perform deduction on the address space, if we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:49,Performance,perform,perform,49,"// If the template argument is a pack expansion, perform template argument; // deduction against the pattern of that expansion. This only occurs during; // partial ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:213,Availability,avail,available,213,"/// Determine whether there is a template argument to be used for; /// deduction.; ///; /// This routine ""expands"" argument packs in-place, overriding its input; /// parameters so that \c Args[ArgIdx] will be the available template argument.; ///; /// \returns true if there is another template argument (which will be at; /// \c Args[ArgIdx]), false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:97,Integrability,rout,routine,97,"/// Determine whether there is a template argument to be used for; /// deduction.; ///; /// This routine ""expands"" argument packs in-place, overriding its input; /// parameters so that \c Args[ArgIdx] will be the available template argument.; ///; /// \returns true if there is another template argument (which will be at; /// \c Args[ArgIdx]), false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:7,Usability,simpl,simple,7,// The simple case: deduce template arguments by matching Pi and Ai.; // Check whether we have enough arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Performance,Perform,Perform,3,// Perform deduction for this Pi/Ai pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:407,Availability,avail,available,407,"/// Allocate a TemplateArgumentLoc where all locations have; /// been initialized to the given location.; ///; /// \param Arg The template argument we are producing template argument; /// location information for.; ///; /// \param NTTPType For a declaration template argument, the type of; /// the non-type template parameter that corresponds to this template; /// argument. Can be null if no type sugar is available to add to the; /// type from the template argument.; ///; /// \param Loc The source location to use for the resulting template; /// argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a TemplateArgumentLoc where all locations have; /// been initialized to the given location.; ///; /// \param Arg The template argument we are producing template argument; /// location information for.; ///; /// \param NTTPType For a declaration template argument, the type of; /// the non-type template parameter that corresponds to this template; /// argument. Can be null if no type sugar is available to add to the; /// type from the template argument.; ///; /// \param Loc The source location to use for the resulting template; /// argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:200,Availability,avail,available,200,"// When converting the deduced template argument, append it to the; // general output list. We need to do this so that the template argument; // checking logic has all of the prior template arguments available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:154,Testability,log,logic,154,"// When converting the deduced template argument, append it to the; // general output list. We need to do this so that the template argument; // checking logic has all of the prior template arguments available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:124,Modifiability,extend,extended,124,// We may have had explicitly-specified template arguments for a; // template parameter pack (that may or may not have been extended; // via additional deduced arguments).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:54,Modifiability,extend,extended,54,// We still need to check the argument in case it was extended by; // deduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:53,Availability,avail,available,53,"// Substitute into the default template argument, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:105,Modifiability,variab,variable,105,"// getTemplateInstantiationArgs picks up the non-deduced version of the; // template args when this is a variable template partial specialization and; // not class-scope explicit specialization, so replace with Deduced Args; // instead of adding to inner-most.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:56,Modifiability,variab,variable,56,"/// Complete template argument deduction for a class or variable template,; /// when partial ordering against a partial specialization.; // FIXME: Factor out duplication with partial specialization version above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Performance,Perform,Perform,4,/// Perform template argument deduction to determine whether; /// the given template arguments match the given class template; /// partial specialization per C++ [temp.class.spec.match].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:77,Performance,perform,performing,77,// This deduction has no relation to any outer instantiation we might be; // performing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:111,Modifiability,variab,variable,111,/// Perform template argument deduction to determine whether; /// the given template arguments match the given variable template; /// partial specialization per C++ [temp.class.spec.match].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Performance,Perform,Perform,4,/// Perform template argument deduction to determine whether; /// the given template arguments match the given variable template; /// partial specialization per C++ [temp.class.spec.match].,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:77,Performance,perform,performing,77,// This deduction has no relation to any outer instantiation we might be; // performing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,Usability,simpl,simple-template-id,44,/// Determine whether the given type T is a simple-template-id type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:33,Integrability,inject,injected-class-name,33,"// C++17 [temp.local]p2:; // the injected-class-name [...] is equivalent to the template-name followed; // by the template-arguments of the class template specialization or partial; // specialization enclosed in <>; // ... which means it's equivalent to a simple-template-id.; //; // This only arises during class template argument deduction for a copy; // deduction candidate, where it permits slicing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:33,Security,inject,injected-class-name,33,"// C++17 [temp.local]p2:; // the injected-class-name [...] is equivalent to the template-name followed; // by the template-arguments of the class template specialization or partial; // specialization enclosed in <>; // ... which means it's equivalent to a simple-template-id.; //; // This only arises during class template argument deduction for a copy; // deduction candidate, where it permits slicing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:256,Usability,simpl,simple-template-id,256,"// C++17 [temp.local]p2:; // the injected-class-name [...] is equivalent to the template-name followed; // by the template-arguments of the class template specialization or partial; // specialization enclosed in <>; // ... which means it's equivalent to a simple-template-id.; //; // This only arises during class template argument deduction for a copy; // deduction candidate, where it permits slicing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:912,Availability,failure,failure,912,"/// Substitute the explicitly-provided template arguments into the; /// given function template according to C++ [temp.arg.explicit].; ///; /// \param FunctionTemplate the function template into which the explicit; /// template arguments will be substituted.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Deduced the deduced template arguments, which will be populated; /// with the converted and checked explicit template arguments.; ///; /// \param ParamTypes will be populated with the instantiated function; /// parameters.; ///; /// \param FunctionType if non-NULL, the result type of the function template; /// will also be instantiated and the pointed-to value will be updated with; /// the instantiated function type.; ///; /// \param Info if substitution fails for any reason, this object will be; /// populated with more information about the failure.; ///; /// \returns TDK_Success if substitution was successful, or some failure; /// condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:992,Availability,failure,failure,992,"/// Substitute the explicitly-provided template arguments into the; /// given function template according to C++ [temp.arg.explicit].; ///; /// \param FunctionTemplate the function template into which the explicit; /// template arguments will be substituted.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Deduced the deduced template arguments, which will be populated; /// with the converted and checked explicit template arguments.; ///; /// \param ParamTypes will be populated with the instantiated function; /// parameters.; ///; /// \param FunctionType if non-NULL, the result type of the function template; /// will also be instantiated and the pointed-to value will be updated with; /// the instantiated function type.; ///; /// \param Info if substitution fails for any reason, this object will be; /// populated with more information about the failure.; ///; /// \returns TDK_Success if substitution was successful, or some failure; /// condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:735,Deployability,update,updated,735,"/// Substitute the explicitly-provided template arguments into the; /// given function template according to C++ [temp.arg.explicit].; ///; /// \param FunctionTemplate the function template into which the explicit; /// template arguments will be substituted.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Deduced the deduced template arguments, which will be populated; /// with the converted and checked explicit template arguments.; ///; /// \param ParamTypes will be populated with the instantiated function; /// parameters.; ///; /// \param FunctionType if non-NULL, the result type of the function template; /// will also be instantiated and the pointed-to value will be updated with; /// the instantiated function type.; ///; /// \param Info if substitution fails for any reason, this object will be; /// populated with more information about the failure.; ///; /// \returns TDK_Success if substitution was successful, or some failure; /// condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:167,Deployability,update,update,167,"// Under Objective-C++ ARC, the deduced type may have implicitly; // been given strong or (when dealing with a const reference); // unsafe_unretained lifetime. If so, update the original; // qualifiers to include this lifetime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:118,Performance,perform,performed,118,"// Qualifiers are compatible, so have the argument type adopt the; // deduced argument type's qualifiers as if we had performed the; // qualification conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:40,Usability,simpl,simple-template-id,40,"// - If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. [...]; // [...] Likewise, if P is a pointer to a class of the form; // simple-template-id, the transformed A can be a pointer to a; // derived class pointed to by the deduced A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:199,Usability,simpl,simple-template-id,199,"// - If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. [...]; // [...] Likewise, if P is a pointer to a class of the form; // simple-template-id, the transformed A can be a pointer to a; // derived class pointed to by the deduced A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:106,Deployability,update,update,106,"// if `Specialization` is a `CXXConstructorDecl` or `CXXConversionDecl`,; // we'll try to instantiate and update its explicit specifier after constraint; // checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:422,Integrability,depend,dependent,422,"// C++ [temp.deduct.call]p10: [DR1391]; // If deduction succeeds for all parameters that contain; // template-parameters that participate in template argument deduction,; // and all template arguments are explicitly specified, deduced, or; // obtained from default template arguments, remaining parameters are then; // compared with the corresponding arguments. For each remaining parameter; // P with a type that was non-dependent before substitution of any; // explicitly-specified template arguments, if the corresponding argument; // A cannot be implicitly converted to P, deduction fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:87,Deployability,release,release,87,"// If the template argument list is owned by the function template; // specialization, release it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:26,Availability,error,error,26,// There may have been an error that did not prevent us from constructing a; // declaration. Mark the declaration invalid and return with a substitution; // failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:157,Availability,failure,failure,157,// There may have been an error that did not prevent us from constructing a; // declaration. Mark the declaration invalid and return with a substitution; // failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:133,Availability,failure,failure,133,// FIXME: This presumably means a pack ended up smaller than we; // expected while deducing. Should this not result in deduction; // failure? Can it even happen?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:42,Performance,perform,performing,42,"// If we suppressed any diagnostics while performing template argument; // deduction, and if we haven't already instantiated this declaration,; // keep track of these diagnostics. They'll be emitted if this specialization; // is actually used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Performance,Perform,Perform,4,/// Perform the adjustments to the parameter and argument types; /// described in C++ [temp.deduct.call].; ///; /// \returns true if the caller should not attempt to perform any template; /// argument deduction based on this P/A pair because the argument is an; /// overloaded function set that could not be resolved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:166,Performance,perform,perform,166,/// Perform the adjustments to the parameter and argument types; /// described in C++ [temp.deduct.call].; ///; /// \returns true if the caller should not attempt to perform any template; /// argument deduction based on this P/A pair because the argument is an; /// overloaded function set that could not be resolved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:40,Usability,simpl,simple-template-id,40,"// - If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. Likewise,; // if P is a pointer to a class of the form simple-template-id, the; // transformed A can be a pointer to a derived class pointed to by; // the deduced A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:183,Usability,simpl,simple-template-id,183,"// - If P is a class and P has the form simple-template-id, then the; // transformed A can be a derived class of the deduced A. Likewise,; // if P is a pointer to a class of the form simple-template-id, the; // transformed A can be a pointer to a derived class pointed to by; // the deduced A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:227,Performance,perform,performed,227,"// C++ [temp.deduct.call]p1: (CWG 1591); // If removing references and cv-qualifiers from P gives; // std::initializer_list<P0> or P0[N] for some P0 and N and the argument is; // a non-empty initializer list, then deduction is performed instead for; // each element of the initializer list, taking P0 as a function template; // parameter type and the initializer element as its argument; //; // We've already removed references and cv-qualifiers here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:39,Integrability,depend,dependent,39,// Deduction only needs to be done for dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:10,Performance,perform,perform,10,// We can perform template argument deduction for the given non-type; // template parameter.; // C++ [temp.deduct.type]p13:; // The type of N in the type T[N] is std::size_t.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Performance,Perform,Perform,4,/// Perform template argument deduction per [temp.deduct.call] for a; /// single parameter / argument pair.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:589,Deployability,update,updated,589,"/// Perform template argument deduction from a function call; /// (C++ [temp.deduct.call]).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicit template arguments provided; /// for this call.; ///; /// \param Args the function call arguments; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param CheckNonDependent A callback to invoke to check conversions for; /// non-dependent parameters, between deduction and substitution, per DR1391.; /// If this returns true, substitution will be skipped and we return; /// TDK_NonDependentConversionFailure. The callback is passed the parameter; /// types (after substituting explicit template arguments).; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:761,Integrability,depend,dependent,761,"/// Perform template argument deduction from a function call; /// (C++ [temp.deduct.call]).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicit template arguments provided; /// for this call.; ///; /// \param Args the function call arguments; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param CheckNonDependent A callback to invoke to check conversions for; /// non-dependent parameters, between deduction and substitution, per DR1391.; /// If this returns true, substitution will be skipped and we return; /// TDK_NonDependentConversionFailure. The callback is passed the parameter; /// types (after substituting explicit template arguments).; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Performance,Perform,Perform,4,"/// Perform template argument deduction from a function call; /// (C++ [temp.deduct.call]).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicit template arguments provided; /// for this call.; ///; /// \param Args the function call arguments; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param CheckNonDependent A callback to invoke to check conversions for; /// non-dependent parameters, between deduction and substitution, per DR1391.; /// If this returns true, substitution will be skipped and we return; /// TDK_NonDependentConversionFailure. The callback is passed the parameter; /// types (after substituting explicit template arguments).; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:165,Performance,perform,performing,165,"/// Perform template argument deduction from a function call; /// (C++ [temp.deduct.call]).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicit template arguments provided; /// for this call.; ///; /// \param Args the function call arguments; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param CheckNonDependent A callback to invoke to check conversions for; /// non-dependent parameters, between deduction and substitution, per DR1391.; /// If this returns true, substitution will be skipped and we return; /// TDK_NonDependentConversionFailure. The callback is passed the parameter; /// types (after substituting explicit template arguments).; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:50,Performance,perform,perform,50,// The types of the parameters from which we will perform template argument; // deduction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Usability,Simpl,Simple,3,// Simple case: matching a function parameter to a function argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:107,Security,access,accessibility,107,// Capture the context in which the function call is made. This is the context; // that is needed when the accessibility of template arguments is checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:899,Deployability,update,updated,899,"/// Deduce template arguments when taking the address of a function; /// template (C++ [temp.deduct.funcaddr]) or matching a specialization to; /// a template.; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param ArgFunctionType the function type that will be used as the; /// ""argument"" type (A) when performing template argument deduction from the; /// function template's function type. This type may be NULL, if there is no; /// argument type to compare against, in C++0x [temp.arg.explicit]p3.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template per [temp.deduct.funcaddr] and; /// [over.over]. If \c false, we are looking up a function template; /// specialization based on its signature, per [temp.deduct.decl].; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:233,Performance,perform,performing,233,"/// Deduce template arguments when taking the address of a function; /// template (C++ [temp.deduct.funcaddr]) or matching a specialization to; /// a template.; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param ArgFunctionType the function type that will be used as the; /// ""argument"" type (A) when performing template argument deduction from the; /// function template's function type. This type may be NULL, if there is no; /// argument type to compare against, in C++0x [temp.arg.explicit]p3.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template per [temp.deduct.funcaddr] and; /// [over.over]. If \c false, we are looking up a function template; /// specialization based on its signature, per [temp.deduct.decl].; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:472,Performance,perform,performing,472,"/// Deduce template arguments when taking the address of a function; /// template (C++ [temp.deduct.funcaddr]) or matching a specialization to; /// a template.; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param ArgFunctionType the function type that will be used as the; /// ""argument"" type (A) when performing template argument deduction from the; /// function template's function type. This type may be NULL, if there is no; /// argument type to compare against, in C++0x [temp.arg.explicit]p3.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template per [temp.deduct.funcaddr] and; /// [over.over]. If \c false, we are looking up a function template; /// specialization based on its signature, per [temp.deduct.decl].; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:66,Integrability,depend,dependent,66,"// If the function has a deduced return type, substitute it for a dependent; // type so that we treat it as a non-deduced context in what follows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:25,Integrability,depend,dependent,25,"// If the function has a dependent exception specification, resolve it now,; // so we can check that the exception specification matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:163,Integrability,depend,dependent,163,"// Adjust the exception specification of the argument to match the; // substituted and resolved type we just formed. (Calling convention and; // noreturn can't be dependent, so we don't actually need this for them; // right now.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:566,Deployability,update,updated,566,"/// Deduce template arguments for a function template when there is; /// nothing to deduce against (C++0x [temp.arg.explicit]p3).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template in a context where we do not have a; /// target type, per [over.over]. If \c false, we are looking up a function; /// template specialization based on its signature, which only happens when; /// deducing a function parameter type from an argument that is a template-id; /// naming a function template specialization.; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:203,Performance,perform,performing,203,"/// Deduce template arguments for a function template when there is; /// nothing to deduce against (C++0x [temp.arg.explicit]p3).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template in a context where we do not have a; /// target type, per [over.over]. If \c false, we are looking up a function; /// template specialization based on its signature, which only happens when; /// deducing a function parameter type from an argument that is a template-id; /// naming a function template specialization.; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:63,Integrability,wrap,wrap,63,"// If we're building the type pattern to deduce against, don't wrap the; // substituted type in an AutoType. Certain template deduction rules; // apply only when a template type parameter appears directly (and not if; // the parameter is found through desugaring). For instance:; // auto &&lref = lvalue;; // must transform into ""rvalue reference to T"" not ""rvalue reference to; // auto type deduced as T"" in order for [temp.deduct.call]p3 to apply.; //; // FIXME: Is this still necessary?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:583,Deployability,update,updated,583,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:133,Integrability,depend,dependent,133,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:231,Integrability,depend,dependent,231,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:284,Integrability,depend,dependent,284,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:677,Integrability,Depend,DependentDeduction,677,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:738,Integrability,depend,dependent,738,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:411,Modifiability,variab,variable,411,"/// Deduce the type for an auto type-specifier (C++11 [dcl.spec.auto]p6); ///; /// Note that this is done even if the initializer is dependent. (This is; /// necessary to support partial ordering of templates using 'auto'.); /// A dependent type will be produced when deducing from a dependent type.; ///; /// \param Type the type pattern using the auto type-specifier.; /// \param Init the initializer for the variable whose type is to be deduced.; /// \param Result if type deduction was successful, this will be set to the; /// deduced type.; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; /// \param DependentDeduction Set if we should permit deduction in; /// dependent cases. This is necessary for template partial ordering with; /// 'auto' template parameters. The template parameter depth to be used; /// should be specified in the 'Info' parameter.; /// \param IgnoreConstraints Set if we should not fail if the deduced type does; /// not satisfy the type-constraint in the auto type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:61,Integrability,depend,dependent,61,"// If deduction failed, don't diagnose if the initializer is dependent; it; // might acquire a matching type in the instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:79,Integrability,depend,depend,79,// C++0x [temp.deduct.partial]p3:; // The types used to determine the ordering depend on the context in which; // the partial ordering is done:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:710,Modifiability,extend,extended,710,"// C++11 [temp.func.order]p3:; // [...] If only one of the function templates is a non-static; // member, that function template is considered to have a new; // first parameter inserted in its function parameter list. The; // new parameter is of type ""reference to cv A,"" where cv are; // the cv-qualifiers of the function template (if any) and A is; // the class of which the function template is a member.; //; // Note that we interpret this to mean ""if one of the function; // templates is a non-static member and the other is a non-member"";; // otherwise, the ordering rules for static functions against non-static; // functions don't make any sense.; //; // C++98/03 doesn't have this provision but we've extended DR532 to cover; // it as wording was broken prior to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:291,Performance,perform,performing,291,"/// Returns the more specialized function template according; /// to the rules of function template partial ordering (C++ [temp.func.order]).; ///; /// \param FT1 the first function template; ///; /// \param FT2 the second function template; ///; /// \param TPOC the context in which we are performing partial ordering of; /// function templates.; ///; /// \param NumCallArguments1 The number of arguments in the call to FT1, used; /// only when \c TPOC is \c TPOC_Call.; ///; /// \param NumCallArguments2 The number of arguments in the call to FT2, used; /// only when \c TPOC is \c TPOC_Call.; ///; /// \param Reversed If \c true, exactly one of FT1 and FT2 is an overload; /// candidate with a reversed parameter order. In this case, the corresponding; /// P/A pairs between FT1 and FT2 are reversed.; ///; /// \returns the more specialized function template. If neither; /// template is more specialized, returns NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:13,Usability,clear,clear,13,// We have a clear winner,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:257,Integrability,inject,injected-class-name,257,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:335,Integrability,inject,injected-class-name,335,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:296,Modifiability,variab,variable,296,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:374,Modifiability,variab,variable,374,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:257,Security,inject,injected-class-name,257,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:335,Security,inject,injected-class-name,335,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:160,Modifiability,rewrite,rewrite,160,"// C++ [temp.class.order]p1:; // For two class template partial specializations, the first is at least as; // specialized as the second if, given the following rewrite to two; // function templates, the first function template is at least as; // specialized as the second according to the ordering rules for function; // templates (14.6.6.2):; // - the first function template has the same template parameters as the; // first partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the first partial specialization, and; // - the second function template has the same template parameters as the; // second partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the second partial specialization.; //; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template arguments of the class template partial; // specializations. This computation is slightly simpler than the; // general problem of function template partial ordering, because; // class template partial specializations are more constrained. We; // know that every template parameter is deducible from the class; // template partial specialization's template arguments, for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:935,Performance,perform,perform,935,"// C++ [temp.class.order]p1:; // For two class template partial specializations, the first is at least as; // specialized as the second if, given the following rewrite to two; // function templates, the first function template is at least as; // specialized as the second according to the ordering rules for function; // templates (14.6.6.2):; // - the first function template has the same template parameters as the; // first partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the first partial specialization, and; // - the second function template has the same template parameters as the; // second partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the second partial specialization.; //; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template arguments of the class template partial; // specializations. This computation is slightly simpler than the; // general problem of function template partial ordering, because; // class template partial specializations are more constrained. We; // know that every template parameter is deducible from the class; // template partial specialization's template arguments, for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:982,Performance,perform,performing,982,"// C++ [temp.class.order]p1:; // For two class template partial specializations, the first is at least as; // specialized as the second if, given the following rewrite to two; // function templates, the first function template is at least as; // specialized as the second according to the ordering rules for function; // templates (14.6.6.2):; // - the first function template has the same template parameters as the; // first partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the first partial specialization, and; // - the second function template has the same template parameters as the; // second partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the second partial specialization.; //; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template arguments of the class template partial; // specializations. This computation is slightly simpler than the; // general problem of function template partial ordering, because; // class template partial specializations are more constrained. We; // know that every template parameter is deducible from the class; // template partial specialization's template arguments, for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:1122,Usability,simpl,simpler,1122,"// C++ [temp.class.order]p1:; // For two class template partial specializations, the first is at least as; // specialized as the second if, given the following rewrite to two; // function templates, the first function template is at least as; // specialized as the second according to the ordering rules for function; // templates (14.6.6.2):; // - the first function template has the same template parameters as the; // first partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the first partial specialization, and; // - the second function template has the same template parameters as the; // second partial specialization and has a single function parameter; // whose type is a class template specialization with the template; // arguments of the second partial specialization.; //; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template arguments of the class template partial; // specializations. This computation is slightly simpler than the; // general problem of function template partial ordering, because; // class template partial specializations are more constrained. We; // know that every template parameter is deducible from the class; // template partial specialization's template arguments, for; // example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:54,Performance,perform,performing,54,"// A dummy class to return nullptr instead of P2 when performing ""more; // specialized than primary"" check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:128,Integrability,depend,dependent,128,"// We use profile, instead of structural comparison of the arguments,; // because canonicalization can't do the right thing for dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:128,Integrability,depend,dependent,128,"// We use profile, instead of structural comparison of the arguments,; // because canonicalization can't do the right thing for dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,Integrability,inject,injected,44,"// Unlike the specialization arguments, the injected arguments are not; // always canonical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,Security,inject,injected,44,"// Unlike the specialization arguments, the injected arguments are not; // always canonical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:13,Usability,clear,clear,13,// We have a clear winner,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:104,Integrability,inject,injected,104,// Pretend the variable template specializations are class template; // specializations and form a fake injected class name type for comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:15,Modifiability,variab,variable,15,// Pretend the variable template specializations are class template; // specializations and form a fake injected class name type for comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:104,Security,inject,injected,104,// Pretend the variable template specializations are class template; // specializations and form a fake injected class name type for comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:166,Modifiability,rewrite,rewrite,166,"// C++1z [temp.arg.template]p4: (DR 150); // A template template-parameter P is at least as specialized as a; // template template-argument A if, given the following rewrite to two; // function templates...; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template parameter lists of the template template parameters.; //; // Given an invented class template X with the template parameter list of; // A (including default arguments):",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:264,Performance,perform,perform,264,"// C++1z [temp.arg.template]p4: (DR 150); // A template template-parameter P is at least as specialized as a; // template template-argument A if, given the following rewrite to two; // function templates...; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template parameter lists of the template template parameters.; //; // Given an invented class template X with the template parameter list of; // A (including default arguments):",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:311,Performance,perform,performing,311,"// C++1z [temp.arg.template]p4: (DR 150); // A template template-parameter P is at least as specialized as a; // template template-argument A if, given the following rewrite to two; // function templates...; // Rather than synthesize function templates, we merely perform the; // equivalent partial ordering by performing deduction directly on; // the template parameter lists of the template template parameters.; //; // Given an invented class template X with the template parameter list of; // A (including default arguments):",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:45,Integrability,wrap,wrapped,45,"// Unwrap packs that getInjectedTemplateArgs wrapped around pack; // expansions, to form an ""as written"" argument list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:43,Modifiability,rewrite,rewrite,43,"// C++1z [temp.arg.template]p3:; // If the rewrite produces an invalid type, then P is not at least as; // specialized as A.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:7,Integrability,depend,dependent,7,// Non-dependent types have nothing deducible,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:33,Modifiability,variab,variable,33,// Add template arguments from a variable template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:11,Modifiability,variab,variable,11,"// If this variable template specialization was instantiated from a; // specialized member that is a variable template, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:101,Modifiability,variab,variable,101,"// If this variable template specialization was instantiated from a; // specialized member that is a variable template, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:90,Performance,perform,performing,90,"// If we have a template template parameter with translation unit context,; // then we're performing substitution into a default template argument of; // this template template parameter before we've constructed the template; // that will own this template template parameter. In this case, we; // use empty template parameter lists for all of the outer templates; // to avoid performing any substitutions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:377,Performance,perform,performing,377,"// If we have a template template parameter with translation unit context,; // then we're performing substitution into a default template argument of; // this template template parameter before we've constructed the template; // that will own this template template parameter. In this case, we; // use empty template parameter lists for all of the outer templates; // to avoid performing any substitutions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:371,Safety,avoid,avoid,371,"// If we have a template template parameter with translation unit context,; // then we're performing substitution into a default template argument of; // this template template parameter before we've constructed the template; // that will own this template template parameter. In this case, we; // use empty template parameter lists for all of the outer templates; // to avoid performing any substitutions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:48,Availability,error,error,48,"// Don't allow further instantiation if a fatal error and an uncompilable; // error have occurred. Any diagnostics we might have raised will not be; // visible, and we do not need to construct a correct AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:78,Availability,error,error,78,"// Don't allow further instantiation if a fatal error and an uncompilable; // error have occurred. Any diagnostics we might have raised will not be; // visible, and we do not need to construct a correct AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:81,Integrability,depend,depending,81,"// An instantiation of an alias template may or may not be a SFINAE; // context, depending on what else is on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:78,Performance,cache,cache,78,"// FIXME: This should not be treated as a SFINAE context, because; // we will cache an incorrect exception specification. However, clang; // bootstrap relies this! See PR31692.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:48,Usability,simpl,simply,48,// Whether to evaluate the C++20 constraints or simply substitute into them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:202,Integrability,depend,dependent,202,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// For the purposes of template instantiation, a type has already been; /// transformed if it is NULL or if it is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:110,Deployability,update,update,110,"// If we've instantiated the call operator of a lambda or the call; // operator template of a generic lambda, update the ""instantiation of""; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:91,Integrability,depend,dependent,91,"// We recreated a local declaration, but not by instantiating it. There; // may be pending dependent diagnostics to produce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:49,Performance,perform,performing,49,/// Transforms a template type parameter type by performing; /// substitution of the corresponding template type argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:63,Availability,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:135,Availability,down,downstream,135,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:81,Integrability,wrap,wraps,81,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:63,Safety,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:212,Availability,failure,failure,212,"// Currently, we instantiate the body when instantiating the lambda; // expression. However, `EvaluateConstraints` is disabled during the; // instantiation of the lambda expression, causing the instantiation; // failure of the return type requirement in the body. If p0588r1 is fully; // implemented, the body will be lazily instantiated, and this problem; // will not occur. Here, `EvaluateConstraints` is temporarily set to; // `true` to temporarily fix this issue.; // FIXME: This temporary fix can be removed after fully implementing; // p0588r1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:103,Integrability,depend,dependent,103,"// We recreate the RequiresExpr body, but not by instantiating it.; // Produce pending diagnostics for dependent access check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:113,Security,access,access,113,"// We recreate the RequiresExpr body, but not by instantiating it.; // Produce pending diagnostics for dependent access check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:91,Performance,perform,performing,91,"// If the corresponding template argument is NULL or non-existent, it's; // because we are performing instantiation from explicitly-specified; // template arguments in a function template, but there were some; // arguments left unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:117,Availability,down,down,117,"// If the first part of the nested-name-specifier was a template type; // parameter, instantiate that type parameter down to a tag type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:39,Security,access,access,39,// FIXME: This needs testing w/ member access expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:21,Testability,test,testing,21,// FIXME: This needs testing w/ member access expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:122,Availability,error,errors,122,// TODO: should we even warn on struct/class mismatches for this? Seems; // like it's likely to produce a lot of spurious errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:91,Performance,perform,performing,91,"// If the corresponding template argument is NULL or non-existent, it's; // because we are performing instantiation from explicitly-specified; // template arguments in a function template, but there were some; // arguments left unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:91,Performance,perform,performing,91,"// If the corresponding template argument is NULL or non-existent, it's; // because we are performing instantiation from explicitly-specified; // template arguments in a function template, but there were some; // arguments left unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:12,Availability,error,error,12,// Generate error if there is a problem with the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:37,Integrability,depend,dependent,37,"// The type may have been previously dependent and not now, which means we; // might have to implicit cast the argument to the new type, for example:; // template<auto T, decltype(T) U>; // concept C = sizeof(U) == 4;; // void foo() requires C<2, 'a'> { }; // When normalizing foo(), we first form the normalized constraints of C:; // AtomicExpr(sizeof(U) == 4,; // U=SubstNonTypeTemplateParmExpr(Param=U,; // Expr=DeclRef(U),; // Type=decltype(T))); // Then we substitute T = 2, U = 'a' into the parameter mapping, and need to; // produce:; // AtomicExpr(sizeof(U) == 4,; // U=SubstNonTypeTemplateParmExpr(Param=U,; // Expr=ImpCast(; // decltype(2),; // SubstNTTPE(Param=U, Expr='a',; // Type=char)),; // Type=decltype(2))); // The call to CheckTemplateArgument here produces the ImpCast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:178,Performance,perform,performing,178,"// Replace the template type parameter with its corresponding; // template argument.; // If the corresponding template argument is NULL or doesn't exist, it's; // because we are performing instantiation from explicitly-specified; // template arguments in a function template class, but there were some; // arguments left unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:234,Energy Efficiency,reduce,reduced,234,"// The template type parameter comes from an inner template (e.g.,; // the template parameter list of a member template inside the; // template we are instantiating). Create a new template type; // parameter with the template ""level"" reduced by one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:45,Availability,error,error,45,// Add a 'failed' Requirement to contain the error that caused the failure; // here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:67,Availability,failure,failure,67,// Add a 'failed' Requirement to contain the error that caused the failure; // here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:99,Integrability,rout,routine,99,"/// Perform substitution on the type T with a given set of template; /// arguments.; ///; /// This routine substitutes the given template arguments into the; /// type T and produces the instantiated type.; ///; /// \param T the type into which the template arguments will be; /// substituted. If this type is not dependent, it will be returned; /// immediately.; ///; /// \param Args the template arguments that will be; /// substituted for the top-level template parameters within T.; ///; /// \param Loc the location in the source code where this substitution; /// is being performed. It will typically be the location of the; /// declarator (if we're instantiating the type of some declaration); /// or the location of the type in the source code (if, e.g., we're; /// instantiating the type of a cast expression).; ///; /// \param Entity the name of the entity associated with a declaration; /// being instantiated (if any). May be empty to indicate that there; /// is no such entity (if, e.g., this is a type that occurs as part of; /// a cast expression) or that the entity has no name (e.g., an; /// unnamed function parameter).; ///; /// \param AllowDeducedTST Whether a DeducedTemplateSpecializationType is; /// acceptable as the top level type of the result.; ///; /// \returns If the instantiation succeeds, the instantiated; /// type. Otherwise, produces diagnostics and returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:313,Integrability,depend,dependent,313,"/// Perform substitution on the type T with a given set of template; /// arguments.; ///; /// This routine substitutes the given template arguments into the; /// type T and produces the instantiated type.; ///; /// \param T the type into which the template arguments will be; /// substituted. If this type is not dependent, it will be returned; /// immediately.; ///; /// \param Args the template arguments that will be; /// substituted for the top-level template parameters within T.; ///; /// \param Loc the location in the source code where this substitution; /// is being performed. It will typically be the location of the; /// declarator (if we're instantiating the type of some declaration); /// or the location of the type in the source code (if, e.g., we're; /// instantiating the type of a cast expression).; ///; /// \param Entity the name of the entity associated with a declaration; /// being instantiated (if any). May be empty to indicate that there; /// is no such entity (if, e.g., this is a type that occurs as part of; /// a cast expression) or that the entity has no name (e.g., an; /// unnamed function parameter).; ///; /// \param AllowDeducedTST Whether a DeducedTemplateSpecializationType is; /// acceptable as the top level type of the result.; ///; /// \returns If the instantiation succeeds, the instantiated; /// type. Otherwise, produces diagnostics and returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:4,Performance,Perform,Perform,4,"/// Perform substitution on the type T with a given set of template; /// arguments.; ///; /// This routine substitutes the given template arguments into the; /// type T and produces the instantiated type.; ///; /// \param T the type into which the template arguments will be; /// substituted. If this type is not dependent, it will be returned; /// immediately.; ///; /// \param Args the template arguments that will be; /// substituted for the top-level template parameters within T.; ///; /// \param Loc the location in the source code where this substitution; /// is being performed. It will typically be the location of the; /// declarator (if we're instantiating the type of some declaration); /// or the location of the type in the source code (if, e.g., we're; /// instantiating the type of a cast expression).; ///; /// \param Entity the name of the entity associated with a declaration; /// being instantiated (if any). May be empty to indicate that there; /// is no such entity (if, e.g., this is a type that occurs as part of; /// a cast expression) or that the entity has no name (e.g., an; /// unnamed function parameter).; ///; /// \param AllowDeducedTST Whether a DeducedTemplateSpecializationType is; /// acceptable as the top level type of the result.; ///; /// \returns If the instantiation succeeds, the instantiated; /// type. Otherwise, produces diagnostics and returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:576,Performance,perform,performed,576,"/// Perform substitution on the type T with a given set of template; /// arguments.; ///; /// This routine substitutes the given template arguments into the; /// type T and produces the instantiated type.; ///; /// \param T the type into which the template arguments will be; /// substituted. If this type is not dependent, it will be returned; /// immediately.; ///; /// \param Args the template arguments that will be; /// substituted for the top-level template parameters within T.; ///; /// \param Loc the location in the source code where this substitution; /// is being performed. It will typically be the location of the; /// declarator (if we're instantiating the type of some declaration); /// or the location of the type in the source code (if, e.g., we're; /// instantiating the type of a cast expression).; ///; /// \param Entity the name of the entity associated with a declaration; /// being instantiated (if any). May be empty to indicate that there; /// is no such entity (if, e.g., this is a type that occurs as part of; /// a cast expression) or that the entity has no name (e.g., an; /// unnamed function parameter).; ///; /// \param AllowDeducedTST Whether a DeducedTemplateSpecializationType is; /// acceptable as the top level type of the result.; ///; /// \returns If the instantiation succeeds, the instantiated; /// type. Otherwise, produces diagnostics and returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:17,Integrability,depend,dependent,17,"// If T is not a dependent type or a variably-modified type, there; // is nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:37,Modifiability,variab,variably-modified,37,"// If T is not a dependent type or a variably-modified type, there; // is nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:190,Safety,avoid,avoid,190,/// A form of SubstType intended specifically for instantiating the; /// type of a FunctionDecl. Its purpose is solely to force the; /// instantiation of default-argument expressions and to avoid; /// instantiating an exception-specification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:18,Availability,error,errors,18,"// When there are errors resolving types, clang may use IntTy as a fallback,; // breaking our assumption that function declarations have function types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:6,Availability,error,error,6,"// On error, recover by dropping the exception specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:13,Availability,recover,recover,13,"// On error, recover by dropping the exception specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:13,Safety,recover,recover,13,"// On error, recover by dropping the exception specification.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:132,Availability,avail,available,132,// Default arguments cannot be substituted until the declaration context; // for the associated function or lambda capture class is available.; // This is necessary for cases like the following where construction of; // the lambda capture class for the outer lambda is dependent on the; // parameter types but where the default argument is dependent on the; // outer lambda's declaration context.; // template <typename T>; // auto f() {; // return [](T = []{ return T{}; }()) { return 0; };; // },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:269,Integrability,depend,dependent,269,// Default arguments cannot be substituted until the declaration context; // for the associated function or lambda capture class is available.; // This is necessary for cases like the following where construction of; // the lambda capture class for the outer lambda is dependent on the; // parameter types but where the default argument is dependent on the; // outer lambda's declaration context.; // template <typename T>; // auto f() {; // return [](T = []{ return T{}; }()) { return 0; };; // },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:340,Integrability,depend,dependent,340,// Default arguments cannot be substituted until the declaration context; // for the associated function or lambda capture class is available.; // This is necessary for cases like the following where construction of; // the lambda capture class for the outer lambda is dependent on the; // parameter types but where the default argument is dependent on the; // outer lambda's declaration context.; // template <typename T>; // auto f() {; // return [](T = []{ return T{}; }()) { return 0; };; // },MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:155,Availability,error,error,155,"/// Perform substitution on the base class specifiers of the; /// given class template specialization.; ///; /// Produces a diagnostic and returns true on error, returns false and; /// attaches the instantiated base classes to the class template; /// specialization if successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:4,Performance,Perform,Perform,4,"/// Perform substitution on the base class specifiers of the; /// given class template specialization.; ///; /// Produces a diagnostic and returns true on error, returns false and; /// attaches the instantiated base classes to the class template; /// specialization if successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:889,Availability,error,error,889,"/// Instantiate the definition of a class from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; ///; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be either a class template specialization; /// or a member class of a class template specialization.; ///; /// \param Pattern is the pattern from which the instantiation; /// occurs. This will be either the declaration of a class template or; /// the declaration of a member class of a class template.; ///; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \param TSK the kind of implicit or explicit instantiation to perform.; ///; /// \param Complain whether to complain if the class cannot be instantiated due; /// to the lack of a definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:730,Performance,perform,perform,730,"/// Instantiate the definition of a class from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; ///; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be either a class template specialization; /// or a member class of a class template specialization.; ///; /// \param Pattern is the pattern from which the instantiation; /// occurs. This will be either the declaration of a class template or; /// the declaration of a member class of a class template.; ///; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \param TSK the kind of implicit or explicit instantiation to perform.; ///; /// \param Complain whether to complain if the class cannot be instantiated due; /// to the lack of a definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:15,Integrability,depend,dependent,15,// Perform any dependent diagnostics from the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Performance,Perform,Perform,3,// Perform any dependent diagnostics from the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:31,Modifiability,variab,variable,31,// Instantiate any out-of-line variable template partial; // specializations now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:76,Modifiability,polymorphi,polymorphic,76,"// Always emit the vtable for an explicit instantiation definition; // of a polymorphic class template specialization. Otherwise, eagerly; // instantiate only constexpr virtual functions in preparation for their use; // in constant evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:678,Availability,error,error,678,"/// Instantiate the definition of an enum from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a member enumeration of a class; /// temploid specialization, or a local enumeration within a; /// function temploid specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; /// \param TSK The kind of implicit or explicit instantiation to perform.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:637,Performance,perform,perform,637,"/// Instantiate the definition of an enum from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a member enumeration of a class; /// temploid specialization, or a local enumeration within a; /// function temploid specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; /// \param TSK The kind of implicit or explicit instantiation to perform.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:592,Availability,error,error,592,"/// Instantiate the definition of a field from the given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a class of a class temploid; /// specialization, or a local enumeration within a function temploid; /// specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Availability,Error,Error,3,// Error out if we haven't parsed the initializer of the pattern yet because; // we are waiting for the closing brace of the outer class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Availability,Error,Error,3,// Error out if we hit an instantiation cycle for this initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:38,Usability,clear,clear,38,// Partial ordering did not produce a clear winner. Complain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:3,Performance,Perform,Perform,3,// Perform the actual instantiation on the canonical declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:19,Integrability,inject,injected-class-name,19,"// Always skip the injected-class-name, along with any; // redeclarations of nested classes, since both would cause us; // to try to instantiate the members of a class twice.; // Skip closure types; they'll get instantiated when we instantiate; // the corresponding lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:19,Security,inject,injected-class-name,19,"// Always skip the injected-class-name, along with any; // redeclarations of nested classes, since both would cause us; // to try to instantiate the members of a class twice.; // Skip closure types; they'll get instantiated when we instantiate; // the corresponding lambda-expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:230,Modifiability,inherit,inherited,230,"// C++0x [temp.explicit]p7:; // An explicit instantiation that names a class template; // specialization is an explicit instantion of the same kind; // (declaration or definition) of each of its members (not; // including members inherited from base classes) that has not; // been previously explicitly specialized in the translation unit; // containing the explicit instantiation, except as described; // below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:12,Performance,perform,performing,12,"// If we're performing a partial substitution during template argument; // deduction, we may not have values for template parameters yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:82,Availability,error,error,82,// Enumeration types referenced prior to definition may appear as a result of; // error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:88,Availability,recover,recovery,88,// Enumeration types referenced prior to definition may appear as a result of; // error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:88,Safety,recover,recovery,88,// Enumeration types referenced prior to definition may appear as a result of; // error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:59,Usability,guid,guides,59,// Materialized typedefs/type alias for implicit deduction guides may require; // instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:170,Availability,error,error,170,// Do not treat 'std::forward' as a builtin if it takes an rvalue reference; // type and returns an lvalue reference type. The library implementation; // will produce an error in this case; don't get in its way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:4,Deployability,Update,Update,4,"/// Update instantiation attributes after template was late parsed.; ///; /// Some attributes are evaluated based on the body of template. If it is; /// late parsed, such attributes cannot be evaluated when declaration is; /// instantiated. This function is used to update instantiation attributes when; /// template definition is ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:266,Deployability,update,update,266,"/// Update instantiation attributes after template was late parsed.; ///; /// Some attributes are evaluated based on the body of template. If it is; /// late parsed, such attributes cannot be evaluated when declaration is; /// instantiated. This function is used to update instantiation attributes when; /// template definition is ready.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:33,Modifiability,variab,variables,33,"// In ARC, infer 'retaining' for variables of retainable type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:93,Integrability,depend,dependent,93,"// This is the last chance we have of checking copy elision eligibility; // for functions in dependent contexts. The sema actions for building; // the return statement during template instantiation will have no effect; // regarding copy elision, since NRVO propagation runs on the scope exit; // actions, and these are not run on instantiation.; // This might run through some VarDecls which were returned from non-taken; // 'if constexpr' branches, and these will end up being constructed on the; // return slot even if they will never be returned, as a sort of accidental; // 'optimization'. Notably, functions with 'auto' return types won't have it; // deduced by this point. Coupled with the limitation described; // previously, this makes it very hard to support copy elision for these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:579,Performance,optimiz,optimization,579,"// This is the last chance we have of checking copy elision eligibility; // for functions in dependent contexts. The sema actions for building; // the return statement during template instantiation will have no effect; // regarding copy elision, since NRVO propagation runs on the scope exit; // actions, and these are not run on instantiation.; // This might run through some VarDecls which were returned from non-taken; // 'if constexpr' branches, and these will end up being constructed on the; // return slot even if they will never be returned, as a sort of accidental; // 'optimization'. Notably, functions with 'auto' return types won't have it; // deduced by this point. Coupled with the limitation described; // previously, this makes it very hard to support copy elision for these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:91,Integrability,depend,dependent,91,"// C++ [temp.arg.type]p3:; // If a declaration acquires a function type through a type; // dependent on a template-parameter and this causes a; // declaration that does not use the syntactic form of a; // function declarator to have function type, the program is; // ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:91,Integrability,depend,dependent,91,"// C++ [temp.arg.type]p3:; // If a declaration acquires a function type through a type; // dependent on a template-parameter and this causes a; // declaration that does not use the syntactic form of a; // function declarator to have function type, the program is; // ill-formed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:37,Usability,simpl,simply,37,// Handle friend type expressions by simply substituting template; // parameters into the pattern type and checking the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:30,Testability,assert,assertion,30,// The expression in a static assertion is a constant expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:116,Performance,Perform,Perform,116,"// If we have type source information for the underlying type, it means it; // has been explicitly set by the user. Perform substitution on it before; // moving on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Deployability,Update,Update,3,// Update the location to refer to the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:22,Security,validat,validation,22,"// Do some additional validation, then merge default arguments; // from the existing declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Performance,Queue,Queue,3,// Queue up any out-of-line partial specializations of this member; // class template; the client will force their instantiation once; // the enclosing class has been instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:47,Modifiability,variab,variable,47,"// Create a local instantiation scope for this variable template, which; // will contain the instantiations of the template parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:71,Modifiability,variab,variable,71,// Queue up any out-of-line partial specializations of this member; // variable template; the client will force their instantiation once; // the enclosing class has been instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Performance,Queue,Queue,3,// Queue up any out-of-line partial specializations of this member; // variable template; the client will force their instantiation once; // the enclosing class has been instantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:24,Integrability,inject,injected-class-name,24,// Link the type of the injected-class-name to that of the outer class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:24,Security,inject,injected-class-name,24,// Link the type of the injected-class-name to that of the outer class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:150,Security,access,access,150,// FIXME: Check against AS_none is an ugly hack to work around the issue that; // the tag decls introduced by friend class declarations don't have an access; // specifier. Remove once this area of the code gets sorted out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:66,Modifiability,inherit,inherit,66,"// If the original function was part of a friend declaration,; // inherit its namespace state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:73,Performance,perform,performed,73,// This class may have local implicit instantiations that need to be; // performed within this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:260,Usability,guid,guide,260,/// Normal class members are of more specific types and therefore; /// don't make it here. This function serves three purposes:; /// 1) instantiating function templates; /// 2) substituting friend and local function declarations; /// 3) substituting deduction guide declarations for nested class templates,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:301,Deployability,update,updated,301,"// In abbreviated templates, the type-constraints of invented template; // type parameters are instantiated with the function type, invalidating; // the TemplateParameterList which relied on the template type parameter; // not having a type constraint. Recreate the TemplateParameterList with; // the updated parameter list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:277,Availability,error,error,277,"// Per [temp.inst], default arguments in function declarations at local scope; // are instantiated along with the enclosing declaration. For example:; //; // template<typename T>; // void ft() {; // void f(int = []{ return T::value; }());; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::' because it has no members; //; // The error is issued during instantiation of ft<int>() because substitution; // into the default argument fails; the default argument is instantiated even; // though it is never used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:366,Availability,error,error,366,"// Per [temp.inst], default arguments in function declarations at local scope; // are instantiated along with the enclosing declaration. For example:; //; // template<typename T>; // void ft() {; // void f(int = []{ return T::value; }());; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::' because it has no members; //; // The error is issued during instantiation of ft<int>() because substitution; // into the default argument fails; the default argument is instantiated even; // though it is never used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:63,Availability,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:135,Availability,down,downstream,135,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:81,Integrability,wrap,wraps,81,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:63,Safety,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:13,Usability,guid,guides,13,// deduction guides need this,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:301,Deployability,update,updated,301,"// In abbreviated templates, the type-constraints of invented template; // type parameters are instantiated with the function type, invalidating; // the TemplateParameterList which relied on the template type parameter; // not having a type constraint. Recreate the TemplateParameterList with; // the updated parameter list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:313,Availability,error,error,313,"// Per [temp.inst], default arguments in member functions of local classes; // are instantiated along with the member function declaration. For example:; //; // template<typename T>; // void ft() {; // struct lc {; // int operator()(int p = []{ return T::value; }());; // };; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::'because it has no members; //; // The error is issued during instantiation of ft<int>()::lc::operator(); // because substitution into the default argument fails; the default argument; // is instantiated even though it is never used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:401,Availability,error,error,401,"// Per [temp.inst], default arguments in member functions of local classes; // are instantiated along with the member function declaration. For example:; //; // template<typename T>; // void ft() {; // struct lc {; // int operator()(int p = []{ return T::value; }());; // };; // }; // template void ft<int>(); // error: type 'int' cannot be used prior; // to '::'because it has no members; //; // The error is issued during instantiation of ft<int>()::lc::operator(); // because substitution into the default argument fails; the default argument; // is instantiated even though it is never used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:63,Availability,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:135,Availability,down,downstream,135,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:81,Integrability,wrap,wraps,81,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:63,Safety,Recover,RecoveryExpr,63,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:13,Security,access,access,13,"// Propagate access. For a non-friend declaration, the access is; // whatever we're propagating from. For a friend, it should be the; // previous declaration we just found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:55,Security,access,access,55,"// Propagate access. For a non-friend declaration, the access is; // whatever we're propagating from. For a friend, it should be the; // previous declaration we just found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:381,Integrability,depend,depends,381,"// If the method is a special member function, we need to mark it as; // ineligible so that Owner->addDecl() won't mark the class as non trivial.; // At the end of the class instantiation, we calculate eligibility again and; // then we adjust trivility if needed.; // We need this check to happen only after the method parameters are set,; // because being e.g. a copy constructor depends on the instantiated; // arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:35,Security,access,access,35,"// do nothing; // Otherwise, check access to friends and make them visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:28,Security,access,access,28,// We only need to re-check access for methods which we didn't; // manage to match during parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Usability,Simpl,Simple,3,// Simple case: substitution into a parameter that is not a parameter pack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Performance,Perform,Perform,3,"// Perform the actual substitution of template parameters within a new,; // local instantiation scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:30,Integrability,depend,dependent,30,"// Using directives are never dependent (and never contain any types or; // expressions), so they require no explicit instantiation work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:36,Integrability,depend,dependent,36,"// The nested name specifier may be dependent, for example; // template <typename T> struct t {; // struct s1 { T f1(); };; // struct s2 : s1 { using s1::f1; };; // };; // template struct t<int>;; // Here, in using s1::f1, s1 refers to t<T>::s1;; // we need to substitute for t<int>::s1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:10,Modifiability,inherit,inheriting,10,"// For an inheriting constructor declaration, the name of the using; // declaration is the name of a constructor in this class, not in the; // base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:26,Integrability,depend,dependent,26,"// If the using scope was dependent, or we had dependent bases, we need to; // recheck the inheritance",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:47,Integrability,depend,dependent,47,"// If the using scope was dependent, or we had dependent bases, we need to; // recheck the inheritance",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:91,Modifiability,inherit,inheritance,91,"// If the using scope was dependent, or we had dependent bases, we need to; // recheck the inheritance",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:15,Integrability,depend,dependent,15,"// Cannot be a dependent type, but still could be an instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:93,Integrability,depend,dependent,93,"// We don't have to recheck for duplication of the UsingEnumDecl itself, as it; // cannot be dependent, and will therefore have been checked during template; // definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:26,Modifiability,variab,variable,26,// Instantiate the mapper variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:312,Availability,error,error,312,"// If PrevDecl was a definition and D is also a definition, diagnose.; // This happens in cases like:; //; // template<typename T, typename U>; // struct Outer {; // template<typename X> struct Inner;; // template<> struct Inner<T> {};; // template<> struct Inner<U> {};; // };; //; // Outer<int, int> outer; // error: the explicit specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:2,Deployability,Update,UpdateArgsWithConversions,2,/*UpdateArgsWithConversions=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Deployability,Update,Update,3,"// Update the return type in the source info too. The most straightforward; // way is to create new TypeSourceInfo for the new type. Use the location of; // the '= default' as the location of the new type.; //; // FIXME: Set the correct return type when we initially transform the type,; // rather than delaying it to now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:111,Security,access,access,111,// C++2a [class.compare.default]p3:; // an == operator function is declared implicitly [...] with the same; // access and function-definition and in the same class scope as the; // three-way comparison operator function,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:186,Availability,error,error,186,/// Instantiates a nested template parameter list in the current; /// instantiation context.; ///; /// \param L The parameter list to instantiate; ///; /// \returns NULL if there was an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:7,Availability,error,errors,7,// Get errors for all the parameters before bailing out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:25,Availability,error,error,25,// Clean up if we had an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:451,Availability,error,error,451,"/// Instantiate the declaration of a class template partial; /// specialization.; ///; /// \param ClassTemplate the (instantiated) class template that is partially; // specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) class template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:557,Availability,error,error,557,"// We've already seen a partial specialization with the same template; // parameters and template arguments. This can happen, for example, when; // substituting the outer template arguments ends up causing two; // class template partial specializations of a member class template; // to have identical forms, e.g.,; //; // template<typename T, typename U>; // struct Outer {; // template<typename X, typename Y> struct Inner;; // template<typename Y> struct Inner<T, Y>;; // template<typename Y> struct Inner<U, Y>;; // };; //; // Outer<int, int> outer; // error: the partial specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:459,Availability,error,error,459,"/// Instantiate the declaration of a variable template partial; /// specialization.; ///; /// \param VarTemplate the (instantiated) variable template that is partially; /// specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) variable template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:37,Modifiability,variab,variable,37,"/// Instantiate the declaration of a variable template partial; /// specialization.; ///; /// \param VarTemplate the (instantiated) variable template that is partially; /// specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) variable template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:132,Modifiability,variab,variable,132,"/// Instantiate the declaration of a variable template partial; /// specialization.; ///; /// \param VarTemplate the (instantiated) variable template that is partially; /// specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) variable template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:275,Modifiability,variab,variable,275,"/// Instantiate the declaration of a variable template partial; /// specialization.; ///; /// \param VarTemplate the (instantiated) variable template that is partially; /// specialized by the instantiation of \p PartialSpec.; ///; /// \param PartialSpec the (uninstantiated) variable template partial; /// specialization that we are instantiating.; ///; /// \returns The instantiated partial specialization, if successful; otherwise,; /// NULL to indicate an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:47,Modifiability,variab,variable,47,"// Create a local instantiation scope for this variable template partial; // specialization, which will contain the instantiations of the template; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:50,Modifiability,variab,variable,50,// Substitute into the template parameters of the variable template partial; // specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:49,Modifiability,variab,variable,49,// Substitute into the template arguments of the variable template partial; // specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:35,Modifiability,variab,variable,35,// Figure out where to insert this variable template partial specialization; // in the member template's set of variable template partial specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:112,Modifiability,variab,variable,112,// Figure out where to insert this variable template partial specialization; // in the member template's set of variable template partial specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:87,Modifiability,variab,variable,87,// Build the canonical type that describes the converted template; // arguments of the variable template partial specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:41,Modifiability,variab,variable,41,"// Build the fully-sugared type for this variable template; // specialization as the user wrote in the specialization; // itself. This means that we'll pretty-print the type retrieved; // from the specialization's declaration the way that the user; // actually wrote the specialization, rather than formatting the; // name based on the ""canonical"" representation used to store the; // template arguments in the specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:550,Availability,error,error,550,"// We've already seen a partial specialization with the same template; // parameters and template arguments. This can happen, for example, when; // substituting the outer template arguments ends up causing two; // variable template partial specializations of a member variable template; // to have identical forms, e.g.,; //; // template<typename T, typename U>; // struct Outer {; // template<typename X, typename Y> pair<X,Y> p;; // template<typename Y> pair<T, Y> p;; // template<typename Y> pair<U, Y> p;; // };; //; // Outer<int, int> outer; // error: the partial specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:214,Modifiability,variab,variable,214,"// We've already seen a partial specialization with the same template; // parameters and template arguments. This can happen, for example, when; // substituting the outer template arguments ends up causing two; // variable template partial specializations of a member variable template; // to have identical forms, e.g.,; //; // template<typename T, typename U>; // struct Outer {; // template<typename X, typename Y> pair<X,Y> p;; // template<typename Y> pair<T, Y> p;; // template<typename Y> pair<U, Y> p;; // };; //; // Outer<int, int> outer; // error: the partial specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:268,Modifiability,variab,variable,268,"// We've already seen a partial specialization with the same template; // parameters and template arguments. This can happen, for example, when; // substituting the outer template arguments ends up causing two; // variable template partial specializations of a member variable template; // to have identical forms, e.g.,; //; // template<typename T, typename U>; // struct Outer {; // template<typename X, typename Y> pair<X,Y> p;; // template<typename Y> pair<T, Y> p;; // template<typename Y> pair<U, Y> p;; // };; //; // Outer<int, int> outer; // error: the partial specializations of Inner; // // have the same signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:14,Modifiability,variab,variable,14,// Create the variable template partial specialization declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:49,Modifiability,variab,variable,49,// Add this partial specialization to the set of variable template partial; // specializations. The instantiation of the initializer is not necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:90,Integrability,depend,dependent,90,"// Simple case: normal parameter, or a parameter pack that's; // instantiated to a (still-dependent) parameter pack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Usability,Simpl,Simple,3,"// Simple case: normal parameter, or a parameter pack that's; // instantiated to a (still-dependent) parameter pack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:36,Integrability,depend,dependent,36,"// The function type itself was not dependent and therefore no; // substitution occurred. However, we still need to instantiate; // the function parameters themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:37,Modifiability,variab,variables,37,/// Introduce the instantiated local variables into the local; /// instantiation scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Usability,Simpl,Simple,3,// Simple case: not a parameter pack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:45,Deployability,update,update,45,"// If the parameter's type is not dependent, update it to match the type; // in the pattern. They can differ in top-level cv-qualifiers, and we want; // the pattern's type here. If the type is dependent, they can't differ,; // per core issue 1668. Substitute into the type from the pattern, in case; // it's instantiation-dependent.; // FIXME: Updating the type to work around this is at best fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:34,Integrability,depend,dependent,34,"// If the parameter's type is not dependent, update it to match the type; // in the pattern. They can differ in top-level cv-qualifiers, and we want; // the pattern's type here. If the type is dependent, they can't differ,; // per core issue 1668. Substitute into the type from the pattern, in case; // it's instantiation-dependent.; // FIXME: Updating the type to work around this is at best fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:193,Integrability,depend,dependent,193,"// If the parameter's type is not dependent, update it to match the type; // in the pattern. They can differ in top-level cv-qualifiers, and we want; // the pattern's type here. If the type is dependent, they can't differ,; // per core issue 1668. Substitute into the type from the pattern, in case; // it's instantiation-dependent.; // FIXME: Updating the type to work around this is at best fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:322,Integrability,depend,dependent,322,"// If the parameter's type is not dependent, update it to match the type; // in the pattern. They can differ in top-level cv-qualifiers, and we want; // the pattern's type here. If the type is dependent, they can't differ,; // per core issue 1668. Substitute into the type from the pattern, in case; // it's instantiation-dependent.; // FIXME: Updating the type to work around this is at best fragile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:41,Usability,Clear,Clear,41,// We hit the instantiation depth limit. Clear the exception specification; // so that our callers don't have to cope with EST_Uninstantiated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:43,Integrability,depend,depends,43,// This exception specification indirectly depends on itself. Reject.; // FIXME: Corresponding rule in the standard?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:180,Availability,error,error,180,/// Initializes the common fields of an instantiation function; /// declaration (New) from the corresponding fields of its template (Tmpl).; ///; /// \returns true if there was an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:530,Availability,error,errors,530,"// If we are performing substituting explicitly-specified template arguments; // or deduced template arguments into a function template and we reach this; // point, we are now past the point where SFINAE applies and have committed; // to keeping the new function template specialization. We therefore; // convert the active template instantiation for the function template; // into a template instantiation for this specific function template; // specialization, which is not a SFINAE context, so that we diagnose any; // further errors in the declaration itself.; //; // FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:13,Performance,perform,performing,13,"// If we are performing substituting explicitly-specified template arguments; // or deduced template arguments into a function template and we reach this; // point, we are now past the point where SFINAE applies and have committed; // to keeping the new function template specialization. We therefore; // convert the active template instantiation for the function template; // into a template instantiation for this specific function template; // specialization, which is not a SFINAE context, so that we diagnose any; // further errors in the declaration itself.; //; // FIXME: This is a hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:34,Modifiability,variab,variable,34,// Get the definition. Leaves the variable unchanged if undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:178,Availability,error,error,178,/// Initializes common fields of an instantiated method; /// declaration (New) from the corresponding fields of its template; /// (Tmpl).; ///; /// \returns true if there was an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:613,Performance,perform,performing,613,"/// Instantiate the definition of the given function from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the function, but it's close.; ///; /// \param Function the already-instantiated declaration of a; /// function template specialization or member function of a class template; /// specialization.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where the body of the function is required. Complain if; /// there is no such body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Performance,perform,performing,12,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate later,; // while we're still within our own instantiation context.; // This has to happen before LateTemplateParser below is called, so that; // it marks vtables used in late parsed templates as used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:76,Performance,queue,queue,76,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate later,; // while we're still within our own instantiation context.; // This has to happen before LateTemplateParser below is called, so that; // it marks vtables used in late parsed templates as used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize to allow individual templates to be deserialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:37,Modifiability,variab,variable,37,"// Introduce a new scope where local variable instantiations will be; // recorded, unless we're actually a member function within a local; // class, in which case we need to merge our results with the parent; // scope (of the enclosing function). The exception is instantiating; // a function template specialization, since the template to be; // instantiated already has references to locals properly substituted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:60,Availability,failure,failure,60,// Substitute into the qualifier; we can get a substitution failure here; // through evil use of alias templates.; // FIXME: Is CurContext correct for this? Should we go to the (instantiation; // of the) lexical context of the pattern?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:44,Modifiability,variab,variable,44,"// Instantiate the first declaration of the variable template: for a partial; // specialization of a static data member template, the first declaration may; // or may not be the declaration in the class; if it's in the class, we want; // to instantiate a member in the class (a declaration), and if it's outside,; // we want to instantiate a definition.; //; // If we're instantiating an explicitly-specialized member template or member; // partial specialization, don't do this. The member specialization completely; // replaces the original declaration in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:19,Modifiability,variab,variable,19,/// Instantiates a variable template specialization by completing it; /// with appropriate type information and initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Deployability,Update,Update,3,// Update the type of this variable template specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:27,Modifiability,variab,variable,27,// Update the type of this variable template specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:50,Modifiability,variab,variable,50,/// BuildVariableInstantiation - Used after a new variable has been created.; /// Sets basic variable data and decides whether to postpone the; /// variable instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:93,Modifiability,variab,variable,93,/// BuildVariableInstantiation - Used after a new variable has been created.; /// Sets basic variable data and decides whether to postpone the; /// variable instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:148,Modifiability,variab,variable,148,/// BuildVariableInstantiation - Used after a new variable has been created.; /// Sets basic variable data and decides whether to postpone the; /// variable instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:24,Modifiability,variab,variable,24,// Instantiating from a variable template (or partial specialization) to; // produce a variable template specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:87,Modifiability,variab,variable,87,// Instantiating from a variable template (or partial specialization) to; // produce a variable template specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:55,Modifiability,variab,variable,55,// We need the type to complete the declaration of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:46,Modifiability,variab,variable,46,// Delay instantiation of the initializer for variable template; // specializations or inline static data members until a definition of the; // variable is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:144,Modifiability,variab,variable,144,// Delay instantiation of the initializer for variable template; // specializations or inline static data members until a definition of the; // variable is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:40,Integrability,depend,dependent,40,"// Diagnose unused local variables with dependent types, where the diagnostic; // will have been deferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:25,Modifiability,variab,variables,25,"// Diagnose unused local variables with dependent types, where the diagnostic; // will have been deferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:37,Modifiability,variab,variable,37,/// Instantiate the initializer of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:102,Modifiability,variab,variable,102,"// We propagate the 'inline' flag with the initializer, because it; // would otherwise imply that the variable is a definition for a; // non-static data member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:43,Modifiability,variab,variables,43,// Do not dynamically initialize dllimport variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Modifiability,variab,variables,12,// `inline` variables are a definition and declaration all in one; we won't; // pick up an initializer from anywhere else.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:44,Modifiability,variab,variable,44,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:243,Modifiability,variab,variable,243,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:342,Modifiability,variab,variable,342,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:598,Modifiability,variab,variable,598,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:530,Performance,perform,performing,530,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:69,Availability,down,down,69,// FIXME: Factor out the duplicated instantiation context setup/tear down; // code here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Performance,perform,performing,12,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate; // later, while we're still within our own instantiation context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:76,Performance,queue,queue,76,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate; // later, while we're still within our own instantiation context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:8,Modifiability,variab,variable,8,// This variable may have local implicit instantiations that need to be; // instantiated within this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:40,Modifiability,variab,variable,40,"// If we don't have a definition of the variable template, we won't perform; // any instantiation. Rather, we rely on the user to instantiate this; // definition (or provide a specialization for it) in another translation; // unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:68,Performance,perform,perform,68,"// If we don't have a definition of the variable template, we won't perform; // any instantiation. Rather, we rely on the user to instantiate this; // definition (or provide a specialization for it) in another translation; // unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:68,Modifiability,variab,variables,68,"// C++11 [temp.explicit]p10:; // Except for inline functions, const variables of literal types, variables; // of reference types, [...] explicit instantiation declarations; // have the effect of suppressing the implicit instantiation of the entity; // to which they refer.; //; // FIXME: That's not exactly the same as ""might be usable in constant; // expressions"", which only allows constexpr variables and const integral; // types, not arbitrary const literal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:96,Modifiability,variab,variables,96,"// C++11 [temp.explicit]p10:; // Except for inline functions, const variables of literal types, variables; // of reference types, [...] explicit instantiation declarations; // have the effect of suppressing the implicit instantiation of the entity; // to which they refer.; //; // FIXME: That's not exactly the same as ""might be usable in constant; // expressions"", which only allows constexpr variables and const integral; // types, not arbitrary const literal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:394,Modifiability,variab,variables,394,"// C++11 [temp.explicit]p10:; // Except for inline functions, const variables of literal types, variables; // of reference types, [...] explicit instantiation declarations; // have the effect of suppressing the implicit instantiation of the entity; // to which they refer.; //; // FIXME: That's not exactly the same as ""might be usable in constant; // expressions"", which only allows constexpr variables and const integral; // types, not arbitrary const literal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:329,Usability,usab,usable,329,"// C++11 [temp.explicit]p10:; // Except for inline functions, const variables of literal types, variables; // of reference types, [...] explicit instantiation declarations; // have the effect of suppressing the implicit instantiation of the entity; // to which they refer.; //; // FIXME: That's not exactly the same as ""might be usable in constant; // expressions"", which only allows constexpr variables and const integral; // types, not arbitrary const literal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:38,Modifiability,variab,variable,38,// Make sure to pass the instantiated variable to the consumer at the end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Performance,perform,performing,12,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate later,; // while we're still within our own instantiation context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:76,Performance,queue,queue,76,"// If we're performing recursive template instantiation, create our own; // queue of pending implicit instantiations that we will instantiate later,; // while we're still within our own instantiation context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:25,Modifiability,variab,variable,25,// Complete the existing variable's definition with an appropriately; // substituted type and initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:8,Modifiability,variab,variable,8,// This variable may have local implicit instantiations that need to be; // instantiated within this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:140,Availability,error,error,140,/// Finds the instantiation of the given declaration context; /// within the current instantiation.; ///; /// \returns NULL if there was an error,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:43,Integrability,depend,dependent,43,"/// Determine whether the given context is dependent on template parameters at; /// level \p Level or below.; ///; /// Sometimes we only substitute an inner set of template arguments and leave; /// the outer templates alone. In such cases, contexts dependent only on the; /// outer levels are not effectively dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:249,Integrability,depend,dependent,249,"/// Determine whether the given context is dependent on template parameters at; /// level \p Level or below.; ///; /// Sometimes we only substitute an inner set of template arguments and leave; /// the outer templates alone. In such cases, contexts dependent only on the; /// outer levels are not effectively dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:309,Integrability,depend,dependent,309,"/// Determine whether the given context is dependent on template parameters at; /// level \p Level or below.; ///; /// Sometimes we only substitute an inner set of template arguments and leave; /// the outer templates alone. In such cases, contexts dependent only on the; /// outer levels are not effectively dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:106,Integrability,rout,routine,106,"/// Find the instantiation of the given declaration within the; /// current instantiation.; ///; /// This routine is intended to be used when \p D is a declaration; /// referenced from within a template, that needs to mapped into the; /// corresponding declaration within an instantiation. For example,; /// given:; ///; /// \code; /// template<typename T>; /// struct X {; /// enum Kind {; /// KnownValue = sizeof(T); /// };; ///; /// bool getKind() const { return KnownValue; }; /// };; ///; /// template struct X<int>;; /// \endcode; ///; /// In the instantiation of X<int>::getKind(), we need to map the \p; /// EnumConstantDecl for \p KnownValue (which refers to; /// X<T>::<Kind>::KnownValue) to its instantiation (X<int>::<Kind>::KnownValue).; /// \p FindInstantiatedDecl performs this mapping from within the instantiation; /// of X<int>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:779,Performance,perform,performs,779,"/// Find the instantiation of the given declaration within the; /// current instantiation.; ///; /// This routine is intended to be used when \p D is a declaration; /// referenced from within a template, that needs to mapped into the; /// corresponding declaration within an instantiation. For example,; /// given:; ///; /// \code; /// template<typename T>; /// struct X {; /// enum Kind {; /// KnownValue = sizeof(T); /// };; ///; /// bool getKind() const { return KnownValue; }; /// };; ///; /// template struct X<int>;; /// \endcode; ///; /// In the instantiation of X<int>::getKind(), we need to map the \p; /// EnumConstantDecl for \p KnownValue (which refers to; /// X<T>::<Kind>::KnownValue) to its instantiation (X<int>::<Kind>::KnownValue).; /// \p FindInstantiatedDecl performs this mapping from within the instantiation; /// of X<int>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:40,Integrability,depend,depends,40,// Determine whether our parent context depends on any of the template; // arguments we're currently substituting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:236,Integrability,Depend,Dependent,236,"// FIXME: Parameters of pointer to functions (y below) that are themselves; // parameters (p below) can have their ParentDC set to the translation-unit; // - thus we can not consistently check if the ParentDC of such a parameter; // is Dependent or/and a FunctionOrMethod.; // For e.g. this code, during Template argument deduction tries to; // find an instantiated decl for (T y) when the ParentDC for y is; // the translation unit.; // e.g. template <class T> void Foo(auto (*p)(T y) -> decltype(y())) {}; // float baz(float(*)()) { return 0.0; }; // Foo(baz);; // The better fix here is perhaps to ensure that a ParmVarDecl, by the time; // it gets here, always has a FunctionOrMethod as its ParentDC??; // For now:; // - as long as we have a ParmVarDecl whose parent is non-dependent and; // whose type is not instantiation dependent, do nothing to the decl; // - otherwise find its instantiated decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:778,Integrability,depend,dependent,778,"// FIXME: Parameters of pointer to functions (y below) that are themselves; // parameters (p below) can have their ParentDC set to the translation-unit; // - thus we can not consistently check if the ParentDC of such a parameter; // is Dependent or/and a FunctionOrMethod.; // For e.g. this code, during Template argument deduction tries to; // find an instantiated decl for (T y) when the ParentDC for y is; // the translation unit.; // e.g. template <class T> void Foo(auto (*p)(T y) -> decltype(y())) {}; // float baz(float(*)()) { return 0.0; }; // Foo(baz);; // The better fix here is perhaps to ensure that a ParmVarDecl, by the time; // it gets here, always has a FunctionOrMethod as its ParentDC??; // For now:; // - as long as we have a ParmVarDecl whose parent is non-dependent and; // whose type is not instantiation dependent, do nothing to the decl; // - otherwise find its instantiated decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:828,Integrability,depend,dependent,828,"// FIXME: Parameters of pointer to functions (y below) that are themselves; // parameters (p below) can have their ParentDC set to the translation-unit; // - thus we can not consistently check if the ParentDC of such a parameter; // is Dependent or/and a FunctionOrMethod.; // For e.g. this code, during Template argument deduction tries to; // find an instantiated decl for (T y) when the ParentDC for y is; // the translation unit.; // e.g. template <class T> void Foo(auto (*p)(T y) -> decltype(y())) {}; // float baz(float(*)()) { return 0.0; }; // Foo(baz);; // The better fix here is perhaps to ensure that a ParmVarDecl, by the time; // it gets here, always has a FunctionOrMethod as its ParentDC??; // For now:; // - as long as we have a ParmVarDecl whose parent is non-dependent and; // whose type is not instantiation dependent, do nothing to the decl; // - otherwise find its instantiated decl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Performance,perform,performing,12,"// If we're performing a partial substitution during template argument; // deduction, we may not have values for template parameters yet. They; // just map to themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:378,Availability,Error,Error,378,"// Normally this function only searches for already instantiated declaration; // however we have to make an exclusion for local types used before; // definition as in the code:; //; // template<typename T> void f1() {; // void g1(struct x1);; // struct x1 {};; // }; //; // In this case instantiation of the type of 'g1' requires definition of; // 'x1', which is defined later. Error recovery may produce an enum used; // before definition. In these cases we need to instantiate relevant; // declarations here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:384,Availability,recover,recovery,384,"// Normally this function only searches for already instantiated declaration; // however we have to make an exclusion for local types used before; // definition as in the code:; //; // template<typename T> void f1() {; // void g1(struct x1);; // struct x1 {};; // }; //; // In this case instantiation of the type of 'g1' requires definition of; // 'x1', which is defined later. Error recovery may produce an enum used; // before definition. In these cases we need to instantiate relevant; // declarations here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:384,Safety,recover,recovery,384,"// Normally this function only searches for already instantiated declaration; // however we have to make an exclusion for local types used before; // definition as in the code:; //; // template<typename T> void f1() {; // void g1(struct x1);; // struct x1 {};; // }; //; // In this case instantiation of the type of 'g1' requires definition of; // 'x1', which is defined later. Error recovery may produce an enum used; // before definition. In these cases we need to instantiate relevant; // declarations here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:12,Performance,perform,performing,12,"// If we're performing substitution while we're inside the template; // definition, we'll find our own context. We're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:25,Usability,guid,guide,25,// An implicit deduction guide acts as if it's within the class template; // specialization described by its name and first N template params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:35,Integrability,depend,dependent,35,"// Fall through to deal with other dependent record types (e.g.,; // anonymous unions in class templates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:212,Integrability,depend,dependent,212,"// We performed some kind of instantiation in the parent context,; // so now we need to look into the instantiated parent context to; // find the instantiation of the declaration D.; // If our context used to be dependent, we may need to instantiate; // it before performing lookup into that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:6,Performance,perform,performed,6,"// We performed some kind of instantiation in the parent context,; // so now we need to look into the instantiated parent context to; // find the instantiation of the declaration D.; // If our context used to be dependent, we may need to instantiate; // it before performing lookup into that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:264,Performance,perform,performing,264,"// We performed some kind of instantiation in the parent context,; // so now we need to look into the instantiated parent context to; // find the instantiation of the declaration D.; // If our context used to be dependent, we may need to instantiate; // it before performing lookup into that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:27,Integrability,depend,dependent,27,"// FIXME: If the name is a dependent name, this lookup won't necessarily; // find it. Does that ever matter?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:248,Integrability,depend,dependencies,248,"// The class in which this member exists is currently being; // instantiated, and we haven't gotten around to instantiating this; // member yet. This can happen when the code uses forward declarations; // of member classes, and introduces ordering dependencies via; // template instantiation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:4,Performance,Perform,Performs,4,/// Performs template instantiation for all implicit template; /// instantiations we have seen until this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:54,Availability,avail,available,54,// Definition of a PCH-ed template declaration may be available only in the TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:15,Modifiability,variab,variable,15,// Instantiate variable definitions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:49,Modifiability,variab,variable,49,// Instantiate static data member definitions or variable template; // specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:165,Integrability,depend,dependent,165,"// For now, the only problematic case is a generic lambda's templated; // call operator, so we don't need to look for all the other ways we; // could have reached a dependent parameter pack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:154,Integrability,rout,routine,154,"/// Record occurrences of template type parameter packs; /// when we don't have proper source-location information for; /// them.; ///; /// Ideally, this routine would never be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:480,Safety,detect,detect,480,"// Construct in lambda only references packs declared outside the lambda.; // That's OK for now, but the lambda itself is considered to contain an; // unexpanded pack in this case, which will require expansion outside the; // lambda.; // We do not permit pack expansion that would duplicate a statement; // expression, not even within a lambda.; // FIXME: We could probably support this for statement expressions that; // do not contain labels.; // FIXME: This is insufficient to detect this problem; consider; // f( ({ bad: 0; }) + pack ... );",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:231,Safety,avoid,avoid,231,"// CollectUnexpandedParameterPacksVisitor does not expect to see a; // FunctionParmPackExpr, but diagnosing unexpected parameter packs may still; // see such an expression in a lambda body.; // We'll bail out early in this case to avoid triggering an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:251,Testability,assert,assertion,251,"// CollectUnexpandedParameterPacksVisitor does not expect to see a; // FunctionParmPackExpr, but diagnosing unexpected parameter packs may still; // see such an expression in a lambda body.; // We'll bail out early in this case to avoid triggering an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:68,Modifiability,extend,extend,68,"// C++0x [temp.arg.explicit]p9:; // Template argument deduction can extend the sequence of template; // arguments corresponding to a template parameter pack, even when the; // sequence contains explicitly specified template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:12,Performance,perform,performing,12,"// If we're performing a partial expansion but we also have a full expansion,; // expand to the number of common arguments. For example, given:; //; // template<typename ...T> struct A {; // template<typename ...U> void f(pair<T, U>...);; // };; //; // ... a call to 'A<int, int>().f<int>' should expand the pack once and; // retain an expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:116,Safety,avoid,avoid,116,// We need to copy the TypeLoc because TemplateArgumentLocs store a; // TypeSourceInfo.; // FIXME: Find some way to avoid the copy?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:103,Availability,down,down,103,// LHS and RHS must be cast-expressions. We allow an arbitrary expression; // in the parser and reduce down to just cast-expressions here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:96,Energy Efficiency,reduce,reduce,96,// LHS and RHS must be cast-expressions. We allow an arbitrary expression; // in the parser and reduce down to just cast-expressions here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:3,Performance,Perform,Perform,3,// Perform first-phase name lookup now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:78,Availability,avail,available,78,"// objc_gc applies to Objective-C pointers or, otherwise, to the; // smallest available pointer type (i.e. 'void*' in 'void**').",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:74,Security,validat,validating,74,/// Flag to indicate we parsed a noderef attribute. This is used for; /// validating that noderef was used on a pointer or array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:119,Availability,redundant,redundant,119,"// If this occurs outside a template instantiation, warn the user about; // it; they probably didn't mean to specify a redundant qualifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:119,Safety,redund,redundant,119,"// If this occurs outside a template instantiation, warn the user about; // it; they probably didn't mean to specify a redundant qualifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:26,Modifiability,parameteriz,parameterized,26,// The class type must be parameterized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Integrability,Depend,Dependent,3,// Dependent types will be checked at instantiation time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,Integrability,protocol,protocol-list,11,// Form id<protocol-list>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,Integrability,protocol,protocol,11,// Fill in protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Integrability,Protocol,Protocol,3,// Protocol qualifier information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Integrability,Protocol,Protocol,3,// Protocol qualifier information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:26,Testability,log,logic,26,// FIXME: Should move the logic from DeclSpec::Finish to here for validity; // checking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:138,Availability,error,errors,138,"// When this occurs, often something is very broken with the value; // being declared, poison it as invalid so we don't get chains of; // errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:109,Safety,avoid,avoid,109,"// CUDA host and device may have different _Float16 support, therefore; // do not diagnose _Float16 usage to avoid false alarm.; // ToDo: more precise diagnostics for CUDA.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:493,Availability,error,error,493,"// For standard syntax attributes, which would normally appertain to the; // declaration here, suggest moving them to the type instead. But only; // do this for our own vendor attributes; moving other vendors'; // attributes might hurt portability.; // There's one special case that we need to deal with here: The; // `MatrixType` attribute may only be used in a typedef declaration. If; // it's being used anywhere else, don't output the warning as; // ProcessDeclAttributes() will output an error anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:236,Modifiability,portab,portability,236,"// For standard syntax attributes, which would normally appertain to the; // declaration here, suggest moving them to the type instead. But only; // do this for our own vendor attributes; moving other vendors'; // attributes might hurt portability.; // There's one special case that we need to deal with here: The; // `MatrixType` attribute may only be used in a typedef declaration. If; // it's being used anywhere else, don't output the warning as; // ProcessDeclAttributes() will output an error anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:22,Modifiability,variab,variable,22,"// For an __auto_type variable, we may not have seen the initializer yet; // and so have no idea whether the underlying type is a pointer type or; // not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:49,Safety,safe,safely,49,"// If the object type is const-qualified, we can safely use; // __unsafe_unretained. This is safe (because there are no read; // barriers), and it'll be safe to coerce anything but __weak* to; // the resulting type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:93,Safety,safe,safe,93,"// If the object type is const-qualified, we can safely use; // __unsafe_unretained. This is safe (because there are no read; // barriers), and it'll be safe to coerce anything but __weak* to; // the resulting type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:153,Safety,safe,safe,153,"// If the object type is const-qualified, we can safely use; // __unsafe_unretained. This is safe (because there are no read; // barriers), and it'll be safe to coerce anything but __weak* to; // the resulting type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:129,Integrability,protocol,protocol-qualifed,129,"// Otherwise, check whether the static type does not require; // retaining. This currently only triggers for Class (possibly; // protocol-qualifed, and arrays thereof).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:27,Availability,error,error,27,"// If that failed, give an error and recover using __strong. __strong; // is the option most likely to prevent spurious second-order diagnostics,; // like when binding a reference to a field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,Availability,recover,recover,37,"// If that failed, give an error and recover using __strong. __strong; // is the option most likely to prevent spurious second-order diagnostics,; // like when binding a reference to a field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,Safety,recover,recover,37,"// If that failed, give an error and recover using __strong. __strong; // is the option most likely to prevent spurious second-order diagnostics,; // like when binding a reference to a field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:96,Availability,error,error,96,"// These types can show up in private ivars in system headers, so; // we need this to not be an error in those cases. Instead we; // want to delay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:433,Availability,error,errors,433,"/// Build a pointer type.; ///; /// \param T The type to which we'll be building a pointer.; ///; /// \param Loc The location of the entity whose type involves this; /// pointer type or, if there is no such entity, the location of the; /// type that will have pointer type.; ///; /// \param Entity The name of the entity that involves the pointer; /// type, if known.; ///; /// \returns A suitable pointer type, if there are no; /// errors. Otherwise, returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:445,Availability,error,errors,445,"/// Build a reference type.; ///; /// \param T The type to which we'll be building a reference.; ///; /// \param Loc The location of the entity whose type involves this; /// reference type or, if there is no such entity, the location of the; /// type that will have reference type.; ///; /// \param Entity The name of the entity that involves the reference; /// type, if known.; ///; /// \returns A suitable reference type, if there are no; /// errors. Otherwise, returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:200,Availability,error,errors,200,"/// Build a Read-only Pipe type.; ///; /// \param T The type to which we'll be building a Pipe.; ///; /// \param Loc We do not use it for now.; ///; /// \returns A suitable pipe type, if there are no errors. Otherwise, returns a; /// NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:201,Availability,error,errors,201,"/// Build a Write-only Pipe type.; ///; /// \param T The type to which we'll be building a Pipe.; ///; /// \param Loc We do not use it for now.; ///; /// \returns A suitable pipe type, if there are no errors. Otherwise, returns a; /// NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:450,Availability,error,errors,450,"/// Build an array type.; ///; /// \param T The type of each element in the array.; ///; /// \param ASM C99 array size modifier (e.g., '*', 'static').; ///; /// \param ArraySize Expression describing the size of the array.; ///; /// \param Brackets The range from the opening '[' to the closing ']'.; ///; /// \param Entity The name of the entity that involves the array; /// type, if known.; ///; /// \returns A suitable array type, if there are no errors. Otherwise,; /// returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:82,Modifiability,inherit,inheritance,82,"// Mentioning a member pointer type for an array type causes us to lock in; // an inheritance model, even if it's inside an unused typedef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:202,Testability,assert,assertion,202,"// If the array size expression is a conditional expression whose branches; // are both integer constant expressions, one negative and one positive,; // then it's assumed to be like an old-style static assertion. e.g.,; // int old_style_assert[expr ? 1 : -1];; // We will accept any integer constant expressions instead of assuming the; // values 1 and -1 are always used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:65,Availability,error,error,65,"// VLAs always produce at least a -Wvla diagnostic, sometimes an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:23,Modifiability,variab,variable,23,// OpenCL v1.2 s6.9.d: variable length arrays are not supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:49,Energy Efficiency,power,power,49,// Only support _BitInt elements with byte-sized power of 2 NumBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:72,Modifiability,extend,extended,72,/// Build an ext-vector type.; ///; /// Run the required checks for the extended vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:49,Energy Efficiency,power,power,49,// Only support _BitInt elements with byte-sized power of 2 NumBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:36,Integrability,depend,dependent,36,"// Check element type, if it is not dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:25,Integrability,interface,interface,25,// Methods cannot return interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:14,Modifiability,extend,extended,14,/// Check the extended parameter information. Most of the necessary; /// checking should occur when applying the parameter attribute; the; /// only other checks required are positional restrictions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:409,Availability,error,error,409,"/// Build a member pointer type \c T Class::*.; ///; /// \param T the type to which the member pointer refers.; /// \param Class the class type into which the member pointer points.; /// \param Loc the location where this type begins; /// \param Entity the name of the entity that will have this member pointer type; ///; /// \returns a member pointer type, if successful, or a NULL type if there was; /// an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:339,Availability,error,errors,339,"/// Build a block pointer type.; ///; /// \param T The type to which we'll be building a block pointer.; ///; /// \param Loc The source location, used for diagnostics.; ///; /// \param Entity The name of the entity that involves the block pointer; /// type, if known.; ///; /// \returns A suitable block pointer type, if there are no; /// errors. Otherwise, returns a NULL type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:162,Testability,log,logic,162,// TODO: should we care about decl qualifiers?; // Check whether the declarator has the expected form. We walk; // from the inside out in order to make the block logic work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:29,Availability,redundant,redundant,29,// Build a string naming the redundant qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:29,Safety,redund,redundant,29,// Build a string naming the redundant qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:110,Availability,redundant,redundant,110,"// If the qualifiers come from a conversion function type, don't diagnose; // them -- they're not necessarily redundant, since such a conversion; // operator can be explicitly called as ""x.operator const int()"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:110,Safety,redund,redundant,110,"// If the qualifiers come from a conversion function type, don't diagnose; // them -- they're not necessarily redundant, since such a conversion; // operator can be explicitly called as ""x.operator const int()"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:13,Usability,guid,guides,13,// Deduction guides have a trailing return type and no type in their; // decl-specifier sequence. Use a placeholder return type for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Integrability,Interface,Interface,3,// Interface member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Integrability,Interface,Interface,3,/* Interface member */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:162,Usability,simpl,simple-declarations,162,"// FIXME: P0091R3 (erroneously) does not permit class template argument; // deduction in conditions, for-init-statements, and other declarations; // that are not simple-declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:27,Availability,error,error,27,// In Objective-C it is an error to use 'auto' on a function declarator; // (and everywhere for '__auto_type').,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:145,Modifiability,variab,variable,145,"// For a declaration with parameters, eg. ""T var(T());"", suggest adding; // parens around the first parameter to turn the declaration into a; // variable declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:141,Modifiability,variab,variable,141,"// For a declaration without parameters, eg. ""T var();"", suggest replacing; // the parens with an initializer to turn the declaration into a variable; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:91,Availability,error,error,91,// FIXME: Suppress the warning here if there is no initializer; we're; // going to give an error anyway.; // We assume that something like 'T (&x) = y;' is highly likely to not; // be intended to be a temporary object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:67,Availability,redundant,redundant-parens,67,"// FIXME: ""A(f())"" deserves a vexing-parse warning, not just a; // redundant-parens warning, but we don't know whether the function; // chunk was syntactically valid as an expression here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:67,Safety,redund,redundant-parens,67,"// FIXME: ""A(f())"" deserves a vexing-parse warning, not just a; // redundant-parens warning, but we don't know whether the function; // chunk was syntactically valid as an expression here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:101,Availability,failure,failure,101,// Ignore attributes that don't validate or can't apply to the; // function type. We'll diagnose the failure to apply them in; // handleFunctionTypeAttr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:32,Security,validat,validate,32,// Ignore attributes that don't validate or can't apply to the; // function type. We'll diagnose the failure to apply them in; // handleFunctionTypeAttr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:171,Usability,simpl,simplest,171,"// Attribute AT_OpenCLKernel affects the calling convention for SPIR; // and AMDGPU targets, hence it cannot be treated as a calling; // convention attribute. This is the simplest place to infer; // calling convention for OpenCL kernels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:6,Usability,simpl,simple,6,"/// A simple notion of pointer kinds, which matches up with the various; /// pointer declarators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:33,Integrability,wrap,wrapping,33,/// Describes a declarator chunk wrapping a pointer that marks inference as; /// unexpected.; // These values must be kept in sync with diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,Integrability,depend,dependent,11,"// For any dependent type, we consider it a non-pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,Testability,test,test,37,"// If we already know about CFError, test it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:65,Integrability,bridg,bridge,65,"// Check whether this is CFError, which we identify based on its bridge to; // NSError. CFErrorRef used to be declared with ""objc_bridge"" but is now; // declared with ""objc_bridge_mutable"", so look for either one of the two; // attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:70,Performance,perform,perform,70,"// If we're anywhere in a function, method, or closure context, don't perform; // completeness checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:20,Performance,perform,perform,20,// We don't want to perform completeness checks on the main file or in; // system headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:30,Performance,perform,performing,30,// Determine which file we're performing consistency checking for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:226,Testability,test,testing,226,"/// Returns true if any of the declarator chunks before \p endIndex include a; /// level of indirection: array, pointer, reference, or pointer-to-member.; ///; /// Because declarator chunks are stored in outer-to-inner order, testing; /// every chunk before \p endIndex is testing all chunks that embed the current; /// chunk as part of their type.; ///; /// It is legal to pass the result of Declarator::getNumTypeObjects() as the; /// end index, in which case all chunks are tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:273,Testability,test,testing,273,"/// Returns true if any of the declarator chunks before \p endIndex include a; /// level of indirection: array, pointer, reference, or pointer-to-member.; ///; /// Because declarator chunks are stored in outer-to-inner order, testing; /// every chunk before \p endIndex is testing all chunks that embed the current; /// chunk as part of their type.; ///; /// It is legal to pass the result of Declarator::getNumTypeObjects() as the; /// end index, in which case all chunks are tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:477,Testability,test,tested,477,"/// Returns true if any of the declarator chunks before \p endIndex include a; /// level of indirection: array, pointer, reference, or pointer-to-member.; ///; /// Because declarator chunks are stored in outer-to-inner order, testing; /// every chunk before \p endIndex is testing all chunks that embed the current; /// chunk as part of their type.; ///; /// It is legal to pass the result of Declarator::getNumTypeObjects() as the; /// end index, in which case all chunks are tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:93,Availability,error,error,93,"// The TypeSourceInfo that this function returns will not be a null type.; // If there is an error, this function will fill in a dummy type as fallback.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:55,Integrability,depend,dependent,55,// Note that we allow but don't require nullability on dependent types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:25,Integrability,depend,depends,25,// Nullability inference depends on the type and declarator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:93,Performance,perform,perform,93,"// If the type itself could have nullability but does not, infer pointer; // nullability and perform consistency checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:351,Availability,recover,recovers,351,"// Walk the DeclTypeInfo, building the recursive type as we go.; // DeclTypeInfos are ordered from the identifier out, which is; // opposite of what we want :).; // Track if the produced type matches the structure of the declarator.; // This is used later to decide if we can fill `TypeLoc` from; // `DeclaratorChunk`s. E.g. it must be false if Clang recovers from; // an error by replacing the type with `int`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:372,Availability,error,error,372,"// Walk the DeclTypeInfo, building the recursive type as we go.; // DeclTypeInfos are ordered from the identifier out, which is; // opposite of what we want :).; // Track if the produced type matches the structure of the declarator.; // This is used later to decide if we can fill `TypeLoc` from; // `DeclaratorChunk`s. E.g. it must be false if Clang recovers from; // an error by replacing the type with `int`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:351,Safety,recover,recovers,351,"// Walk the DeclTypeInfo, building the recursive type as we go.; // DeclTypeInfos are ordered from the identifier out, which is; // opposite of what we want :).; // Track if the produced type matches the structure of the declarator.; // This is used later to decide if we can fill `TypeLoc` from; // `DeclaratorChunk`s. E.g. it must be false if Clang recovers from; // an error by replacing the type with `int`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:35,Availability,error,error,35,"// If blocks are disabled, emit an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:32,Modifiability,variab,variable,32,"// OpenCL v2.0, s6.12.5 - Block variable declarations are implicitly; // qualified with const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:125,Safety,avoid,avoid,125,// Microsoft property fields can have multiple sizeless array chunks; // (i.e. int x[][][]). Skip all of these except one to avoid creating; // bad incomplete array types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:171,Deployability,patch,patches,171,"// FIXME: This check isn't quite right: it allows star in prototypes; // for function definitions, and disallows some edge cases detailed; // in http://gcc.gnu.org/ml/gcc-patches/2009-02/msg00133.html",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Availability,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Safety,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Availability,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Safety,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Availability,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Safety,recover,recover,10,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:6,Availability,error,error,6,// An error occurred parsing the trailing return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:132,Availability,error,error,132,"// C99 6.7.5.3p1: The return type may not be a function or array type.; // For conversion functions, we'll diagnose this particular error later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:25,Integrability,interface,interface,25,// Methods cannot return interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:103,Modifiability,variab,variable,103,"// If we see ""T var();"" or ""T var(T());"" at block scope, it is probably; // an attempt to initialize a variable, not a function declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Usability,Simpl,Simple,3,"// Simple void foo(), where the incoming T is the result type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Availability,Recover,Recover,3,"// Recover by creating a K&R-style function type, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Safety,Recover,Recover,3,"// Recover by creating a K&R-style function type, if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:57,Safety,avoid,avoid,57,// Take address space attr if any and mark as invalid to avoid adding; // them later while creating QualType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:47,Integrability,depend,dependent,47,"// The scope spec must refer to a class, or be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:24,Availability,error,errors,24,// Avoid emitting extra errors if we already errored on the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:45,Availability,error,errored,45,// Avoid emitting extra errors if we already errored on the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting extra errors if we already errored on the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:156,Integrability,wrap,wrap,156,"// Note: if the NNS has a prefix and ClsType is a nondependent; // TemplateSpecializationType, then the NNS prefix is NOT included; // in ClsType; hence we wrap ClsType into an ElaboratedType.; // NOTE: in particular, no wrap occurs if ClsType already is an; // Elaborated, DependentName, or DependentTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:221,Integrability,wrap,wrap,221,"// Note: if the NNS has a prefix and ClsType is a nondependent; // TemplateSpecializationType, then the NNS prefix is NOT included; // in ClsType; hence we wrap ClsType into an ElaboratedType.; // NOTE: in particular, no wrap occurs if ClsType already is an; // Elaborated, DependentName, or DependentTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:274,Integrability,Depend,DependentName,274,"// Note: if the NNS has a prefix and ClsType is a nondependent; // TemplateSpecializationType, then the NNS prefix is NOT included; // in ClsType; hence we wrap ClsType into an ElaboratedType.; // NOTE: in particular, no wrap occurs if ClsType already is an; // Elaborated, DependentName, or DependentTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:292,Integrability,Depend,DependentTemplateSpecialization,292,"// Note: if the NNS has a prefix and ClsType is a nondependent; // TemplateSpecializationType, then the NNS prefix is NOT included; // in ClsType; hence we wrap ClsType into an ElaboratedType.; // NOTE: in particular, no wrap occurs if ClsType already is an; // Elaborated, DependentName, or DependentTemplateSpecialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:227,Availability,error,error,227,"/// GetTypeForDeclarator - Convert the type for the specified; /// declarator to Type instances.; ///; /// The result of this call will never be null, but the associated; /// type may be a null type if there's an unrecoverable error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:160,Integrability,interface,interface,160,"// FIXME. We should have DS.getTypeSpecTypeEndLoc(). But, it requires; // addition field. What we have is good enough for display of location; // of 'fixit' on interface name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:51,Integrability,rout,routines,51,"// If we got no declarator info from previous Sema routines,; // just fill with the typespec loc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:57,Testability,assert,assert,57,// FIXME: add other typespec types and change this to an assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:61,Security,validat,validated,61,// C99 6.7.6: Type names have no identifier. This is already validated by; // the parser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:275,Availability,error,errors,275,//===----------------------------------------------------------------------===//; // Type Attribute Processing; //===----------------------------------------------------------------------===//; /// Build an AddressSpace index from a constant expression and diagnose any; /// errors related to invalid address_spaces. Returns true on successfully; /// building an AddressSpace index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:21,Integrability,Depend,DependentAddressSpaceTypes,21,// Default value for DependentAddressSpaceTypes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,Integrability,Depend,DependentAddressSpaceType,37,/// BuildAddressSpaceAttr - Builds a DependentAddressSpaceType if an expression; /// is uninstantiated. If instantiated it will apply the appropriate address; /// space to the type. This function allows dependent template variables to be; /// used in conjunction with the address_space attribute,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:203,Integrability,depend,dependent,203,/// BuildAddressSpaceAttr - Builds a DependentAddressSpaceType if an expression; /// is uninstantiated. If instantiated it will apply the appropriate address; /// space to the type. This function allows dependent template variables to be; /// used in conjunction with the address_space attribute,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:222,Modifiability,variab,variables,222,/// BuildAddressSpaceAttr - Builds a DependentAddressSpaceType if an expression; /// is uninstantiated. If instantiated it will apply the appropriate address; /// space to the type. This function allows dependent template variables to be; /// used in conjunction with the address_space attribute,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:106,Integrability,depend,dependent,106,"// A check with similar intentions as checking if a type already has an; // address space except for on a dependent types, basically if the; // current type is already a DependentAddressSpaceType then its already; // lined up to have another address space on it and we can't have; // multiple address spaces on the one pointer indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:170,Integrability,Depend,DependentAddressSpaceType,170,"// A check with similar intentions as checking if a type already has an; // address space except for on a dependent types, basically if the; // current type is already a DependentAddressSpaceType then its already; // lined up to have another address space on it and we can't have; // multiple address spaces on the one pointer indirection",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:34,Integrability,depend,dependent,34,"// If the expression is not value dependent (not templated), then we can; // apply the address space qualifiers just to the equivalent type.; // Otherwise, we make an AttributedType with the modified and equivalent; // type the same, and wrap it in a DependentAddressSpaceType. When this; // dependent type is resolved, the qualifier is added to the equivalent type; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:238,Integrability,wrap,wrap,238,"// If the expression is not value dependent (not templated), then we can; // apply the address space qualifiers just to the equivalent type.; // Otherwise, we make an AttributedType with the modified and equivalent; // type the same, and wrap it in a DependentAddressSpaceType. When this; // dependent type is resolved, the qualifier is added to the equivalent type; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:251,Integrability,Depend,DependentAddressSpaceType,251,"// If the expression is not value dependent (not templated), then we can; // apply the address space qualifiers just to the equivalent type.; // Otherwise, we make an AttributedType with the modified and equivalent; // type the same, and wrap it in a DependentAddressSpaceType. When this; // dependent type is resolved, the qualifier is added to the equivalent type; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:292,Integrability,depend,dependent,292,"// If the expression is not value dependent (not templated), then we can; // apply the address space qualifiers just to the equivalent type.; // Otherwise, we make an AttributedType with the modified and equivalent; // type the same, and wrap it in a DependentAddressSpaceType. When this; // dependent type is resolved, the qualifier is added to the equivalent type; // later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:13,Availability,redundant,redundant,13,// Check for redundant/conflicting ownership qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:13,Safety,redund,redundant,13,// Check for redundant/conflicting ownership qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:39,Availability,error,error,39,"// If it's written directly, that's an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:36,Availability,down,down,36,"/// A helper class to unwrap a type down to a function for the; /// purposes of applying attributes there.; ///; /// Use:; /// FunctionTypeUnwrapper unwrapped(SemaRef, T);; /// if (unwrapped.isFunctionType()) {; /// const FunctionType *fn = unwrapped.get();; /// // change fn somehow; /// T = unwrapped.wrap(fn);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:303,Integrability,wrap,wrap,303,"/// A helper class to unwrap a type down to a function for the; /// purposes of applying attributes there.; ///; /// Use:; /// FunctionTypeUnwrapper unwrapped(SemaRef, T);; /// if (unwrapped.isFunctionType()) {; /// const FunctionType *fn = unwrapped.get();; /// // change fn somehow; /// T = unwrapped.wrap(fn);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:2,Integrability,Wrap,WrapKind,2,/*WrapKind*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:17,Integrability,depend,dependent,17,// FIXME: Handle dependent types that aren't yet object types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:56,Availability,down,down,56,"// Rebuild the ""equivalent"" type, which pushes __kindof down into; // the object type.; // There is no need to apply kindof on an unqualified id type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:51,Testability,assert,asserted,51,"// If this is not a function type, warning will be asserted by subject; // check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Availability,Error,Error,3,// Error out on when there's already an attribute on the type; // and the CCs don't match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:26,Integrability,wrap,wrapped,26,"// Modify the CC from the wrapped function type, wrap it all back, and then; // wrap the whole thing in an AttributedType as written. The modified type; // might have a different CC if we ignored the attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:49,Integrability,wrap,wrap,49,"// Modify the CC from the wrapped function type, wrap it all back, and then; // wrap the whole thing in an AttributedType as written. The modified type; // might have a different CC if we ignored the attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:80,Integrability,wrap,wrap,80,"// Modify the CC from the wrapped function type, wrap it all back, and then; // wrap the whole thing in an AttributedType as written. The modified type; // might have a different CC if we ignored the attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:487,Integrability,rout,routine,487,"/// HandleVectorSizeAttribute - this attribute is only applicable to integral; /// and float scalars, although arrays, pointers, and function return values are; /// allowed in conjunction with this construct. Aggregates with this attribute; /// are invalid, even if they are of the same size as a corresponding scalar.; /// The raw attribute should contain precisely 1 argument, the vector size for; /// the variable, measured in bytes. If curType and rawAttr are well formed,; /// this routine will return a new vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:408,Modifiability,variab,variable,408,"/// HandleVectorSizeAttribute - this attribute is only applicable to integral; /// and float scalars, although arrays, pointers, and function return values are; /// allowed in conjunction with this construct. Aggregates with this attribute; /// are invalid, even if they are of the same size as a corresponding scalar.; /// The raw attribute should contain precisely 1 argument, the vector size for; /// the variable, measured in bytes. If curType and rawAttr are well formed,; /// this routine will return a new vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:18,Security,Access,Access,18,/// Handle OpenCL Access Qualifier Attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:22,Security,Access,Access,22,// OpenCL v2.0 s6.6 - Access qualifier can be used only for image and pipe type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:42,Integrability,depend,dependent,42,// Don't apply this attribute to template dependent types. It is applied on; // substitution during template instantiation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:167,Usability,simpl,simply,167,"// FIXME: `noderef` currently doesn't work correctly in [[]] syntax.; // See https://github.com/llvm/llvm-project/issues/55790 for details.; // For the time being, we simply emit a warning that the attribute is; // ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:127,Integrability,depend,dependent,127,"// Either add nullability here or try to distribute it. We; // don't want to distribute the nullability specifier past any; // dependent type, because that complicates the user model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:128,Testability,log,logic,128,"// Attributes with standard syntax have strict rules for what they; // appertain to and hence should not use the ""distribution"" logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Deployability,Update,Update,3,// Update the type to the definition's type both here and within the; // expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,Deployability,Update,Update,10,// FIXME: Update the type on all intervening expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:152,Modifiability,variab,variable,152,"// Incomplete array types may be completed by the initializer attached to; // their definitions. For static data members of class templates and for; // variable templates, we need to instantiate the definition to get this; // initializer and complete the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:77,Integrability,rout,routine,77,"/// Ensure that the type of the given expression is complete.; ///; /// This routine checks whether the expression \p E has a complete type. If the; /// expression refers to an instantiable construct, that instantiation is; /// performed as needed to complete its type. Furthermore; /// Sema::RequireCompleteType is called for the expression's type (or in the; /// case of a reference type, the referred-to type).; ///; /// \param E The expression whose type is required to be complete.; /// \param Kind Selects which completeness rules should be applied.; /// \param Diagnoser The object that will emit a diagnostic if the type is; /// incomplete.; ///; /// \returns \c true if the type of \p E is incomplete and diagnosed, \c false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:228,Performance,perform,performed,228,"/// Ensure that the type of the given expression is complete.; ///; /// This routine checks whether the expression \p E has a complete type. If the; /// expression refers to an instantiable construct, that instantiation is; /// performed as needed to complete its type. Furthermore; /// Sema::RequireCompleteType is called for the expression's type (or in the; /// case of a reference type, the referred-to type).; ///; /// \param E The expression whose type is required to be complete.; /// \param Kind Selects which completeness rules should be applied.; /// \param Diagnoser The object that will emit a diagnostic if the type is; /// incomplete.; ///; /// \returns \c true if the type of \p E is incomplete and diagnosed, \c false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:62,Integrability,rout,routine,62,"/// Ensure that the type T is a complete type.; ///; /// This routine checks whether the type @p T is complete in any; /// context where a complete type is required. If @p T is a complete; /// type, returns false. If @p T is a class template specialization,; /// this routine then attempts to perform class template; /// instantiation. If instantiation fails, or if @p T is incomplete; /// and cannot be completed, issues the diagnostic @p diag (giving it; /// the type @p T) and returns true.; ///; /// @param Loc The location in the source that the incomplete type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for completeness.; ///; /// @param Kind Selects which completeness rules should be applied.; ///; /// @returns @c true if @p T is incomplete and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:268,Integrability,rout,routine,268,"/// Ensure that the type T is a complete type.; ///; /// This routine checks whether the type @p T is complete in any; /// context where a complete type is required. If @p T is a complete; /// type, returns false. If @p T is a class template specialization,; /// this routine then attempts to perform class template; /// instantiation. If instantiation fails, or if @p T is incomplete; /// and cannot be completed, issues the diagnostic @p diag (giving it; /// the type @p T) and returns true.; ///; /// @param Loc The location in the source that the incomplete type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for completeness.; ///; /// @param Kind Selects which completeness rules should be applied.; ///; /// @returns @c true if @p T is incomplete and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:638,Integrability,rout,routine,638,"/// Ensure that the type T is a complete type.; ///; /// This routine checks whether the type @p T is complete in any; /// context where a complete type is required. If @p T is a complete; /// type, returns false. If @p T is a class template specialization,; /// this routine then attempts to perform class template; /// instantiation. If instantiation fails, or if @p T is incomplete; /// and cannot be completed, issues the diagnostic @p diag (giving it; /// the type @p T) and returns true.; ///; /// @param Loc The location in the source that the incomplete type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for completeness.; ///; /// @param Kind Selects which completeness rules should be applied.; ///; /// @returns @c true if @p T is incomplete and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:293,Performance,perform,perform,293,"/// Ensure that the type T is a complete type.; ///; /// This routine checks whether the type @p T is complete in any; /// context where a complete type is required. If @p T is a complete; /// type, returns false. If @p T is a class template specialization,; /// this routine then attempts to perform class template; /// instantiation. If instantiation fails, or if @p T is incomplete; /// and cannot be completed, issues the diagnostic @p diag (giving it; /// the type @p T) and returns true.; ///; /// @param Loc The location in the source that the incomplete type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for completeness.; ///; /// @param Kind Selects which completeness rules should be applied.; ///; /// @returns @c true if @p T is incomplete and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:2,Availability,Error,ErrorOnTagTypeMismatch,2,/*ErrorOnTagTypeMismatch*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Performance,Cache,Cache,3,// Cache the fact that this definition is implicitly visible because; // there is a visible merged definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:17,Modifiability,inherit,inheritance,17,/// Locks in the inheritance model for the given class and all of its bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:235,Integrability,depend,dependent,235,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:260,Integrability,depend,dependent,260,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:348,Integrability,depend,dependent,348,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:19,Testability,assert,assertion,19,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:82,Testability,assert,assert,82,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:173,Testability,assert,assertion,173,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:291,Testability,assert,assert,291,"// FIXME: Add this assertion to make sure we always get instantiation points.; // assert(!Loc.isInvalid() && ""Invalid location in RequireCompleteType"");; // FIXME: Add this assertion to help us flush out problems with; // checking for dependent types and type-dependent expressions.; //; // assert(!T->isDependentType() &&; // ""Can't ask whether a dependent type is complete"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:18,Modifiability,inherit,inheritance,18,// We lock in the inheritance model once somebody has asked us to ensure; // that a pointer-to-member type is complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:34,Availability,error,error,34,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:46,Availability,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:46,Safety,recover,recover,46,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:2,Availability,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:2,Safety,Recover,Recover,2,/*Recover*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:186,Safety,avoid,avoid,186,// Give the external source a chance to provide a definition of the type.; // This is kept separate from completing the redeclaration chain so that; // external sources such as LLDB can avoid synthesizing a type definition; // unless it's actually needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Safety,Avoid,Avoid,3,// Avoid diagnosing invalid decls as incomplete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:30,Integrability,depend,dependent,30,"// Don't try to instantiate a dependent class (eg, a member template of; // an instantiated class template specialization).; // FIXME: Can this ever happen?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:98,Availability,error,error,98,"// If we instantiated a definition, check that it's usable, even if; // instantiation produced an error, so that repeated calls to this; // function give consistent answers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:52,Usability,usab,usable,52,"// If we instantiated a definition, check that it's usable, even if; // instantiation produced an error, so that repeated calls to this; // function give consistent answers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:79,Integrability,message,message,79,/// Get diagnostic %select index for tag kind for; /// literal type diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:61,Integrability,rout,routine,61,"/// Ensure that the type T is a literal type.; ///; /// This routine checks whether the type @p T is a literal type. If @p T is an; /// incomplete type, an attempt is made to complete it. If @p T is a literal; /// type, or @p AllowIncompleteType is true and @p T is an incomplete type,; /// returns false. Otherwise, this routine issues the diagnostic @p PD (giving; /// it the type @p T), along with notes explaining why the type is not a; /// literal type, and returns true.; ///; /// @param Loc The location in the source that the non-literal type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for literalness.; ///; /// @param Diagnoser Emits a diagnostic if T is not a literal type.; ///; /// @returns @c true if @p T is not a literal type and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:322,Integrability,rout,routine,322,"/// Ensure that the type T is a literal type.; ///; /// This routine checks whether the type @p T is a literal type. If @p T is an; /// incomplete type, an attempt is made to complete it. If @p T is a literal; /// type, or @p AllowIncompleteType is true and @p T is an incomplete type,; /// returns false. Otherwise, this routine issues the diagnostic @p PD (giving; /// it the type @p T), along with notes explaining why the type is not a; /// literal type, and returns true.; ///; /// @param Loc The location in the source that the non-literal type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for literalness.; ///; /// @param Diagnoser Emits a diagnostic if T is not a literal type.; ///; /// @returns @c true if @p T is not a literal type and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:622,Integrability,rout,routine,622,"/// Ensure that the type T is a literal type.; ///; /// This routine checks whether the type @p T is a literal type. If @p T is an; /// incomplete type, an attempt is made to complete it. If @p T is a literal; /// type, or @p AllowIncompleteType is true and @p T is an incomplete type,; /// returns false. Otherwise, this routine issues the diagnostic @p PD (giving; /// it the type @p T), along with notes explaining why the type is not a; /// literal type, and returns true.; ///; /// @param Loc The location in the source that the non-literal type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for literalness.; ///; /// @param Diagnoser Emits a diagnostic if T is not a literal type.; ///; /// @returns @c true if @p T is not a literal type and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:138,Usability,simpl,simple,138,"/// getDecltypeForExpr - Given an expr, will return the decltype for; /// that expression, according to the rules in C++11; /// [dcl.type.simple]p4 and C++11 [expr.lambda.prim]p18.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:256,Performance,perform,performing,256,"// C++11 [dcl.type.simple]p4:; // The type denoted by decltype(e) is defined as follows:; // C++20:; // - if E is an unparenthesized id-expression naming a non-type; // template-parameter (13.2), decltype(E) is the type of the; // template-parameter after performing any necessary type deduction; // Note that this does not pick up the implicit 'const' for a template; // parameter object. This rule makes no difference before C++20 so we apply; // it unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:19,Usability,simpl,simple,19,"// C++11 [dcl.type.simple]p4:; // The type denoted by decltype(e) is defined as follows:; // C++20:; // - if E is an unparenthesized id-expression naming a non-type; // template-parameter (13.2), decltype(E) is the type of the; // template-parameter after performing any necessary type deduction; // Note that this does not pick up the implicit 'const' for a template; // parameter object. This rule makes no difference before C++20 so we apply; // it unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:85,Security,access,access,85,"// - if e is an unparenthesized id-expression or an unparenthesized class; // member access (5.2.5), decltype(e) is the type of the entity named; // by e. If there is no such entity, or if e names a set of overloaded; // functions, the program is ill-formed;; //; // We apply the same rules for Objective-C ivar and property references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:227,Security,access,access,227,// C++11 [expr.lambda.prim]p18:; // Every occurrence of decltype((x)) where x is a possibly; // parenthesized id-expression that names an entity of automatic; // storage duration is treated as if x were transformed into an; // access to a corresponding data member of the closure type that; // would have been declared if x were an odr-use of the denoted; // entity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:167,Integrability,depend,dependent,167,"// The expression operand for decltype is in an unevaluated expression; // context, so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'decltype' is often; // used to build SFINAE gadgets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:71,Availability,recover,recovering,71,// The enum could be incomplete if we're parsing its definition or; // recovering from an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:90,Availability,error,error,90,// The enum could be incomplete if we're parsing its definition or; // recovering from an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:71,Safety,recover,recovering,71,// The enum could be incomplete if we're parsing its definition or; // recovering from an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:148,Modifiability,extend,extending,148,"// std::decay is supposed to produce 'std::remove_cv', but since 'restrict' is; // in the same group of qualifiers as 'const' and 'volatile', we're extending; // '__decay(T)' so that it removes all qualifiers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:28,Usability,clear,clear,28,"// FIXME: It isn't entirely clear whether incomplete atomic types; // are allowed or not; for simplicity, ban them for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:94,Usability,simpl,simplicity,94,"// FIXME: It isn't entirely clear whether incomplete atomic types; // are allowed or not; for simplicity, ban them for the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:2722,Energy Efficiency,efficient,efficient,2722,"nsforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.; ///; /// For more fine-grained transformations, subclasses can replace any of the; /// \c TransformXXX functions (where XXX is the name of an AST node, e.g.,; /// PointerType, StmtExpr) to alter the transformation. As mentioned previously,; /// replacing TransformTemplateTypeParmType() allows template instantiation; /// to substitute template arguments for their corresponding template; /// parameters. Additionally, subclasses can override the \c RebuildXXX; /// functions to control how AST nodes are rebuilt when their operands change.; /// By default, \c TreeTransform will invoke semantic analysis to rebuild; /// AST nodes. However, certain other tree transformations (e.g, cloning) may; /// be able to use more efficient rebuild steps.; ///; /// There are a handful of other functions that can be overridden, allowing one; /// to avoid traversing nodes that don't need any transformation; /// (\c AlreadyTransformed()), force rebuilding AST nodes even when their; /// operands have not changed (\c AlwaysRebuild()), and customize the; /// default locations and entity names used for type-checking; /// (\c getBaseLocation(), \c getBaseEntity()).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:1417,Integrability,rout,routines,1417,"ypeParmType nodes involves substituting the; /// template arguments for their corresponding template parameters; a similar; /// transformation is performed for non-type template parameters and; /// template template parameters.; ///; /// This tree-transformation template uses static polymorphism to allow; /// subclasses to customize any of its operations. Thus, a subclass can; /// override any of the transformation or rebuild operators by providing an; /// operation with the same signature as the default implementation. The; /// overriding function should not be virtual.; ///; /// Semantic tree transformations are split into two stages, either of which; /// can be replaced by a subclass. The ""transform"" step transforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.; ///; /// For more fine-grained transformations, subclasses can replace any of the; /// \c TransformXXX functions (where XXX is the name of an AST node, e.g.,; /// PointerType, StmtExpr) to alter the transformation. As mentioned previously,; /// replacing TransformTemplateTypeParmType() allows template instantiation; /// to substitute template arguments for their corresponding template; /// parameters. Additionally, subclasses can ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:719,Modifiability,polymorphi,polymorphism,719,"/// A semantic tree transformation that allows one to transform one; /// abstract syntax tree into another.; ///; /// A new tree transformation is defined by creating a new subclass \c X of; /// \c TreeTransform<X> and then overriding certain operations to provide; /// behavior specific to that transformation. For example, template; /// instantiation is implemented as a tree transformation where the; /// transformation of TemplateTypeParmType nodes involves substituting the; /// template arguments for their corresponding template parameters; a similar; /// transformation is performed for non-type template parameters and; /// template template parameters.; ///; /// This tree-transformation template uses static polymorphism to allow; /// subclasses to customize any of its operations. Thus, a subclass can; /// override any of the transformation or rebuild operators by providing an; /// operation with the same signature as the default implementation. The; /// overriding function should not be virtual.; ///; /// Semantic tree transformations are split into two stages, either of which; /// can be replaced by a subclass. The ""transform"" step transforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:581,Performance,perform,performed,581,"/// A semantic tree transformation that allows one to transform one; /// abstract syntax tree into another.; ///; /// A new tree transformation is defined by creating a new subclass \c X of; /// \c TreeTransform<X> and then overriding certain operations to provide; /// behavior specific to that transformation. For example, template; /// instantiation is implemented as a tree transformation where the; /// transformation of TemplateTypeParmType nodes involves substituting the; /// template arguments for their corresponding template parameters; a similar; /// transformation is performed for non-type template parameters and; /// template template parameters.; ///; /// This tree-transformation template uses static polymorphism to allow; /// subclasses to customize any of its operations. Thus, a subclass can; /// override any of the transformation or rebuild operators by providing an; /// operation with the same signature as the default implementation. The; /// overriding function should not be virtual.; ///; /// Semantic tree transformations are split into two stages, either of which; /// can be replaced by a subclass. The ""transform"" step transforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:2841,Safety,avoid,avoid,2841,"nsforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.; ///; /// For more fine-grained transformations, subclasses can replace any of the; /// \c TransformXXX functions (where XXX is the name of an AST node, e.g.,; /// PointerType, StmtExpr) to alter the transformation. As mentioned previously,; /// replacing TransformTemplateTypeParmType() allows template instantiation; /// to substitute template arguments for their corresponding template; /// parameters. Additionally, subclasses can override the \c RebuildXXX; /// functions to control how AST nodes are rebuilt when their operands change.; /// By default, \c TreeTransform will invoke semantic analysis to rebuild; /// AST nodes. However, certain other tree transformations (e.g, cloning) may; /// be able to use more efficient rebuild steps.; ///; /// There are a handful of other functions that can be overridden, allowing one; /// to avoid traversing nodes that don't need any transformation; /// (\c AlreadyTransformed()), force rebuilding AST nodes even when their; /// operands have not changed (\c AlwaysRebuild()), and customize the; /// default locations and entity names used for type-checking; /// (\c getBaseLocation(), \c getBaseEntity()).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:282,Performance,perform,performing,282,"/// Whether the transformation should always rebuild AST nodes, even; /// if none of the children have changed.; ///; /// Subclasses may override this function to specify when the transformation; /// should rebuild all AST nodes.; ///; /// We must always rebuild all AST nodes when performing variadic template; /// pack expansion, in order to avoid violating the AST invariant that each; /// statement node appears at most once in its containing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:344,Safety,avoid,avoid,344,"/// Whether the transformation should always rebuild AST nodes, even; /// if none of the children have changed.; ///; /// Subclasses may override this function to specify when the transformation; /// should rebuild all AST nodes.; ///; /// We must always rebuild all AST nodes when performing variadic template; /// pack expansion, in order to avoid violating the AST invariant that each; /// statement node appears at most once in its containing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:91,Availability,avail,available,91,"/// Returns the location of the entity being transformed, if that; /// information was not available elsewhere in the AST.; ///; /// By default, returns no source-location information. Subclasses can; /// provide an alternative implementation that provides better location; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:87,Availability,avail,available,87,"/// Returns the name of the entity being transformed, if that; /// information was not available elsewhere in the AST.; ///; /// By default, returns an empty name. Subclasses can provide an alternative; /// implementation with a more precise name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,Integrability,rout,routine,148,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// Subclasses can provide an alternative implementation of this routine; /// to short-circuit evaluation when it is known that a given type will; /// not change. For example, template instantiation need not traverse; /// non-dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:309,Integrability,depend,dependent,309,"/// Determine whether the given type \p T has already been; /// transformed.; ///; /// Subclasses can provide an alternative implementation of this routine; /// to short-circuit evaluation when it is known that a given type will; /// not change. For example, template instantiation need not traverse; /// non-dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:181,Integrability,rout,routine,181,"/// Determine whether the given call argument should be dropped, e.g.,; /// because it is a default argument.; ///; /// Subclasses can provide an alternative implementation of this routine to; /// determine which kinds of call arguments get dropped. By default,; /// CXXDefaultArgument nodes are dropped (prior to transformation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:1591,Availability,error,error,1591,"/// Determine whether we should expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// By default, the transformer never tries to expand pack expansions.; /// Subclasses can override this routine to provide different behavior.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:279,Integrability,rout,routine,279,"/// Determine whether we should expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// By default, the transformer never tries to expand pack expansions.; /// Subclasses can override this routine to provide different behavior.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:971,Modifiability,extend,extending,971,"/// Determine whether we should expand a pack expansion with the; /// given set of parameter packs into separate arguments by repeatedly; /// transforming the pattern.; ///; /// By default, the transformer never tries to expand pack expansions.; /// Subclasses can override this routine to provide different behavior.; ///; /// \param EllipsisLoc The location of the ellipsis that identifies the; /// pack expansion.; ///; /// \param PatternRange The source range that covers the entire pattern of; /// the pack expansion.; ///; /// \param Unexpanded The set of unexpanded parameter packs within the; /// pattern.; ///; /// \param ShouldExpand Will be set to \c true if the transformer should; /// expand the corresponding pack expansions into separate arguments. When; /// set, \c NumExpansions must also be set.; ///; /// \param RetainExpansion Whether the caller should add an unexpanded; /// pack expansion after all of the expanded arguments. This is used; /// when extending explicitly-specified template argument packs per; /// C++0x [temp.arg.explicit]p9.; ///; /// \param NumExpansions The number of separate arguments that will be in; /// the expanded form of the corresponding pack expansion. This is both an; /// input and an output parameter, which can be set by the caller if the; /// number of expansions is known a priori (e.g., due to a prior substitution); /// and will be set by the callee when the number of expansions is known.; /// The callee must set this value when \c ShouldExpand is \c true; it may; /// set this value in other cases.; ///; /// \returns true if an error occurred (e.g., because the parameter packs; /// are to be instantiated with arguments of different lengths), false; /// otherwise. If false, \c ShouldExpand (and possibly \c NumExpansions); /// must be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:170,Integrability,rout,routine,170,"/// ""Forget"" about the partially-substituted pack template argument,; /// when performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:79,Performance,perform,performing,79,"/// ""Forget"" about the partially-substituted pack template argument,; /// when performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,Integrability,rout,routine,166,"/// ""Remember"" the partially-substituted pack template argument; /// after performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,Performance,perform,performing,75,"/// ""Remember"" the partially-substituted pack template argument; /// after performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,Integrability,rout,routine,76,"/// Transforms the given type into another type.; ///; /// By default, this routine transforms a type by creating a; /// TypeSourceInfo for it and delegating to the appropriate; /// function. This is expensive, but we don't mind, because; /// this method is deprecated anyway; all users should be; /// switched to storing TypeSourceInfos.; ///; /// \returns the transformed type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:107,Integrability,rout,routine,107,"/// Transforms the given type-with-location into a new; /// type-with-location.; ///; /// By default, this routine transforms a type by delegating to the; /// appropriate TransformXXXType to build a new type. Subclasses; /// may override this function (to take over all type; /// transformations) or some set of the TransformXXXType functions; /// to alter the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Integrability,rout,routine,62,"/// Transform the given statement.; ///; /// By default, this routine transforms a statement by delegating to the; /// appropriate TransformXXXStmt function to transform a specific kind of; /// statement or the TransformExpr() function to transform an expression.; /// Subclasses may override this function to transform statements using some; /// other mechanism.; ///; /// \returns the transformed statement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Integrability,rout,routine,62,"/// Transform the given statement.; ///; /// By default, this routine transforms a statement by delegating to the; /// appropriate TransformOMPXXXClause function to transform a specific kind; /// of clause. Subclasses may override this function to transform statements; /// using some other mechanism.; ///; /// \returns the transformed OpenMP clause.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Integrability,rout,routine,62,"/// Transform the given attribute.; ///; /// By default, this routine transforms a statement by delegating to the; /// appropriate TransformXXXAttr function to transform a specific kind; /// of attribute. Subclasses may override this function to transform; /// attributed statements/types using some other mechanism.; ///; /// \returns the transformed attribute",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Integrability,rout,routine,63,"/// Transform the given expression.; ///; /// By default, this routine transforms an expression by delegating to the; /// appropriate TransformXXXExpr function to build a new expression.; /// Subclasses may override this function to transform expressions using some; /// other mechanism.; ///; /// \returns the transformed expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Integrability,rout,routine,64,"/// Transform the given initializer.; ///; /// By default, this routine transforms an initializer by stripping off the; /// semantic nodes added by initialization, then passing the result to; /// TransformExpr or TransformExprs.; ///; /// \returns the transformed initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:953,Availability,error,error,953,"/// Transform the given list of expressions.; ///; /// This routine transforms a list of expressions by invoking; /// \c TransformExpr() for each subexpression. However, it also provides; /// support for variadic templates by expanding any pack expansions (if the; /// derived class permits such expansion) along the way. When pack expansions; /// are present, the number of outputs may not equal the number of inputs.; ///; /// \param Inputs The set of expressions to be transformed.; ///; /// \param NumInputs The number of expressions in \c Inputs.; ///; /// \param IsCall If \c true, then this transform is being performed on; /// function-call arguments, and any arguments that should be dropped, will; /// be.; ///; /// \param Outputs The transformed input expressions will be added to this; /// vector.; ///; /// \param ArgChanged If non-NULL, will be set \c true if any argument changed; /// due to transformation.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Integrability,rout,routine,60,"/// Transform the given list of expressions.; ///; /// This routine transforms a list of expressions by invoking; /// \c TransformExpr() for each subexpression. However, it also provides; /// support for variadic templates by expanding any pack expansions (if the; /// derived class permits such expansion) along the way. When pack expansions; /// are present, the number of outputs may not equal the number of inputs.; ///; /// \param Inputs The set of expressions to be transformed.; ///; /// \param NumInputs The number of expressions in \c Inputs.; ///; /// \param IsCall If \c true, then this transform is being performed on; /// function-call arguments, and any arguments that should be dropped, will; /// be.; ///; /// \param Outputs The transformed input expressions will be added to this; /// vector.; ///; /// \param ArgChanged If non-NULL, will be set \c true if any argument changed; /// due to transformation.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:617,Performance,perform,performed,617,"/// Transform the given list of expressions.; ///; /// This routine transforms a list of expressions by invoking; /// \c TransformExpr() for each subexpression. However, it also provides; /// support for variadic templates by expanding any pack expansions (if the; /// derived class permits such expansion) along the way. When pack expansions; /// are present, the number of outputs may not equal the number of inputs.; ///; /// \param Inputs The set of expressions to be transformed.; ///; /// \param NumInputs The number of expressions in \c Inputs.; ///; /// \param IsCall If \c true, then this transform is being performed on; /// function-call arguments, and any arguments that should be dropped, will; /// be.; ///; /// \param Outputs The transformed input expressions will be added to this; /// vector.; ///; /// \param ArgChanged If non-NULL, will be set \c true if any argument changed; /// due to transformation.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Modifiability,variab,variable,81,"/// Transform the specified condition.; ///; /// By default, this transforms the variable and expression and rebuilds; /// the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:295,Integrability,rout,routine,295,"/// Note that a local declaration has been transformed by this; /// transformer.; ///; /// Local declarations are typically transformed via a call to; /// TransformDefinition. However, in some cases (e.g., lambda expressions),; /// the transformer itself has to transform the declarations. This routine; /// can be overridden by a subclass that keeps track of such mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:106,Security,access,access,106,"/// Transform the given declaration, which was the first part of a; /// nested-name-specifier in a member access expression.; ///; /// This specific declaration transformation only applies to the first; /// identifier in a nested-name-specifier of a member access expression, e.g.,; /// the \c T in \c x->T::member; ///; /// By default, invokes TransformDecl() to transform the declaration.; /// Subclasses may override this function to provide alternate behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:257,Security,access,access,257,"/// Transform the given declaration, which was the first part of a; /// nested-name-specifier in a member access expression.; ///; /// This specific declaration transformation only applies to the first; /// identifier in a nested-name-specifier of a member access expression, e.g.,; /// the \c T in \c x->T::member; ///; /// By default, invokes TransformDecl() to transform the declaration.; /// Subclasses may override this function to provide alternate behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:394,Security,access,access,394,"/// Transform the given template name.; ///; /// \param SS The nested-name-specifier that qualifies the template; /// name. This nested-name-specifier must already have been transformed.; ///; /// \param Name The template name to transform.; ///; /// \param NameLoc The source location of the template name.; ///; /// \param ObjectType If we're translating a template name within a member; /// access expression, this is the type of the object whose member template; /// is being referenced.; ///; /// \param FirstQualifierInScope If the first part of a nested-name-specifier; /// also refers to a name within the current (lexical) scope, this is the; /// declaration it refers to.; ///; /// By default, transforms the template name by transforming the declarations; /// and nested-name-specifiers that occur within the template name.; /// Subclasses may override this function to provide alternate behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:355,Availability,error,error,355,"/// Transform the given template argument.; ///; /// By default, this operation transforms the type, expression, or; /// declaration stored within the template argument and constructs a; /// new template argument from the transformed result. Subclasses may; /// override this function to provide alternate behavior.; ///; /// Returns true if there was an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:744,Availability,error,error,744,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// Note that this overload of \c TransformTemplateArguments() is merely; /// a convenience function. Subclasses that wish to override this behavior; /// should override the iterator-based member template version.; ///; /// \param Inputs The set of template arguments to be transformed.; ///; /// \param NumInputs The number of template arguments in \p Inputs.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:706,Integrability,rout,routine,706,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// Note that this overload of \c TransformTemplateArguments() is merely; /// a convenience function. Subclasses that wish to override this behavior; /// should override the iterator-based member template version.; ///; /// \param Inputs The set of template arguments to be transformed.; ///; /// \param NumInputs The number of template arguments in \p Inputs.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:520,Availability,error,error,520,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// \param First An iterator to the first template argument.; ///; /// \param Last An iterator one step past the last template argument.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:482,Integrability,rout,routine,482,"/// Transform the given set of template arguments.; ///; /// By default, this operation transforms all of the template arguments; /// in the input set using \c TransformTemplateArgument(), and appends; /// the transformed arguments to the output list.; ///; /// \param First An iterator to the first template argument.; ///; /// \param Last An iterator one step past the last template argument.; ///; /// \param Outputs The set of transformed template arguments output by this; /// routine.; ///; /// Returns true if an error occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:342,Availability,error,error,342,"/// Transforms the parameters of a function type into the; /// given vectors.; ///; /// The result vectors should be kept in sync; null entries in the; /// variables vector are acceptable.; ///; /// LastParamTransformed, if non-null, will be set to the index of the last; /// parameter on which transfromation was started. In the event of an error,; /// this will contain the parameter which failed to instantiate.; ///; /// Return true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:440,Availability,error,error,440,"/// Transforms the parameters of a function type into the; /// given vectors.; ///; /// The result vectors should be kept in sync; null entries in the; /// variables vector are acceptable.; ///; /// LastParamTransformed, if non-null, will be set to the index of the last; /// parameter on which transfromation was started. In the event of an error,; /// this will contain the parameter which failed to instantiate.; ///; /// Return true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Modifiability,variab,variables,156,"/// Transforms the parameters of a function type into the; /// given vectors.; ///; /// The result vectors should be kept in sync; null entries in the; /// variables vector are acceptable.; ///; /// LastParamTransformed, if non-null, will be set to the index of the last; /// parameter on which transfromation was started. In the event of an error,; /// this will contain the parameter which failed to instantiate.; ///; /// Return true on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Modifiability,variab,variables,157,"/// Transforms the parameters of a requires expresison into the given vectors.; ///; /// The result vectors should be kept in sync; null entries in the; /// variables vector are acceptable.; ///; /// Returns an unset ExprResult on success. Returns an ExprResult the 'not; /// satisfied' RequiresExpr if subsitution failed, OR an ExprError, both of; /// which are cases where transformation shouldn't continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Availability,error,error,69,/// Transforms a single function-type parameter. Return null; /// on error.; ///; /// \param indexAdjustment - A number to add to the parameter's; /// scope index; can be negative,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,Integrability,rout,routine,104,"/// Build a new qualified type given its unqualified type and type location.; ///; /// By default, this routine adds type qualifiers only to types that can; /// have qualifiers, and silently suppresses those qualifiers that are not; /// permitted. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:277,Integrability,rout,routine,277,"/// Build a new qualified type given its unqualified type and type location.; ///; /// By default, this routine adds type qualifiers only to types that can; /// have qualifiers, and silently suppresses those qualifiers that are not; /// permitted. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,Integrability,rout,routine,168,"/// Build a new pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the pointer type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,Performance,perform,performs,75,"/// Build a new pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the pointer type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:180,Integrability,rout,routine,180,"/// Build a new block pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the block pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Performance,perform,performs,81,"/// Build a new block pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the block pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:178,Integrability,rout,routine,178,"/// Build a new reference type given the type it references.; ///; /// By default, performs semantic analysis when building the; /// reference type. Subclasses may override this routine to provide; /// different behavior.; ///; /// \param LValue whether the type was written with an lvalue sigil; /// or an rvalue sigil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:83,Performance,perform,performs,83,"/// Build a new reference type given the type it references.; ///; /// By default, performs semantic analysis when building the; /// reference type. Subclasses may override this routine to provide; /// different behavior.; ///; /// \param LValue whether the type was written with an lvalue sigil; /// or an rvalue sigil.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:221,Integrability,rout,routine,221,"/// Build a new member pointer type given the pointee type and the; /// class type it refers into.; ///; /// By default, performs semantic analysis when building the member pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:121,Performance,perform,performs,121,"/// Build a new member pointer type given the pointee type and the; /// class type it refers into.; ///; /// By default, performs semantic analysis when building the member pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Integrability,rout,routine,152,"/// Build an Objective-C object type.; ///; /// By default, performs semantic analysis when building the object type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build an Objective-C object type.; ///; /// By default, performs semantic analysis when building the object type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:263,Integrability,rout,routine,263,"/// Build a new array type given the element type, size; /// modifier, size of the array (if known), size expression, and index type; /// qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.; /// Also by default, all of the other Rebuild*Array",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:172,Performance,perform,performs,172,"/// Build a new array type given the element type, size; /// modifier, size of the array (if known), size expression, and index type; /// qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.; /// Also by default, all of the other Rebuild*Array",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:247,Integrability,rout,routine,247,"/// Build a new constant array type given the element type, size; /// modifier, (known) size of the array, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Performance,perform,performs,156,"/// Build a new constant array type given the element type, size; /// modifier, (known) size of the array, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:222,Integrability,rout,routine,222,"/// Build a new incomplete array type given the element type, size; /// modifier, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:131,Performance,perform,performs,131,"/// Build a new incomplete array type given the element type, size; /// modifier, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:244,Integrability,rout,routine,244,"/// Build a new variable-length array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Modifiability,variab,variable-length,16,"/// Build a new variable-length array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Performance,perform,performs,153,"/// Build a new variable-length array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Integrability,depend,dependent-sized,16,"/// Build a new dependent-sized array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:244,Integrability,rout,routine,244,"/// Build a new dependent-sized array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Performance,perform,performs,153,"/// Build a new dependent-sized array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,Integrability,rout,routine,194,"/// Build a new vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:102,Performance,perform,performs,102,"/// Build a new vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:28,Integrability,depend,dependently-sized,28,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:233,Integrability,rout,routine,233,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:46,Modifiability,extend,extended,46,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:141,Performance,perform,performs,141,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:203,Integrability,rout,routine,203,"/// Build a new extended vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Modifiability,extend,extended,16,"/// Build a new extended vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:111,Performance,perform,performs,111,"/// Build a new extended vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:28,Integrability,depend,dependently-sized,28,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:233,Integrability,rout,routine,233,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:46,Modifiability,extend,extended,46,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:141,Performance,perform,performs,141,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Integrability,depend,dependently-defined,47,/// Build a new matrix type given the type and dependently-defined; /// dimensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Integrability,Depend,DependentAddressSpaceType,16,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:239,Integrability,depend,dependent,239,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:384,Integrability,rout,routine,384,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:74,Modifiability,variab,variable,74,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:272,Performance,perform,performs,272,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,Integrability,rout,routine,147,"/// Build a new function type.; ///; /// By default, performs semantic analysis when building the function type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Performance,perform,performs,53,"/// Build a new function type.; ///; /// By default, performs semantic analysis when building the function type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new typeof(expr) type.; ///; /// By default, performs semantic analysis when building the typeof type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Performance,perform,performs,57,"/// Build a new typeof(expr) type.; ///; /// By default, performs semantic analysis when building the typeof type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new C++11 decltype type.; ///; /// By default, performs semantic analysis when building the decltype type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new C++11 decltype type.; ///; /// By default, performs semantic analysis when building the decltype type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:107,Integrability,depend,dependent,107,"// Note, IsDependent is always false here: we implicitly convert an 'auto'; // which has been deduced to a dependent type into an undeduced 'auto', so; // that we'll retry deduction after the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:177,Integrability,rout,routine,177,"/// Build a new template specialization type.; ///; /// By default, performs semantic analysis when building the template; /// specialization type. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new template specialization type.; ///; /// By default, performs semantic analysis when building the template; /// specialization type. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:141,Integrability,rout,routine,141,"/// Build a new parenthesized type.; ///; /// By default, builds a new ParenType type from the inner type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:195,Integrability,rout,routine,195,"/// Build a new qualified name type.; ///; /// By default, builds a new ElaboratedType type from the keyword,; /// the nested-name-specifier and the named type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:95,Integrability,Depend,DependentNameType,95,"/// Build a new typename type that refers to a template-id.; ///; /// By default, builds a new DependentNameType type from the; /// nested-name-specifier and the given type. Subclasses may override; /// this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:208,Integrability,rout,routine,208,"/// Build a new typename type that refers to a template-id.; ///; /// By default, builds a new DependentNameType type from the; /// nested-name-specifier and the given type. Subclasses may override; /// this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:40,Safety,avoid,avoid,40,// Rebuild the template name.; // TODO: avoid TemplateName abstraction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:17,Integrability,depend,dependent,17,"// If it's still dependent, make a dependent specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:35,Integrability,depend,dependent,35,"// If it's still dependent, make a dependent specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:38,Integrability,wrap,wrapping,38,"// Otherwise, make an elaborated type wrapping a non-dependent; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Integrability,depend,dependent,53,"// Otherwise, make an elaborated type wrapping a non-dependent; // specialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:197,Integrability,rout,routine,197,"/// Build a new typename type that refers to an identifier.; ///; /// By default, performs semantic analysis when building the typename type; /// (or elaborated type). Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:82,Performance,perform,performs,82,"/// Build a new typename type that refers to an identifier.; ///; /// By default, performs semantic analysis when building the typename type; /// (or elaborated type). Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Integrability,depend,dependent,24,"// If the name is still dependent, just build a new dependent name type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:52,Integrability,depend,dependent,52,"// If the name is still dependent, just build a new dependent name type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,Integrability,depend,dependent,12,// We had a dependent elaborated-type-specifier that has been transformed; // into a non-dependent elaborated-type-specifier. Find the tag we're; // referring to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:89,Integrability,depend,dependent,89,// We had a dependent elaborated-type-specifier that has been transformed; // into a non-dependent elaborated-type-specifier. Find the tag we're; // referring to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new pack expansion type.; ///; /// By default, builds a new PackExpansionType type from the given pattern.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,Integrability,rout,routine,164,"/// Build a new atomic type given its value type.; ///; /// By default, performs semantic analysis when building the atomic type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,Performance,perform,performs,72,"/// Build a new atomic type given its value type.; ///; /// By default, performs semantic analysis when building the atomic type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,Integrability,depend,dependent,12,/// Build a dependent bit-precise int given its value type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:280,Integrability,rout,routine,280,"/// Build a new template name given a nested name specifier, a flag; /// indicating whether the ""template"" keyword was provided, and the template; /// that the template name refers to.; ///; /// By default, builds the new template name directly. Subclasses may override; /// this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:322,Integrability,rout,routine,322,"/// Build a new template name given a nested name specifier and the; /// name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:135,Performance,perform,performs,135,"/// Build a new template name given a nested name specifier and the; /// name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:342,Integrability,rout,routine,342,"/// Build a new template name given a nested name specifier and the; /// overloaded operator name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Performance,perform,performs,155,"/// Build a new template name given a nested name specifier and the; /// overloaded operator name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:293,Integrability,rout,routine,293,"/// Build a new template name given a template template parameter pack; /// and the; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:106,Performance,perform,performs,106,"/// Build a new template name given a template template parameter pack; /// and the; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,Integrability,rout,routine,147,"/// Build a new compound statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Performance,perform,performs,58,"/// Build a new compound statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,Integrability,rout,routine,143,"/// Build a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,Performance,perform,performs,54,"/// Build a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Attach the body to a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Attach the body to a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,Integrability,rout,routine,146,"/// Build a new default statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Performance,perform,performs,57,"/// Build a new default statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:144,Integrability,rout,routine,144,"/// Build a new label statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,Performance,perform,performs,55,"/// Build a new label statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new attributed statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new attributed statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,Integrability,rout,routine,143,"/// Build a new ""if"" statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,Performance,perform,performs,54,"/// Build a new ""if"" statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Start building a new switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Start building a new switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Attach the body to the switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Attach the body to the switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:144,Integrability,rout,routine,144,"/// Build a new while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,Performance,perform,performs,55,"/// Build a new while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,Integrability,rout,routine,147,"/// Build a new do-while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Performance,perform,performs,58,"/// Build a new do-while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:142,Integrability,rout,routine,142,"/// Build a new for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,Performance,perform,performs,53,"/// Build a new for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:143,Integrability,rout,routine,143,"/// Build a new goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,Performance,perform,performs,54,"/// Build a new goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Integrability,rout,routine,152,"/// Build a new indirect goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new indirect goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:145,Integrability,rout,routine,145,"/// Build a new return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:56,Performance,perform,performs,56,"/// Build a new return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,Integrability,rout,routine,150,"/// Build a new declaration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new declaration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new MS style inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new MS style inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,Integrability,rout,routine,148,"/// Build a new co_return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new co_return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Performance,perform,performed,152,"// This function rebuilds a coawait-expr given its operator.; // For an explicit coawait-expr, the rebuild involves the full set; // of transformations performed by BuildUnresolvedCoawaitExpr(),; // including calling await_transform().; // For an implicit coawait-expr, we need to rebuild the ""operator; // coawait"" but not await_transform(), so use BuildResolvedCoawaitExpr().; // This mirrors how the implicit CoawaitExpr is originally created; // in Sema::ActOnCoroutineBodyStart().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new co_yield expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new co_yield expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new Objective-C \@try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new Objective-C \@try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,Integrability,rout,routine,163,"/// Rebuild an Objective-C exception declaration.; ///; /// By default, performs semantic analysis to build the new declaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,Performance,perform,performs,72,"/// Rebuild an Objective-C exception declaration.; ///; /// By default, performs semantic analysis to build the new declaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new Objective-C \@catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new Objective-C \@catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new Objective-C \@finally statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new Objective-C \@finally statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new Objective-C \@throw statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new Objective-C \@throw statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:99,Integrability,wrap,wrapped,99,/// Build a new OpenMP Canonical loop.; ///; /// Ensures that the outermost loop in @p LoopStmt is wrapped by a; /// OMPCanonicalLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP executable directive.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new OpenMP executable directive.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new OpenMP 'if' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Performance,perform,performs,58,"/// Build a new OpenMP 'if' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'final' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new OpenMP 'final' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new OpenMP 'num_threads' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new OpenMP 'num_threads' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Safety,safe,safelen,24,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'simdlen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'simdlen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'allocator' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'allocator' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'collapse' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'collapse' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'default' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'default' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'proc_bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'proc_bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Energy Efficiency,schedul,schedule,24,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'ordered' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'ordered' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'private' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'private' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,Integrability,rout,routine,161,"/// Build a new OpenMP 'firstprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new OpenMP 'firstprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new OpenMP 'lastprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new OpenMP 'lastprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new OpenMP 'shared' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'shared' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new OpenMP 'task_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new OpenMP 'task_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'in_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new OpenMP 'in_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new OpenMP 'linear' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'linear' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'aligned' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'aligned' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new OpenMP 'copyin' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'copyin' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new OpenMP 'copyprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new OpenMP 'copyprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,Integrability,rout,routine,161,"/// Build a new OpenMP 'flush' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new OpenMP 'flush' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,Integrability,rout,routine,162,"/// Build a new OpenMP 'depobj' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new OpenMP 'depobj' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Integrability,depend,depend,24,"/// Build a new OpenMP 'depend' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,Integrability,rout,routine,162,"/// Build a new OpenMP 'depend' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new OpenMP 'depend' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new OpenMP 'device' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'device' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Integrability,rout,routine,152,"/// Build a new OpenMP 'map' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new OpenMP 'map' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Energy Efficiency,allocate,allocate,24,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'num_teams' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'num_teams' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'thread_limit' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new OpenMP 'thread_limit' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new OpenMP 'priority' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'priority' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'grainsize' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'grainsize' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'num_tasks' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'num_tasks' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new OpenMP 'hint' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new OpenMP 'hint' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new OpenMP 'detach' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'detach' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,Integrability,rout,routine,162,"/// Build a new OpenMP 'dist_schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new OpenMP 'dist_schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:147,Integrability,rout,routine,147,"/// Build a new OpenMP 'to' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Performance,perform,performs,58,"/// Build a new OpenMP 'to' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new OpenMP 'from' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new OpenMP 'from' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,Integrability,rout,routine,163,"/// Build a new OpenMP 'use_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new OpenMP 'use_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,Integrability,rout,routine,164,"/// Build a new OpenMP 'use_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new OpenMP 'use_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,Integrability,rout,routine,162,"/// Build a new OpenMP 'is_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new OpenMP 'is_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,Integrability,rout,routine,164,"/// Build a new OpenMP 'has_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new OpenMP 'has_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new OpenMP 'defaultmap' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// Build a new OpenMP 'defaultmap' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new OpenMP 'nontemporal' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new OpenMP 'nontemporal' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'inclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'inclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'exclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'exclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,Integrability,rout,routine,164,"/// Build a new OpenMP 'uses_allocators' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new OpenMP 'uses_allocators' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'affinity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'affinity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'order' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new OpenMP 'order' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new OpenMP 'init' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new OpenMP 'init' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Integrability,rout,routine,152,"/// Build a new OpenMP 'use' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new OpenMP 'use' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'destroy' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'destroy' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new OpenMP 'novariants' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// Build a new OpenMP 'novariants' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'nocontext' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'nocontext' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new OpenMP 'filter' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new OpenMP 'filter' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new OpenMP 'bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new OpenMP 'bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,Integrability,rout,routine,168,"/// Build a new OpenMP 'ompx_dyn_cgroup_mem' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,Performance,perform,performs,75,"/// Build a new OpenMP 'ompx_dyn_cgroup_mem' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,Integrability,rout,routine,163,"/// Build a new OpenMP 'ompx_attribute' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new OpenMP 'ompx_attribute' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new OpenMP 'ompx_bare' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new OpenMP 'ompx_bare' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new OpenMP 'align' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new OpenMP 'align' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new OpenMP 'at' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,Performance,perform,performs,58,"/// Build a new OpenMP 'at' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'severity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'severity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,Integrability,message,message,24,"/// Build a new OpenMP 'message' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new OpenMP 'message' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new OpenMP 'message' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new OpenMP 'doacross' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new OpenMP 'doacross' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:44,Integrability,synchroniz,synchronized,44,"/// Rebuild the operand to an Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:179,Integrability,rout,routine,179,"/// Rebuild the operand to an Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:90,Performance,perform,performs,90,"/// Rebuild the operand to an Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:30,Integrability,synchroniz,synchronized,30,"/// Build a new Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:165,Integrability,rout,routine,165,"/// Build a new Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,Performance,perform,performs,76,"/// Build a new Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,Integrability,rout,routine,168,"/// Build a new Objective-C \@autoreleasepool statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:79,Performance,perform,performs,79,"/// Build a new Objective-C \@autoreleasepool statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:167,Integrability,rout,routine,167,"/// Build a new Objective-C fast enumeration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:78,Performance,perform,performs,78,"/// Build a new Objective-C fast enumeration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new C++ exception declaration.; ///; /// By default, performs semantic analysis to build the new decaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new C++ exception declaration.; ///; /// By default, performs semantic analysis to build the new decaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:148,Integrability,rout,routine,148,"/// Build a new C++ catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new C++ catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:146,Integrability,rout,routine,146,"/// Build a new C++ try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Performance,perform,performs,57,"/// Build a new C++ try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:17,Usability,learn,learned,17,"// If we've just learned that the range is actually an Objective-C; // collection, treat this as an Objective-C fast enumeration loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,Integrability,rout,routine,166,"/// Attach body to a C++0x range-based for statement.; ///; /// By default, performs semantic analysis to finish the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,Performance,perform,performs,76,"/// Attach body to a C++0x range-based for statement.; ///; /// By default, performs semantic analysis to finish the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new predefined expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new predefined expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:170,Integrability,rout,routine,170,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:80,Performance,perform,performs,80,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:170,Integrability,rout,routine,170,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:80,Performance,perform,performs,80,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new expression in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new expression in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new pseudo-destructor expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new pseudo-destructor expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new unary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new unary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new builtin offsetof expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new builtin offsetof expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,Integrability,rout,routine,194,"/// Build a new sizeof, alignof or vec_step expression with a; /// type argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,Performance,perform,performs,104,"/// Build a new sizeof, alignof or vec_step expression with a; /// type argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:201,Integrability,rout,routine,201,"/// Build a new sizeof, alignof or vec step expression with an; /// expression argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:111,Performance,perform,performs,111,"/// Build a new sizeof, alignof or vec step expression with an; /// expression argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new array subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// Build a new array subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new matrix subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new matrix subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new array section expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new array section expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new array shaping expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new array shaping expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new iterator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new iterator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:145,Integrability,rout,routine,145,"/// Build a new call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,Performance,perform,performs,55,"/// Build a new call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:23,Security,access,access,23,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:108,Security,access,access,108,"// We have a reference to an unnamed field. This is always the; // base of an anonymous struct/union member access, i.e. the; // field is always of record type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:86,Safety,avoid,avoid,86,// FIXME: this involves duplicating earlier analysis in a lot of; // cases; we should avoid this when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Security,access,access,66,"// In unevaluated contexts, an expression supposed to be a member access; // might reference a member in an unrelated class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new binary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// Build a new binary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new rewritten operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new rewritten operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,Integrability,rout,routine,161,"/// Build a new conditional operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new conditional operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new C-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new C-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new compound literal expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new compound literal expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:171,Integrability,rout,routine,171,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:16,Modifiability,extend,extended,16,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Performance,perform,performs,81,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:40,Security,access,access,40,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new initializer list expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new initializer list expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,Integrability,rout,routine,163,"/// Build a new designated initializer expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:73,Performance,perform,performs,73,"/// Build a new designated initializer expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:185,Integrability,rout,routine,185,"/// Build a new value-initialized expression.; ///; /// By default, builds the implicit value initialization without performing; /// any semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:117,Performance,perform,performing,117,"/// Build a new value-initialized expression.; ///; /// By default, builds the implicit value initialization without performing; /// any semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,Integrability,rout,routine,150,"/// Build a new \c va_arg expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new \c va_arg expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new expression list in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new expression list in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:220,Integrability,rout,routine,220,"/// Build a new address-of-label expression.; ///; /// By default, performs semantic analysis, using the name of the label; /// rather than attempting to map the label statement itself.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new address-of-label expression.; ///; /// By default, performs semantic analysis, using the name of the label; /// rather than attempting to map the label statement itself.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:154,Integrability,rout,routine,154,"/// Build a new GNU statement expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,Performance,perform,performs,64,"/// Build a new GNU statement expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:162,Integrability,rout,routine,162,"/// Build a new __builtin_choose_expr expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,Performance,perform,performs,72,"/// Build a new __builtin_choose_expr expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:187,Integrability,rout,routine,187,"/// Build a new generic selection expression with an expression predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:97,Performance,perform,performs,97,"/// Build a new generic selection expression with an expression predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:180,Integrability,rout,routine,180,"/// Build a new generic selection expression with a type predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:90,Performance,perform,performs,90,"/// Build a new generic selection expression with a type predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:359,Integrability,depend,dependent,359,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:411,Integrability,rout,routine,411,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,Performance,perform,performs,75,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:334,Performance,perform,performing,334,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:118,Integrability,rout,routine,118,"/// Build a new C++ ""named"" cast expression, such as static_cast or; /// reinterpret_cast.; ///; /// By default, this routine dispatches to one of the more-specific routines; /// for a particular named case, e.g., RebuildCXXStaticCastExpr().; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:165,Integrability,rout,routines,165,"/// Build a new C++ ""named"" cast expression, such as static_cast or; /// reinterpret_cast.; ///; /// By default, this routine dispatches to one of the more-specific routines; /// for a particular named case, e.g., RebuildCXXStaticCastExpr().; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:276,Integrability,rout,routine,276,"/// Build a new C++ ""named"" cast expression, such as static_cast or; /// reinterpret_cast.; ///; /// By default, this routine dispatches to one of the more-specific routines; /// for a particular named case, e.g., RebuildCXXStaticCastExpr().; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// Build a new C++ static_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// Build a new C++ static_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new C++ dynamic_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new C++ dynamic_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,Integrability,rout,routine,161,"/// Build a new C++ reinterpret_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new C++ reinterpret_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new C++ const_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new C++ const_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:166,Integrability,rout,routine,166,"/// Build a new C++ functional-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,Performance,perform,performs,76,"/// Build a new C++ functional-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:163,Integrability,rout,routine,163,"/// Build a new C++ __builtin_bit_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:73,Performance,perform,performs,73,"/// Build a new C++ __builtin_bit_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new C++ typeid(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new C++ typeid(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new C++ typeid(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new C++ typeid(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new C++ __uuidof(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new C++ __uuidof(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:159,Integrability,rout,routine,159,"/// Build a new C++ __uuidof(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,Performance,perform,performs,69,"/// Build a new C++ __uuidof(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:168,Integrability,rout,routine,168,"/// Build a new C++ ""this"" expression.; ///; /// By default, builds a new ""this"" expression without performing any; /// semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:100,Performance,perform,performing,100,"/// Build a new C++ ""this"" expression.; ///; /// By default, builds a new ""this"" expression without performing any; /// semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,Integrability,rout,routine,150,"/// Build a new C++ throw expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new C++ throw expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:193,Integrability,rout,routine,193,"/// Build a new C++ default-argument expression.; ///; /// By default, builds a new default-argument expression, which does not; /// require any semantic analysis. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:218,Integrability,rout,routine,218,"/// Build a new C++11 default-initialization expression.; ///; /// By default, builds a new default field initialization expression, which; /// does not require any semantic analysis. Subclasses may override this; /// routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:164,Integrability,rout,routine,164,"/// Build a new C++ zero-initialization expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:74,Performance,perform,performs,74,"/// Build a new C++ zero-initialization expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:150,Integrability,rout,routine,150,"/// Build a new C++ ""new"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,Performance,perform,performs,60,"/// Build a new C++ ""new"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,Integrability,rout,routine,153,"/// Build a new C++ ""delete"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,Performance,perform,performs,63,"/// Build a new C++ ""delete"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:151,Integrability,rout,routine,151,"/// Build a new type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new array type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new array type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new expression trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new expression trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:191,Integrability,rout,routine,191,"/// Build a new (previously unresolved) declaration reference; /// expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:101,Performance,perform,performs,101,"/// Build a new (previously unresolved) declaration reference; /// expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:152,Integrability,rout,routine,152,"/// Build a new template-id expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,Performance,perform,performs,62,"/// Build a new template-id expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:105,Modifiability,inherit,inherited,105,"// Reconstruct the constructor we originally found, which might be; // different if this is a call to an inherited constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:42,Modifiability,inherit,inherited,42,/// Build a new implicit construction via inherited constructor; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:149,Integrability,rout,routine,149,"/// Build a new noexcept expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,Performance,perform,performs,59,"/// Build a new noexcept expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:194,Integrability,rout,routine,194,"/// Build a new expression representing a call to a source location; /// builtin.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,Performance,perform,performs,104,"/// Build a new expression representing a call to a source location; /// builtin.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,Integrability,rout,routine,156,"/// \brief Build a new requires expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,Performance,perform,performs,66,"/// \brief Build a new requires expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:165,Integrability,rout,routine,165,"/// \brief Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,Performance,perform,performs,75,"/// \brief Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new Objective-C array literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new Objective-C array literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Integrability,rout,routine,160,"/// Build a new Objective-C dictionary literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,Performance,perform,performs,70,"/// Build a new Objective-C dictionary literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:161,Integrability,rout,routine,161,"/// Build a new Objective-C \@encode expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,Performance,perform,performs,71,"/// Build a new Objective-C \@encode expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:34,Integrability,message,message,34,/// Build a new Objective-C class message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:37,Integrability,message,message,37,/// Build a new Objective-C instance message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:43,Integrability,message,message,43,/// Build a new Objective-C instance/class message to 'super'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:167,Integrability,rout,routine,167,"/// Build a new Objective-C ivar reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:77,Performance,perform,performs,77,"/// Build a new Objective-C ivar reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:171,Integrability,rout,routine,171,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Performance,perform,performs,81,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:171,Integrability,rout,routine,171,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Performance,perform,performs,81,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:45,Integrability,depend,dependent,45,"// Since these expressions can only be value-dependent, we do not; // need to perform semantic analysis again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:78,Performance,perform,perform,78,"// Since these expressions can only be value-dependent, we do not; // need to perform semantic analysis again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:158,Integrability,rout,routine,158,"/// Build a new Objective-C ""isa"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,Performance,perform,performs,68,"/// Build a new Objective-C ""isa"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,Integrability,rout,routine,155,"/// Build a new shuffle vector expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new shuffle vector expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:188,Integrability,rout,routine,188,"/// Build a new template argument pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for a template argument. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,Performance,perform,performs,72,"/// Build a new template argument pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for a template argument. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:175,Integrability,rout,routine,175,"/// Build a new expression pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for an expression. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,Performance,perform,performs,65,"/// Build a new expression pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for an expression. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,Performance,perform,performs,61,"/// Build a new C++1z fold-expression.; ///; /// By default, performs semantic analysis in order to build a new fold; /// expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:160,Availability,error,error,160,"/// Build an empty C++1z fold-expression with the given operator.; ///; /// By default, produces the fallback value for the fold-expression, or; /// produce an error if there is no fallback value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,Integrability,rout,routine,157,"/// Build a new atomic operation expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,Performance,perform,performs,67,"/// Build a new atomic operation expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,Modifiability,layers,layers,81,"// Initializers are instantiated like expressions, except that various outer; // layers are stripped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:14,Modifiability,variab,variable,14,// This was a variable declaration's initialization for which no initializer; // was specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,Usability,simpl,simple,57,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,Performance,perform,perform,47,// The transform has determined that we should perform an elementwise; // expansion of the pattern. Do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:56,Performance,perform,perform,56,// There is no meaningful transformation that one could perform on the; // global scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:74,Availability,error,error,74,"// If the nested-name-specifier is an invalid type def, don't emit an; // error because a previous error should have already been emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:99,Availability,error,error,99,"// If the nested-name-specifier is an invalid type def, don't emit an; // error because a previous error should have already been emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:3,Energy Efficiency,Allocate,Allocate,3,// Allocate new nested-name-specifier location information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:13,Energy Efficiency,adapt,adaptor,13,/// Iterator adaptor that invents template argument location information; /// for each of the template arguments in its underlying iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:13,Modifiability,adapt,adaptor,13,/// Iterator adaptor that invents template argument location information; /// for each of the template arguments in its underlying iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h
