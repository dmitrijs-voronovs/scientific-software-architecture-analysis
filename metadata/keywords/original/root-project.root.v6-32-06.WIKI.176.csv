id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html528/TPythia8.html:4005,Availability,error,error,4005," TPythia8(const TPythia8&); virtual~TPythia8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGenerator::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGenerator::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventListing() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGenerator::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*TGenerator::GetListOfParticles() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; Int_tTGenerator::GetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTGenerator::GetParameter(const char*) const; virtual TParticle*TGenerator::GetParticle(Int_t i) ",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8.html:4089,Availability,error,error,4089,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGenerator::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGenerator::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventListing() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGenerator::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*TGenerator::GetListOfParticles() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; Int_tTGenerator::GetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTGenerator::GetParameter(const char*) const; virtual TParticle*TGenerator::GetParticle(Int_t i) const; virtual TObjArray*TGenerator::GetPrimaries(Option_t* option = """"); Float_tTGe",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8.html:2384,Deployability,release,released,2384,"l: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S. Mrenna and P. Skands, arXiv:0710.3820 | |; | | | |; | | The main physics reference is the 'PYTHIA 6.4 Physics and Manual', | |; | | T. Sjostrand, S. Mrenna and P. Skands, JHEP05 (2006) 026 [hep-ph/0603175]. | |; | | | |; | | An archive of program versions and documentation is found on the web: | |; | | http://www.thep.lu.se/~torbjorn/Pythia.html | |; | | | |; | | This program is released under the GNU General Public Licence version 2. | |; | | Please respect the MCnet Guidelines for Event Generator Authors and Users. | |; | | | |; | | Disclaimer: this program comes without any guarantees. | |; | | Beware of errors and use common sense when interpreting results. | |; | | | |; | | Copyright (C) 2007 Torbjorn Sjostrand | |; | | | |; | | | |; | *------------------------------------------------------------------------------* |; | |; *------------------------------------------------------------------------------------*. Function Members (Methods); public:. TPythia8(); TPythia8(const char* xmlDir); TPythia8(const TPythia8&); virtual~TPythia8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8.html:321,Integrability,interface,interface,321,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8.html:503,Integrability,interface,interface,503,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8.html:688,Integrability,interface,interface,688,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
https://root.cern/root/html528/TPythia8Decayer.html:1410,Availability,error,error,1410,"cayer&); virtual~TPythia8Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t pdg, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImpo",MatchSource.WIKI,root/html528/TPythia8Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8Decayer.html
https://root.cern/root/html528/TPythia8Decayer.html:1494,Availability,error,error,1494,"const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t pdg, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImportParticles(TClonesArray* particles); virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html528/TPythia8Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8Decayer.html
https://root.cern/root/html528/TPython.html:3351,Availability,avail,available,3351,"); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test w",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:1230,Modifiability,variab,variables,1230,"TPython. class TPython. Python interpreter access. The TPython class allows for access to python objects from CINT. The current; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObj",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:3159,Performance,load,load,3159,"oxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". v",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:291,Security,access,access,291,". TPython. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPython. class TPython. Python interpreter access. The TPython class allows for access to python objects from CINT. The current; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived typ",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:328,Security,access,access,328,". TPython. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPython. class TPython. Python interpreter access. The TPython class allows for access to python objects from CINT. The current; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived typ",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:1816,Security,access,access,1816,"rn what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPro",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TPython.html:3592,Testability,test,test,3592,"xy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test whether the type of the given pyobject is of ObjectProxy type or any; derived type. Bool_t ObjectProxy_CheckExact(PyObject* pyobject); Test whether the type of the given pyobject is ObjectProxy type. void* ObjectProxy_AsVoidPtr(PyObject* pyobject); Extract the object pointer ",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
https://root.cern/root/html528/TQApplication.html:4075,Availability,error,error,4075,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:4159,Availability,error,error,4159,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:4303,Availability,error,error,4303,"); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:8110,Availability,error,error,8110," const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCustomized(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApp",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:8231,Availability,error,error,8231,"ation::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCustomized(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); voidTA",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:11192,Availability,error,error,11192,"ol_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TAppl",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:12111,Availability,avail,available,12111,"; static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfCustomizedflag for customized canvas implimentation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQApplication(); Used by Dictionary(). TQApplication(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0); Create the root application and load the graphic libraries. ~TQApplication(); Delete ROOT application environment. void LoadGraphicsLibs(); Here we overload the LoadGraphicsLibs() function.; This function now just instantiates a QRootGuiFactory; object and redirect the global pointer gGuiFactory to point; to it. void SetCustomized(); Set the custom flag. » Author: Denis Bertini, M. Al-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last ",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQApplication.html:12471,Performance,load,load,12471," line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfCustomizedflag for customized canvas implimentation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQApplication(); Used by Dictionary(). TQApplication(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0); Create the root application and load the graphic libraries. ~TQApplication(); Delete ROOT application environment. void LoadGraphicsLibs(); Here we overload the LoadGraphicsLibs() function.; This function now just instantiates a QRootGuiFactory; object and redirect the global pointer gGuiFactory to point; to it. void SetCustomized(); Set the custom flag. » Author: Denis Bertini, M. Al-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
https://root.cern/root/html528/TQClass.html:5934,Availability,error,error,5934,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = ",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:6018,Availability,error,error,6018,":Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:1202,Energy Efficiency,power,powerfull,1202," class charts. ROOT; » CORE; » BASE; » TQClass. class TQClass: public TQObject, public TClass. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmembers, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0); virtual~TQClass(); voidTObject::AbstractMethod(const char* method) const; static voidTClass::AddClass(TClass* cl); voidTClass::AddImplFile(const char* filename, int line); voidTClass::AddInstance(Bool_t heap = kFALSE); voidTClass::AddRef(TClassRef* ref); static Bool_tTClass::AddRule(const char* rule); voidTClass::AdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidTClass::AdoptReferenceProxy(TVirtualRefProxy* proxy); voidTClass::AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidTClass::AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bo",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:7003,Performance,load,load,7003,"rams, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* datamember) const; Long_tTClass::GetDataMemberOffset(const char* membername) const; Short_tTClass::GetDeclFileLine() const; const char*TClass::GetDeclFileName() const; ROOT::DelFunc_tTClass::GetDelete() const; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static VoidFuncPtr_tTClass::GetDict(const char* cnam",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:7107,Performance,load,load,7107,"dTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* datamember) const; Long_tTClass::GetDataMemberOffset(const char* membername) const; Short_tTClass::GetDeclFileLine() const; const char*TClass::GetDeclFileName() const; ROOT::DelFunc_tTClass::GetDelete() const; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static VoidFuncPtr_tTClass::GetDict(const char* cname); static VoidFuncPtr_tTClass::GetDict(const type_info& info); ROOT::DirAutoAdd_tTClass::GetDirectoryAu",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:6312,Security,checksum,checksum,6312,"nal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetConte",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:6417,Security,checksum,checksum,6417," signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname,",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:6611,Security,checksum,checksum,6611,"dTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TC",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQClass.html:16263,Security,checksum,checksum,16263," virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tTClass::WriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; static THashTable*TClass::GetClassShortTypedefHash(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). private:. TQClass(const TClass&); TQClass&operator=(const TQClass&). Data Members; public:. enum TClass::[unnamed] { kClassSaved; kIgnoreTObjectStreamer; kUnloaded; kIsTObject; kIsForeign; kIsEmulation; kStartWithTObject; kWarned; kHasNameMapNode; };; enum TClass::ENewType { kRealNew; kClassNew; kDummyNew; };; enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie;",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
https://root.cern/root/html528/TQCommand.html:819,Availability,down,downwards,819,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:7707,Availability,error,error,7707,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*GetCommand(); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*GetName() const; Int_tGetNRargs() const; Int_tGetNUargs() const; void*GetObject() const;",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:7791,Availability,error,error,7791,":Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*GetCommand(); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*GetName() const; Int_tGetNRargs() const; Int_tGetNUargs() const; void*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TLi",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2187,Deployability,update,update,2187,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2241,Deployability,update,update,2241,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:21095,Modifiability,inherit,inheritied,21095,"st of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2741,Performance,perform,performing,2741,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* o",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:16430,Performance,cache,cache,16430,"ObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used f",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:20355,Testability,log,logical,20355,"TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo action",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:571,Usability,undo,undo,571,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:758,Usability,undo,undo,758,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:847,Usability,undo,undo,847,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1287,Usability,undo,undo,1287," CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1311,Usability,undo,undo,1311," based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macr",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1338,Usability,undo,undo,1338," based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macr",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1578,Usability,undo,undo,1578,"ges to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in firs",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1776,Usability,undo,undo,1776,"aversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register co",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1821,Usability,undo,undo,1821,"aversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register co",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:1860,Usability,undo,undo,1860,"and in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2039,Usability,undo,undo,2039,"h command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo t",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2139,Usability,undo,undo,2139,"_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Func",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2639,Usability,undo,undo,2639,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:2752,Usability,undo,undo,2752,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* o",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:3016,Usability,undo,undo,3016,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:3065,Usability,undo,undo,3065," commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* op",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:3247,Usability,undo,undo,3247,,MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:3340,Usability,undo,undo,3340,,MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:15507,Usability,undo,undo,15507,"eCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDele",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:16823,Usability,undo,undo,16823,"ObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used f",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:17041,Usability,undo,undo,17041,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:17338,Usability,undo,undoing,17338,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:17786,Usability,undo,undo,17786,"fNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:17929,Usability,undo,undo,17929,"gs)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRU",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18071,Usability,undo,undo,18071,"o action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQComman",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18100,Usability,undo,undo,18100,"o action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQComman",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18182,Usability,undo,undo,18182,"tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/und",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18240,Usability,undo,undo,18240,"tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/und",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18383,Usability,undo,undo,18383,"fStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18433,Usability,undo,undo,18433,"do(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18584,Usability,undo,undo,18584,"AllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) fr",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18701,Usability,undo,undo,18701,"nit(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18730,Usability,undo,undo,18730,"nit(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18797,Usability,undo,undo,18797," protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt""",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18932,Usability,undo,undo,18932,"tor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:18983,Usability,undo,undo,18983,"ame.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:19203,Usability,undo,undo,19203,"redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can un",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:19249,Usability,undo,undo,19249,"thod/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),;",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:19461,Usability,undo,undo,19461,"mitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:20175,Usability,undo,undo,20175,"tCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated comman",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:20649,Usability,undo,undo,20649,"t::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""se",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:21784,Usability,undo,undo,21784," setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are e",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:21978,Usability,undo,undo,21978,"ogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged co",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:22193,Usability,undo,undo,22193,"ol_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo c",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:22578,Usability,undo,undo,22578," ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs(number_of_params, params). Example:; move_command->SetRedoArgs(2, 100, 100);. void SetUndoArgs(Int_t narg, ...); Set undo parameters. The format is; SetUndoArgs(number_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; R",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23260,Usability,undo,undo,23260,"mber_of_params, params). Example:; move_command->SetUndoArgs(2, 200, 200);. Bool_t CanRedo() const; Returns kTRUE if Redo action is possible, kFALSE if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23410,Usability,undo,undo,23410," if it's not.; By default, only single sequential redo action is possible. Bool_t CanUndo() const; Returns kTRUE if Undo action is possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Opti",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23532,Usability,undo,undo,23532,"s possible, kFALSE if it's not.; By default, only single tial undo action is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23602,Usability,undo,undo,23602," is possible. void Redo(Option_t* option = """"); Execute command and then smerged commands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last genera",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23688,Usability,undo,undo,23688,"ommands. void Undo(Option_t* option = """"); Unexecute all merged commands and the command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQCommand.html:23771,Usability,undo,undo,23771,"command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
https://root.cern/root/html528/TQConnection.html:5037,Availability,error,error,5037,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteMethod(); voidExecuteMethod(Long_t param); voidExecuteMethod(Long64_t param); voidExecuteMethod(Double_t param); voidExecuteMethod(const char* params); voidExecuteMethod(Int_t nargs, va_list va); voidExecuteMethod(Long_t* params, Int_t nparam = -1); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); const char*GetClassName() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQConnection.html:5121,Availability,error,error,5121,":Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteMethod(); voidExecuteMethod(Long_t param); voidExecuteMethod(Long64_t param); voidExecuteMethod(Double_t param); voidExecuteMethod(const char* params); voidExecuteMethod(Int_t nargs, va_list va); voidExecuteMethod(Long_t* params, Int_t nparam = -1); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); const char*GetClassName() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQConnection.html:13991,Integrability,interface,interface,13991,"* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQConnection.html:15579,Modifiability,variab,variable,15579,"ame, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class and with method == funcname. TQConnection(const TQConnection& con); Copy constructor. Ignore connections to this TQConnections. ~TQConnection(); TQConnection dtor.; - remove this connection from all signal lists; - we do not delete fSlot if it has other connections,; TQSlot::fCounter > 0 . const char * GetName() const; Returns name of connection (aka name of slot). void Destroyed(); Signal Destroyed tells that connection is destroyed. void ls(Option_t* option = """") const; List TQConnection full method name and list all signals; connected to this connection. void PrintCollectionHeader(Option_t* option) const; Print TQConnection full method name and print all; signals connected to this connection. void ExecuteMethod(); Apply slot-method to the fReceiver object without arguments. void ExecuteMethod(Int_t nargs, va_list va); Apply slot-method to the fReceiver object with; variable argument list. void ExecuteMethod(Long_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long64_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Double_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long_t* params, Int_t nparam = -1); Apply slot-method to the fReceiver object with variable; number of argument values. void ExecuteMethod(const char* params); Apply slot-method to the fReceiver object and; with string parameter. void * GetReceiver() const; { return fReceiver; }. const char * GetClassName() const; { return fClassName; }. » Author: Valeriy Onuchin & Fons Rademakers 15/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQConnection.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatica",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQConnection.html:16024,Modifiability,variab,variable,16024," could be interpreted class and with method == funcname. TQConnection(const TQConnection& con); Copy constructor. Ignore connections to this TQConnections. ~TQConnection(); TQConnection dtor.; - remove this connection from all signal lists; - we do not delete fSlot if it has other connections,; TQSlot::fCounter > 0 . const char * GetName() const; Returns name of connection (aka name of slot). void Destroyed(); Signal Destroyed tells that connection is destroyed. void ls(Option_t* option = """") const; List TQConnection full method name and list all signals; connected to this connection. void PrintCollectionHeader(Option_t* option) const; Print TQConnection full method name and print all; signals connected to this connection. void ExecuteMethod(); Apply slot-method to the fReceiver object without arguments. void ExecuteMethod(Int_t nargs, va_list va); Apply slot-method to the fReceiver object with; variable argument list. void ExecuteMethod(Long_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long64_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Double_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long_t* params, Int_t nparam = -1); Apply slot-method to the fReceiver object with variable; number of argument values. void ExecuteMethod(const char* params); Apply slot-method to the fReceiver object and; with string parameter. void * GetReceiver() const; { return fReceiver; }. const char * GetClassName() const; { return fClassName; }. » Author: Valeriy Onuchin & Fons Rademakers 15/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQConnection.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQConnection.html:13350,Performance,cache,cache,13350,"* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
https://root.cern/root/html528/TQMimeTypes.html:1672,Availability,error,error,1672,"tMethod(const char* method) const; voidAddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const QIconSet*GetIcon(const char* filename) const; const QIconSet*GetIcon(const TSystemFile* filename); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type) const; virtual UInt_tTObject::GetUniqueID() const; virtu",MatchSource.WIKI,root/html528/TQMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQMimeTypes.html
https://root.cern/root/html528/TQMimeTypes.html:1756,Availability,error,error,1756,"nst char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const QIconSet*GetIcon(const char* filename) const; const QIconSet*GetIcon(const TSystemFile* filename); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type) const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasChanged() const; virtual ULon",MatchSource.WIKI,root/html528/TQMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQMimeTypes.html
https://root.cern/root/html528/TQMimeTypes.html:6248,Performance,cache,cache,6248,"irtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TQMime*Find(const char* filename) const; static const QPixmap&IconProvider(const QFileInfo&); voidTObject::MakeZombie(). private:. TQMimeTypes(const TQMimeTypes&); voidoperator=(const TQMimeTypes&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfChangedtrue if file has changed; TStringfFilenamefile name of mime type file; TStringfIconPaththe path to the icon directory; TOrdCollection*fListlist of mime types; static QFileIconProvider*fgDefaultProviderDefault provider of the system icons;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IconProvider(const QFileInfo& ). TQMimeTypes(const char* iconPath, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TQMimeTypes(); Delete mime type pool. TQMime * Find(const char* filename) const; Given a filename find the matching mime type object. const QIcon * GetIcon(const char* filename) const; Return icon belonging to mime type of filename. const QIcon * GetIcon(const TSystemFile* filename); Return icon belonging to mime type of TSystemFile extension. const QIcon * AddType(const TSystemFile* filename). Bool_t GetAction(const char* filename, char* action) const; Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type) const; Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list ",MatchSource.WIKI,root/html528/TQMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQMimeTypes.html
https://root.cern/root/html528/TQObject.html:4953,Availability,error,error,4953,"c Bool_tConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual void*GetSender(); virtual const char*GetSenderClassName() const. private:. TQObject(const TQObject& tqo); TQObject&operator=(const TQObject& tqo). Data Members; protected:. TList*fListOfConnections! list of connections to this object; TList*fListOfSignals! list of signals from this object; Bool_tfSignalsBlocked! flag used for suppression of signals; static Bool_tfgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name i",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:7665,Availability,error,error,7665,"f connections for this object. void Emit(const char* signal); Acitvate signal without args.; Example:; theButton->Emit(""Clicked()"");. void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; Example:; theButton->EmitVA(""Clicked(int,float)"", 2, id, fid). void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; For internal use and for var arg EmitVA() in RQ_OBJECT.h. void Emit(const char* signal, Long_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Clicked(int)"",id). void Emit(const char* signal, Long64_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Progress(Long64_t)"",processed). void Emit(const char* signal, Double_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Scale(float)"",factor). void Emit(const char* signal, const char* params); Activate signal with parameter text string.; Example:; myObject->Emit(""Error(char*)"",""Fatal error"");. void Emit(const char* signal, Long_t* paramArr); Emit a signal with a varying number of arguments,; paramArr is an array of the parameters.; Note: any parameter should be converted to long type.; Example:; TQObject *processor; // data processor; TH1F *hist; // filled with processor results. processor->Connect(""Evaluated(Float_t,Float_t)"",; ""TH1F"",hist,""Fill12(Axis_t,Axis_t)"");. Long_t args[2];; args[0] = (Long_t)processor->GetValue(1);; args[1] = (Long_t)processor->GetValue(2);. processor->Emit(""Evaluated(Float_t,Float_t)"",args);. Bool_t ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); Create connection between sender and receiver.; Receiver class needs to have a dictionary. Bool_t ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); This method allows to make connection from any object; of the same class to the receiver object.",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:1173,Energy Efficiency,power,powerfull,1173,"unction members; data members; class charts. ROOT; » CORE; » BASE; » TQObject. class TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQObject(); virtual~TQObject(); static Bool_tAreAllSignalsBlocked(); Bool_tAreSignalsBlocked() const; static Bool_tBlockAllSignals(Bool_t b); Bool_tBlockSignals(Bool_t b); virtual voidChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidCollectClassSignalLists(TList& list, TClass* cls); Bool_tConnect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidConnected(const char*); virtual voidDestroyed()SIGNAL ; Bool_tDisconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tDisconnect(TQObject* sender, ",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:5155,Energy Efficiency,allocate,allocated,5155,"gnal, TClass* receiver_class, void* receiver, const char* slot); virtual void*GetSender(); virtual const char*GetSenderClassName() const. private:. TQObject(const TQObject& tqo); TQObject&operator=(const TQObject& tqo). Data Members; protected:. TList*fListOfConnections! list of connections to this object; TList*fListOfSignals! list of signals from this object; Bool_tfSignalsBlocked! flag used for suppression of signals; static Bool_tfgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:6858,Modifiability,variab,variable,6858," time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals, this increase the time; for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed last when signal_name is emitted.; Signal name is not compressed. Bool_t HasConnection(const char* signal_name) const; Return true if there is any object connected to this signal.; Only checks for object signals. Int_t NumberOfSignals() const; Return number of signals for this object.; Only checks for object signals. Int_t NumberOfConnections() const; Return number of connections for this object. void Emit(const char* signal); Acitvate signal without args.; Example:; theButton->Emit(""Clicked()"");. void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; Example:; theButton->EmitVA(""Clicked(int,float)"", 2, id, fid). void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; For internal use and for var arg EmitVA() in RQ_OBJECT.h. void Emit(const char* signal, Long_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Clicked(int)"",id). void Emit(const char* signal, Long64_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Progress(Long64_t)"",processed). void Emit(const char* signal, Double_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Scale(float)"",factor). void Emit(const char* signal, const char* params); Activate signal with parameter text string.; Example:; myObject->Emit(""Error(char*)"",""Fatal error"");. void Emit(const char* signal, Long_t* paramArr); Emit a signal with a varying number of arguments,; paramArr is an array of the parameters.; Note: any para",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:7025,Modifiability,variab,variable,7025,"LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals, this increase the time; for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed last when signal_name is emitted.; Signal name is not compressed. Bool_t HasConnection(const char* signal_name) const; Return true if there is any object connected to this signal.; Only checks for object signals. Int_t NumberOfSignals() const; Return number of signals for this object.; Only checks for object signals. Int_t NumberOfConnections() const; Return number of connections for this object. void Emit(const char* signal); Acitvate signal without args.; Example:; theButton->Emit(""Clicked()"");. void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; Example:; theButton->EmitVA(""Clicked(int,float)"", 2, id, fid). void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; For internal use and for var arg EmitVA() in RQ_OBJECT.h. void Emit(const char* signal, Long_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Clicked(int)"",id). void Emit(const char* signal, Long64_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Progress(Long64_t)"",processed). void Emit(const char* signal, Double_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Scale(float)"",factor). void Emit(const char* signal, const char* params); Activate signal with parameter text string.; Example:; myObject->Emit(""Error(char*)"",""Fatal error"");. void Emit(const char* signal, Long_t* paramArr); Emit a signal with a varying number of arguments,; paramArr is an array of the parameters.; Note: any parameter should be converted to long type.; Example:; TQObject *processor; // data processor; TH1F *hist; // filled with processor results. processor->Connect(""Evaluated(",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObject.html:5586,Performance,perform,performed,5586,"ool_tfgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals, this increase the time; for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed last when signal_name is emitted.; Signal name is not compressed. Bool_t HasConnection(const char* signal_name) const; Return true if there is any object connected to this signal.; Only checks for object signals. Int_t NumberOfSignals() const; Return number of signals for this object.; Only checks for object signals. ",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
https://root.cern/root/html528/TQObjSender.html:1199,Energy Efficiency,power,powerfull,1199,"embers; class charts. ROOT; » CORE; » BASE; » TQObjSender. class TQObjSender: public TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQObjSender(); virtual~TQObjSender(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQOb",MatchSource.WIKI,root/html528/TQObjSender.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObjSender.html
https://root.cern/root/html528/TQpDataBase.html:915,Availability,avail,available,915,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataBase.html:2326,Availability,error,error,2326," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&GetiSlowerBound(); virtual TVectorD&GetiSupperBound(); virtual TVectorD&GetiXlowerBound(); virtual TVectorD&GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVectorD&GetSlowerBound(); virtual TVectorD&GetSupperBound(); virtual",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataBase.html:2410,Availability,error,error,2410,"l TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&GetiSlowerBound(); virtual TVectorD&GetiSupperBound(); virtual TVectorD&GetiXlowerBound(); virtual TVectorD&GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVectorD&GetSlowerBound(); virtual TVectorD&GetSupperBound(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; v",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataBase.html:7223,Modifiability,variab,variables,7223,"sgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidRandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDfBavector of equality constraint; TVectorDfCloBound; TVectorDfCloIndex; TVectorDfCupBoundInequality constraints; TVectorDfCupIndex; TVectorDfGlinear part of Objective function; Int_tfMy; Int_tfMz; Int_tfNx; TVectorDfXloBound; TVectorDfXloIndex; TVectorDfXupBoundBounds on variables; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound); Randomly choose x and its boundaries. TQpDataBase & operator=(const TQpDataBase& source); Assignment operator. virtual ~TQpDataBase(); {}. void PutQIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void PutAIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void PutCIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void Qmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x). void Amult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x). void Cmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x).",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataBase.html:423,Performance,perform,performing,423,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataBase.html:576,Performance,perform,performing,576,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
https://root.cern/root/html528/TQpDataDens.html:2074,Availability,error,error,2074," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html528/TQpDataDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataDens.html
https://root.cern/root/html528/TQpDataDens.html:2158,Availability,error,error,2158,"l TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVectorD&TQpDataBase::GetSlowerBound(); virtual TVectorD&TQpDataBase::GetSu",MatchSource.WIKI,root/html528/TQpDataDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataDens.html
https://root.cern/root/html528/TQpDataDens.html:7258,Modifiability,variab,variables,7258," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidTQpDataBase::RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDTQpDataBase::fBavector of equality constraint; TVectorDTQpDataBase::fCloBound; TVectorDTQpDataBase::fCloIndex; TVectorDTQpDataBase::fCupBoundInequality constraints; TVectorDTQpDataBase::fCupIndex; TVectorDTQpDataBase::fGlinear part of Objective function; Int_tTQpDataBase::fMy; Int_tTQpDataBase::fMz; Int_tTQpDataBase::fNx; TVectorDTQpDataBase::fXloBound; TVectorDTQpDataBase::fXloIndex; TVectorDTQpDataBase::fXupBoundBounds on variables; TVectorDTQpDataBase::fXupIndex. protected:. TMatrixDfAEquality constraints; TMatrixDfCInequality constraints; TMatrixDSymfQQuadratic part of Objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpDataDens(Int_t nx, Int_t my, Int_t mz); Constructor. TQpDataDens(TVectorD& c, TMatrixDSym& Q, TVectorD& xlow, TVectorD& ixlow, TVectorD& xupp, TVectorD& ixupp, TMatrixD& A, TVectorD& bA, TMatrixD& C, TVectorD& clow, TVectorD& iclow, TVectorD& cupp, TVectorD& icupp); Constructor. TQpDataDens(const TQpDataDens& another); Copy constructor. void Qmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); calculate y = beta*y + alpha*(fQ*x). void Amult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); calculate y",MatchSource.WIKI,root/html528/TQpDataDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataDens.html
https://root.cern/root/html528/TQpDataSparse.html:2110,Availability,error,error,2110," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html528/TQpDataSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataSparse.html
https://root.cern/root/html528/TQpDataSparse.html:2194,Availability,error,error,2194,"l TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TVectorD&TQpDataBase::GetSlowerBound(); virtual TVectorD&TQpDataBase::GetSu",MatchSource.WIKI,root/html528/TQpDataSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataSparse.html
https://root.cern/root/html528/TQpDataSparse.html:7351,Modifiability,variab,variables,7351," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidTQpDataBase::RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDTQpDataBase::fBavector of equality constraint; TVectorDTQpDataBase::fCloBound; TVectorDTQpDataBase::fCloIndex; TVectorDTQpDataBase::fCupBoundInequality constraints; TVectorDTQpDataBase::fCupIndex; TVectorDTQpDataBase::fGlinear part of Objective function; Int_tTQpDataBase::fMy; Int_tTQpDataBase::fMz; Int_tTQpDataBase::fNx; TVectorDTQpDataBase::fXloBound; TVectorDTQpDataBase::fXloIndex; TVectorDTQpDataBase::fXupBoundBounds on variables; TVectorDTQpDataBase::fXupIndex. protected:. TMatrixDSparsefAEquality constraints; TMatrixDSparsefCInequality constraints; TMatrixDSparsefQquadratic part of Objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpDataSparse(Int_t nx, Int_t my, Int_t mz); Constructor. TQpDataSparse(TVectorD& c, TMatrixDSparse& Q, TVectorD& xlow, TVectorD& ixlow, TVectorD& xupp, TVectorD& ixupp, TMatrixDSparse& A, TVectorD& bA, TMatrixDSparse& C, TVectorD& clow, TVectorD& iclow, TVectorD& cupp, TVectorD& icupp); Constructor. TQpDataSparse(const TQpDataSparse& another); Copy constructor. void SetNonZeros(Int_t nnzQ, Int_t nnzA, Int_t nnzC); Allocate space for the appropriate number of non-zeros in the matrices. void Qmult(Double_t beta, TVectorD",MatchSource.WIKI,root/html528/TQpDataSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataSparse.html
https://root.cern/root/html528/TQpLinSolverBase.html:512,Availability,avail,available,512,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char*",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:1663,Availability,error,error,1663,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:1747,Availability,error,error,1747,"irtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:7330,Availability,recover,recovers,7330,"und vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:6694,Integrability,rout,routine,6694,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD&",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:6997,Modifiability,variab,variables,6997,"ie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middl",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:6679,Performance,perform,performed,6679,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD&",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:8489,Performance,perform,perform,8489," to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment opeartor. virtual ~TQpLinSolverBase(); {}. void SolveCompressed(TVectorD& rhs); assemble right-hand side of augmented system and call; SolveCompressed to solve it. void PutXDiagonal(TVectorD& xdiag); perform the actual solve using the factors produced in; factor.; rhs on input contains the aggregated right-hand side of; the augmented system; on output contains the solution in; aggregated form. void PutZDiagonal(TVectorD& zdiag); places the diagonal resulting from the bounds on x into; the augmented system matrix. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-10-03 18:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverBase.html:7330,Safety,recover,recovers,7330,"und vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
https://root.cern/root/html528/TQpLinSolverDens.html:1748,Availability,error,error,1748,"virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html528/TQpLinSolverDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverDens.html
https://root.cern/root/html528/TQpLinSolverDens.html:1832,Availability,error,error,1832,"TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html528/TQpLinSolverDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverDens.html
https://root.cern/root/html528/TQpLinSolverSparse.html:1770,Availability,error,error,1770,"virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html528/TQpLinSolverSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverSparse.html
https://root.cern/root/html528/TQpLinSolverSparse.html:1854,Availability,error,error,1854,"TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html528/TQpLinSolverSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverSparse.html
https://root.cern/root/html528/TQpProbBase.html:578,Availability,avail,available,578,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html528/TQpProbBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbBase.html
https://root.cern/root/html528/TQpProbBase.html:1547,Availability,error,error,1547," virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html528/TQpProbBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbBase.html
https://root.cern/root/html528/TQpProbBase.html:1631,Availability,error,error,1631," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TQpProbBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbBase.html
https://root.cern/root/html528/TQpProbDens.html:1417,Availability,error,error,1417,"robDens& another); TQpProbDens(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbDens(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TQpProbDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbDens.html
https://root.cern/root/html528/TQpProbDens.html:1501,Availability,error,error,1501," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TQpProbDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbDens.html
https://root.cern/root/html528/TQpProbDens.html:6969,Modifiability,variab,variables,6969,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tTQpProbBase::fMynumber of rows in A and b; Int_tTQpProbBase::fMznumber of rows in C; Int_tTQpProbBase::fNxnumber of elements in x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpProbDens(Int_t nx, Int_t my, Int_t mz); Constructor. TQpProbDens(const TQpProbDens& another); Copy constructor. TQpDataBase * MakeData(Double_t* c, Double_t* Q, Double_t* xlo, Bool_t* ixlo, Double_t* xup, Bool_t* ixup, Double_t* A, Double_t* bA, Double_t* C, Double_t* clo, Bool_t* iclo, Double_t* cup, Bool_t* icup); Setup the data. TQpDataBase * MakeData(TVectorD& c, TMatrixDBase& Q_in, TVectorD& xlo, TVectorD& ixlo, TVectorD& xup, TVectorD& ixup, TMatrixDBase& A_in, TVectorD& bA, TMatrixDBase& C_in, TVectorD& clo, TVectorD& iclo, TVectorD& cup, TVectorD& icup); Setup the data. TQpResidual* MakeResiduals(const TQpDataBase* data); Setup the residuals. TQpVar* MakeVariables(const TQpDataBase* data); Setup the variables. TQpLinSolverBase* MakeLinSys(const TQpDataBase* data); Setup the linear solver. void JoinRHS(TVectorD& rhs_in, TVectorD& rhs1_in, TVectorD& rhs2_in, TVectorD& rhs3_in); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& x_in, TVectorD& y_in, TVectorD& z_in, TVectorD& vars_in); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. void MakeRandomData(TQpDataDens*& data, TQpVar*& soln, Int_t nnzQ, Int_t nnzA, Int_t nnzC); Create a random QP problem. TQpProbDens & operator=(const TQpProbDens& source); Assignment operator. TQpProbDens(); {}. virtual ~TQpProbDens(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, R",MatchSource.WIKI,root/html528/TQpProbDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbDens.html
https://root.cern/root/html528/TQpProbSparse.html:1435,Availability,error,error,1435,"rse& another); TQpProbSparse(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbSparse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TQpProbSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbSparse.html
https://root.cern/root/html528/TQpProbSparse.html:1519,Availability,error,error,1519," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TQpProbSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbSparse.html
https://root.cern/root/html528/TQpProbSparse.html:6643,Modifiability,variab,variables,6643,"leanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tTQpProbBase::fMynumber of rows in A and b; Int_tTQpProbBase::fMznumber of rows in C; Int_tTQpProbBase::fNxnumber of elements in x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpProbSparse(Int_t nx, Int_t my, Int_t mz); Constructor. TQpProbSparse(const TQpProbSparse& another); Copy constructor. TQpDataBase * MakeData(Double_t *c, Int_t nnzQ,Int_t *irowQ,Int_t *icolQ,Double_t *Q, Double_t *xlo,Bool_t *ixlo, Double_t *xup,Bool_t *ixup, Int_t nnzA,Int_t *irowA,Int_t *icolA,Double_t *A, Double_t *bA, Int_t nnzC,Int_t *irowC,Int_t *icolC,Double_t *C, Double_t *clo,Bool_t *iclo, Double_t *cup,Bool_t *icup); Setup the data. TQpResidual* MakeResiduals(const TQpDataBase* data); Setup the residuals. TQpVar* MakeVariables(const TQpDataBase* data); Setup the variables. TQpLinSolverBase* MakeLinSys(const TQpDataBase* data); Setup the linear solver. void JoinRHS(TVectorD& rhs_in, TVectorD& rhs1_in, TVectorD& rhs2_in, TVectorD& rhs3_in); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& x_in, TVectorD& y_in, TVectorD& z_in, TVectorD& vars_in); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. void MakeRandomData(TQpDataSparse*& data, TQpVar*& soln, Int_t nnzQ, Int_t nnzA, Int_t nnzC); Create a random QP problem. TQpProbSparse & operator=(const TQpProbSparse& source); Assignment operator. TQpProbSparse(); {}. virtual ~TQpProbSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 19",MatchSource.WIKI,root/html528/TQpProbSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbSparse.html
https://root.cern/root/html528/TQpResidual.html:1952,Availability,error,error,1952,"t; voidAdd_r3_xz_alpha(TQpVar* vars, Double_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcResids(TQpDataBase* problem, TQpVar* vars); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClear_r1r2(); voidClear_r3(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetDualityGap(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetResidualNorm(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bo",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
https://root.cern/root/html528/TQpResidual.html:2036,Availability,error,error,2036,"(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcResids(TQpDataBase* problem, TQpVar* vars); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClear_r1r2(); voidClear_r3(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetDualityGap(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetResidualNorm(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inher",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
https://root.cern/root/html528/TQpResidual.html:6858,Modifiability,variab,variable,6858,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDfRA; TVectorDfRC; TVectorDfRQ; TVectorDfRgamma; TVectorDfRlambda; TVectorDfRphi; TVectorDfRpi; TVectorDfRt; TVectorDfRu; TVectorDfRv; TVectorDfRw; TVectorDfRz. protected:. TVectorDfCloIndex; TVectorDfCupIndex; Double_tfDualityGapA quantity that measures progress toward feasibility. In terms; Double_tfMclo; Double_tfMcup; Int_tfMy; Int_tfMz; Int_tfNx; Double_tfNxlo; Double_tfNxup; Double_tfResidualNormThe norm of the residuals, ommiting the complementariy conditions; TVectorDfXloIndex; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpResidual(); Constructor. TQpResidual(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is l",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
https://root.cern/root/html528/TQpResidual.html:7035,Modifiability,variab,variables,7035,"ctorDfRphi; TVectorDfRpi; TVectorDfRt; TVectorDfRu; TVectorDfRv; TVectorDfRw; TVectorDfRz. protected:. TVectorDfCloIndex; TVectorDfCupIndex; Double_tfDualityGapA quantity that measures progress toward feasibility. In terms; Double_tfMclo; Double_tfMcup; Int_tfMy; Int_tfMz; Int_tfNx; Double_tfNxlo; Double_tfNxup; Double_tfResidualNormThe norm of the residuals, ommiting the complementariy conditions; TVectorDfXloIndex; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpResidual(); Constructor. TQpResidual(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
https://root.cern/root/html528/TQpResidual.html:7233,Modifiability,variab,variables,7233,"rd feasibility. In terms; Double_tfMclo; Double_tfMcup; Int_tfMy; Int_tfMz; Int_tfNx; Double_tfNxlo; Double_tfNxup; Double_tfResidualNormThe norm of the residuals, ommiting the complementariy conditions; TVectorDfXloIndex; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpResidual(); Constructor. TQpResidual(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is less than -rmax, replace it by -rmax. Bool_t ValidNonZeroPattern(); Check if vector elements as selected through array indices are non-zero. void GondzioProjection(TVectorD& v, Double_t rmin, Double_t rmax); Replace each component r3_i of the complementarity component of the residuals; by r3p_i-r3_i, where r3p_i is the projection of r3_i onto the box [rmin, rmax].; Then if the ",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
https://root.cern/root/html528/TQpSolverBase.html:721,Availability,avail,available,721,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:2497,Availability,error,error,2497,", TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*GetLinearSystem(); Double_tGetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:2581,Availability,error,error,2581,"* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*GetLinearSystem(); Double_tGetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:7876,Availability,robust,robustness,7876,"mma_fparameters associated with the step length heuristic; Int_tfMaxitmaximum number of iterations allowed; Double_t*fMu_history[fMaxit] history of values of mu obtained on all iterations to date; Double_tfMutoltermination parameters; Double_tfPhimerit function, defined as the sum of the complementarity gap; Double_t*fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Double_t*fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpLinSolverBase*fSys. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TQpSolverBase(); Deconstructor. void Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Implements a default starting-point heuristic. While interior-point theory; places fairly loose restrictions on the choice of starting point, the choice; of heuristic can significantly affect the robustness and efficiency of the; algorithm. void DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Default starting point. void SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, I",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:352,Energy Efficiency,monitor,monitoring,352,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:9836,Energy Efficiency,monitor,monitor,9836,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:9096,Integrability,rout,routine,9096,"b, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t a",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:8397,Modifiability,variab,variables,8397,"alues of residual norm obtained on all iterations to date; TQpLinSolverBase*fSys. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TQpSolverBase(); Deconstructor. void Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Implements a default starting-point heuristic. While interior-point theory; places fairly loose restrictions on the choice of starting point, the choice; of heuristic can significantly affect the robustness and efficiency of the; algorithm. void DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Default starting point. void SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & oper",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:8492,Modifiability,variab,variables,8492,"alues of residual norm obtained on all iterations to date; TQpLinSolverBase*fSys. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TQpSolverBase(); Deconstructor. void Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Implements a default starting-point heuristic. While interior-point theory; places fairly loose restrictions on the choice of starting point, the choice; of heuristic can significantly affect the robustness and efficiency of the; algorithm. void DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Default starting point. void SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & oper",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:8688,Modifiability,variab,variables,8688,"on, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Implements a default starting-point heuristic. While interior-point theory; places fairly loose restrictions on the choice of starting point, the choice; of heuristic can significantly affect the robustness and efficiency of the; algorithm. void DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Default starting point. void SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:9558,Modifiability,variab,variables,9558,"terate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:9654,Modifiability,variab,variables,9654,"terate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpSolverBase.html:9828,Performance,perform,perform,9828,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
https://root.cern/root/html528/TQpVar.html:1749,Availability,error,error,1749,"w_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); virtual~TQpVar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Double_tGetMu(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* time",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:1833,Availability,error,error,1833," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Double_tGetMu(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* meth",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:301,Modifiability,variab,variables,301,". TQpVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpVar. class TQpVar: public TObject. Class containing the variables for the general QP formulation. Function Members (Methods); public:. TQpVar(); TQpVar(const TQpVar& another); TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); TQpVar(TVectorD& x_in, TVectorD& s_in, TVectorD& y_in, TVectorD& z_in, TVectorD& v_in, TVectorD& gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); virtual~TQpVar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:6809,Modifiability,variab,variables,6809,"TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); static Double_tFindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); voidTObject::MakeZombie(); static Double_tStepBound(TVectorD& v, TVectorD& dir, Double_t maxStep). Data Members; public:. enum EVarBlock { kno_block; kt_block; klambda_block; ku_block; kpi_block; kv_block; kgamma_block; kw_block; kphi_block; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDfGamma; TVectorDfLambda; Int_tfNComplementaryVariablesnumber of complementary primal-dual variables.; TVectorDfPhi; TVectorDfPi; TVectorDfS; TVectorDfT; TVectorDfU; TVectorDfV; TVectorDfW; TVectorDfX; TVectorDfY; TVectorDfZ. protected:. TVectorDfCloIndex; TVectorDfCupIndex; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; Int_tfNx; Int_tfNxlo; Int_tfNxup; TVectorDfXloIndex; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpVar(); Default constructor. TQpVar(TVectorD& x_in, TVectorD& s_in, TVectorD& y_in, TVectorD& z_in, TVectorD& v_in, TVectorD& gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); Constructor. TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpVar(const TQpVar& another); Copy constructor. Double_t GetMu(); compute complementarity gap, obtained by t",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:8359,Modifiability,variab,variables,8359,"VectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); Constructor. TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpVar(const TQpVar& another); Copy constructor. Double_t GetMu(); compute complementarity gap, obtained by taking the inner product of the; complementary vectors and dividing by the total number of components; computes mu = (t'lambda +u'pi + v'gamma + w'phi)/(mclow+mcupp+nxlow+nxupp). Double_t MuStep(TQpVar* step, Double_t alpha); Compute the complementarity gap resulting from a step of length ""alpha"" along; direction ""step"". void Saxpy(TQpVar* b, Double_t alpha); Perform a ""saxpy"" operation on all data vectors : x += alpha*y. void Negate(); Perform a ""negate"" operation on all data vectors : x = -x. Double_t StepBound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the c",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:9103,Modifiability,variab,variables,9103,"ute the complementarity gap resulting from a step of length ""alpha"" along; direction ""step"". void Saxpy(TQpVar* b, Double_t alpha); Perform a ""saxpy"" operation on all data vectors : x += alpha*y. void Negate(); Perform a ""negate"" operation on all data vectors : x = -x. Double_t StepBound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:9300,Modifiability,variab,variables,9300,"Bound(TQpVar* b); calculate the largest alpha in (0,1] such that the/ nonnegative variables stay; nonnegative in the given search direction. In the general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlock",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:9405,Modifiability,variab,variables,9405,"general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlocking function. void InteriorPoint(Double_t alpha, Double_t beta); Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. Double_",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:9498,Modifiability,variab,variables,9498,"general QP problem formulation; this is the largest value of alpha such that; (t,u,v,w,lambda,pi,phi,gamma) + alpha * (b->t,b->u,b->v,b->w,b->lambda,b->pi,; b->phi,b->gamma) >= 0. Double_t StepBound(TVectorD& v, TVectorD& dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlocking function. void InteriorPoint(Double_t alpha, Double_t beta); Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. Double_",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:9612,Modifiability,variab,variables,9612,"dir, Double_t maxStep); Find the maximum stepsize of v in direction dir; before violating the nonnegativity constraints. Bool_t IsInteriorPoint(); Is the current position an interior point ?. Double_t FindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); Performs the same function as StepBound, and supplies additional information about; which component of the nonnegative variables is responsible for restricting alpha.; In terms of the abstract formulation, the components have the following meanings :. primalValue : the value of the blocking component of the primal variables (u,t,v,w).; primalStep : the corresponding value of the blocking component of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlocking function. void InteriorPoint(Double_t alpha, Double_t beta); Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. Double_t Violation(); The amount by which the current variables violate the non-negativity constraints. void ShiftBoundVariables(Double_t alpha, Double_t beta); Add alpha to components of (u,t,v,w) and beta to components of (lam",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:10473,Modifiability,variab,variables,10473,"ponent of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlocking function. void InteriorPoint(Double_t alpha, Double_t beta); Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. Double_t Violation(); The amount by which the current variables violate the non-negativity constraints. void ShiftBoundVariables(Double_t alpha, Double_t beta); Add alpha to components of (u,t,v,w) and beta to components of (lambda,pi,phi,gamma). void Print(Option_t* option = """") const; Print class members. Double_t Norm1(); Return the sum of the vector-norm1's. Double_t NormInf(); Return the sum of the vector-normInf's. Bool_t ValidNonZeroPattern(); Check that the variables conform to the non-zero indices. TQpVar & operator=(const TQpVar& source); Assignment operator. virtual ~TQpVar(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpVar.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQpVar.html:10889,Modifiability,variab,variables,10889,"ponent of the primal step; variables (b->u,b->t,b->v,b->w); dualValue : the value of the blocking component of the dual variables; (lambda,pi,phi,gamma).; dualStep : the corresponding value of the blocking component of the dual step; variables (b->lambda,b->pi,b->phi,b->gamma); firstOrSecond : 1 if the primal step is blocking,; 2 if the dual step is block,; 0 if no step is blocking. Double_t FindBlocking(TVectorD& w, TVectorD& wstep, TVectorD& u, TVectorD& ustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, int& first_or_second); See other FindBlocking function. Double_t FindBlockingSub(Int_t n, Double_t* w, Int_t incw, Double_t* wstep, Int_t incwstep, Double_t* u, Int_t incu, Double_t* ustep, Int_t incustep, Double_t maxStep, Double_t& w_elt, Double_t& wstep_elt, Double_t& u_elt, Double_t& ustep_elt, Int_t& first_or_second); See FindBlocking function. void InteriorPoint(Double_t alpha, Double_t beta); Sets components of (u,t,v,w) to alpha and of (lambda,pi,phi,gamma) to beta. Double_t Violation(); The amount by which the current variables violate the non-negativity constraints. void ShiftBoundVariables(Double_t alpha, Double_t beta); Add alpha to components of (u,t,v,w) and beta to components of (lambda,pi,phi,gamma). void Print(Option_t* option = """") const; Print class members. Double_t Norm1(); Return the sum of the vector-norm1's. Double_t NormInf(); Return the sum of the vector-normInf's. Bool_t ValidNonZeroPattern(); Check that the variables conform to the non-zero indices. TQpVar & operator=(const TQpVar& source); Assignment operator. virtual ~TQpVar(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpVar.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
https://root.cern/root/html528/TQRootApplication.html:1249,Availability,error,error,1249,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQRootApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootApplication.html
https://root.cern/root/html528/TQRootCanvas.html:4337,Deployability,release,release,4337,"eMoveEvent(QMouseEvent* e); virtual voidmousePressEvent(QMouseEvent* e); virtual voidmouseReleaseEvent(QMouseEvent* e); virtual voidpaintEvent(QPaintEvent* e); virtual voidresizeEvent(QResizeEvent* e). private:. TQRootCanvas(const TQRootCanvas&); TQRootCanvas&operator=(const TQRootCanvas&). Data Members; protected:. TCanvas*fCanvasRoot Canvas; TQCanvasMenu*fContextMenuQt Context menu for this canvas; Bool_tfIsCanvasOwnedOwnership flag; Bool_tfNeedResizeResize flag; QWidget*fParent; QWidget*fTabWinparent widgets; Int_tfWidWindows Id of the Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:4828,Integrability,wrap,wrapper,4828,"bWinparent widgets; Int_tfWidWindows Id of the Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtual",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:4870,Integrability,wrap,wrapper,4870," Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:4921,Integrability,wrap,wrapper,4921,"Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:4972,Integrability,wrap,wrapper,4972,"n; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5022,Integrability,wrap,wrapper,5022,"me = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a w",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5082,Integrability,wrap,wrapper,5082,"dget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t G",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5124,Integrability,wrap,wrapper,5124,", TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID();",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5158,Integrability,wrap,wrapper,5158,"mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX()",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5230,Integrability,wrap,wrapper,5230,"nt. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapp",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5277,Integrability,wrap,wrapper,5277,"on press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindo",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5307,Integrability,wrap,wrapper,5307,"QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetW",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5347,Integrability,wrap,wrapper,5347,"n release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh()",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5383,Integrability,wrap,wrapper,5383,"Event(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(In",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5426,Integrability,wrap,wrapper,5426,"ble click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UI",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5475,Integrability,wrap,wrapper,5475,"* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EE",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5516,Integrability,wrap,wrapper,5516," Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wr",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5550,Integrability,wrap,wrapper,5550,"e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wr",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5585,Integrability,wrap,wrapper,5585," leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapp",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5620,Integrability,wrap,wrapper,5620,"e event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrappe",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5665,Integrability,wrap,wrapper,5665,"vent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5709,Integrability,wrap,wrapper,5709,"nt(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapp",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5750,Integrability,wrap,wrapper,5750,"ow only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5795,Integrability,wrap,wrapper,5795,"roping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrap",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5843,Integrability,wrap,wrapper,5843," wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5888,Integrability,wrap,wrapper,5888,"pper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapp",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5926,Integrability,wrap,wrapper,5926,"ust a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjL",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:5965,Integrability,wrap,wrapper,5965,"tion = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6004,Integrability,wrap,wrapper,6004,"ption_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevS",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6043,Integrability,wrap,wrapper,6043,"TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Opt",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6082,Integrability,wrap,wrapper,6082,"""""); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. vo",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6119,Integrability,wrap,wrapper,6119,"nePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6158,Integrability,wrap,wrapper,6158,"r(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6197,Integrability,wrap,wrapper,6197,"ad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6238,Integrability,wrap,wrapper,6238,"st a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor c",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6280,Integrability,wrap,wrapper,6280,"); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuf",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6312,Integrability,wrap,wrapper,6312," a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6344,Integrability,wrap,wrapper,6344,"(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6431,Integrability,wrap,wrapper,6431,"st char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6502,Integrability,wrap,wrapper,6502," wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrappe",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6539,Integrability,wrap,wrapper,6539,"_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6571,Integrability,wrap,wrapper,6571,"t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6605,Integrability,wrap,wrapper,6605,"t_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedP",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6642,Integrability,wrap,wrapper,6642,"lor_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6690,Integrability,wrap,wrapper,6690,"TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6738,Integrability,wrap,wrapper,6738,"ect * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wr",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6777,Integrability,wrap,wrapper,6777,"_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6818,Integrability,wrap,wrapper,6818,"VirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6869,Integrability,wrap,wrapper,6869," Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTit",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:6938,Integrability,wrap,wrapper,6938,"Exec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEvent",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7008,Integrability,wrap,wrapper,7008,"GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7060,Integrability,wrap,wrapper,7060," wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); C",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7110,Integrability,wrap,wrapper,7110,"t_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQR",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7193,Integrability,wrap,wrapper,7193,"rapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanva",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7241,Integrability,wrap,wrapper,7241,"th(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7295,Integrability,wrap,wrapper,7295,"t a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvas",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7353,Integrability,wrap,wrapper,7353,"h(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWid",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7411,Integrability,wrap,wrapper,7411,"& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize()",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7469,Integrability,wrap,wrapper,7469,"dleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7522,Integrability,wrap,wrapper,7522,"rapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7570,Integrability,wrap,wrapper,7570,"conify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/200",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7618,Integrability,wrap,wrapper,7618," a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7647,Integrability,wrap,wrapper,7647,"a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtg",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7720,Integrability,wrap,wrapper,7720,"rapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7773,Integrability,wrap,wrapper,7773,"OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been aut",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7832,Integrability,wrap,wrapper,7832," just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7887,Integrability,wrap,wrapper,7887,"a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7929,Integrability,wrap,wrapper,7929,"k(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7968,Integrability,wrap,wrapper,7968,"k(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootCanvas.html:7999,Integrability,wrap,wrapper,7999,"k(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
https://root.cern/root/html528/TQRootGuiFactory.html:2593,Availability,error,error,2593,"teCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*TRootGuiFactory::CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TQRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootGuiFactory.html
https://root.cern/root/html528/TQRootGuiFactory.html:2677,Availability,error,error,2677,"ight); virtual TContextMenuImp*TRootGuiFactory::CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html528/TQRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootGuiFactory.html
https://root.cern/root/html528/TQtApplication.html:1476,Modifiability,variab,variable,1476,"Instantiate the Qt system within ROOT environment. Instantiate the Qt package by createing Qapplication object if any. Function Members (Methods); public:. TQtApplication(); TQtApplication(const char* appClassName, int& argc, char** argv); virtual~TQtApplication(); static TClass*Class(); static TQtApplication*GetQtApplication(); virtual TClass*IsA() const; static boolIsThisGuiThread(); static Int_tQtVersion(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static boolTerminate(). private:. TQtApplication(const TQtApplication&); voidCreateGUIThread(int& argc, char** argv); static voidCreateQApplication(int& argc, char** argv, bool GUIenabled); voidoperator=(const TQtApplication&). Data Members; protected:. static TQtApplication*fgQtApplication. private:. TQtApplicationThread*fGUIThread. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQtApplication(const char* appClassName, int& argc, char** argv). ~TQtApplication(). { }. void CreateQApplication(int& argc, char** argv, bool GUIenabled); Initialize the Qt package; Check the QT_BATCH environment variable to disactivate Qt GUI mode. void CreateGUIThread(int& argc, char** argv); Create GUI thread to Qt event loop. TQtApplication * GetQtApplication(). {return fgQtApplication;}. bool Terminate(); Terminate GUI thread. Int_t QtVersion(); The Qt version the package was compiled with. bool IsThisGuiThread(); Check whether the current thread belongs the GUI. void operator=(const TQtApplication& ). TQtApplication(const TQtApplication& ). TQtApplication(); {}. » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TQtApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQtApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtApplication.html
https://root.cern/root/html528/TQtClientFilter.html:425,Deployability,install,installEventFilter,425,". TQtClientFilter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TQtClientFilter. class TQtClientFilter: public QObject. QtClientFilter provides QOject event filter to map Qt and ROOT events; (see: http://doc.trolltech.com/4.3/qobject.html#installEventFilter ). Function Members (Methods); public:. TQtClientFilter(); virtual~TQtClientFilter(); voidAppendButtonGrab(TQtClientWidget*); static TClass*Class(); static TQtClientWidget*GetButtonGrabber(); static TQtClientWidget*GetPointerGrabber(); static voidGrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); virtual TClass*IsA() const; static TQtPointerGrabber*PointerGrabber(); voidRemoveButtonGrab(QObject*); static voidSetButtonGrabber(TQtClientWidget* grabber); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidAddKeyEvent(const int& event, TQtClientWidget* widget); booleventFilter(QObject* o, QEvent* e); static Bool_tIsGrabSelected(UInt_t selectEventMask); TQtEventQueue*Queue(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Clas",MatchSource.WIKI,root/html528/TQtClientFilter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html
https://root.cern/root/html528/TQtClientFilter.html:2300,Performance,queue,queue,2300,"(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const int& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt KeyBoard event mapped to the ROOT Event_t; For ""dest"" widget. bool SelectGrab(Event_t& event, UInt_t selectEventMask, int& me); Select Event: -- 04.12.2005 --. bool eventFilter(QObject* o, QEvent* e); Dispatch The Qt event from event queue to Event_t structure; Not all of the event fields are valid for each event type,; except fType and fWindow. void GrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); Set the X11 style active grabbing for ROOT TG widgets. TQtPointerGrabber * PointerGrabber(); { return fgGrabber; }. TQtClientWidget * GetPointerGrabber(); { return fgPointerGrabber; }. TQtClientWidget * GetButtonGrabber(); { return fgButtonGrabber; }. void SetButtonGrabber(TQtClientWidget* grabber); { fgButtonGrabber = grabber; }. void AppendButtonGrab(TQtClientWidget* ); { fButtonGrabList.append(widget); }. void RemoveButtonGrab(QObject* ). TQtEventQueue * Queue(). void operator=(co",MatchSource.WIKI,root/html528/TQtClientFilter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html
https://root.cern/root/html528/TQtClientFilter.html:2543,Performance,queue,queue,2543,"r=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const int& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt KeyBoard event mapped to the ROOT Event_t; For ""dest"" widget. bool SelectGrab(Event_t& event, UInt_t selectEventMask, int& me); Select Event: -- 04.12.2005 --. bool eventFilter(QObject* o, QEvent* e); Dispatch The Qt event from event queue to Event_t structure; Not all of the event fields are valid for each event type,; except fType and fWindow. void GrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); Set the X11 style active grabbing for ROOT TG widgets. TQtPointerGrabber * PointerGrabber(); { return fgGrabber; }. TQtClientWidget * GetPointerGrabber(); { return fgPointerGrabber; }. TQtClientWidget * GetButtonGrabber(); { return fgButtonGrabber; }. void SetButtonGrabber(TQtClientWidget* grabber); { fgButtonGrabber = grabber; }. void AppendButtonGrab(TQtClientWidget* ); { fButtonGrabList.append(widget); }. void RemoveButtonGrab(QObject* ). TQtEventQueue * Queue(). void operator=(const TQtClientFilter& ). TQtClientFilter(const TQtClientFilter& ). void SetKeyGrabber(TQtClientWidget* grabber); { fKeyGrabber = grabber;}. void UnSetKeyGrabber(TQtClientWidget* grabber); { if (fKeyGrabber == grabber) fKeyGrabber = 0; }. void RestoreLostGrabbing(Event_t& ev",MatchSource.WIKI,root/html528/TQtClientFilter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html
https://root.cern/root/html528/TQtClientWidget.html:2557,Availability,mask,mask,2557,", UInt_t modifier = kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root/html528/TQtClientWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientWidget.html
https://root.cern/root/html528/TQtClientWidget.html:2627,Availability,mask,mask,2627,", UInt_t modifier = kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root/html528/TQtClientWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientWidget.html
https://root.cern/root/html528/TQtClientWidget.html:2698,Availability,mask,mask,2698,", UInt_t modifier = kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root/html528/TQtClientWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientWidget.html
https://root.cern/root/html528/TQtClientWidget.html:3010,Availability,mask,mask,3010,", UInt_t modifier = kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root/html528/TQtClientWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientWidget.html
https://root.cern/root/html528/TQtRootGuiFactory.html:2706,Availability,error,error,2706,"ar* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* ",MatchSource.WIKI,root/html528/TQtRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtRootGuiFactory.html
https://root.cern/root/html528/TQtRootGuiFactory.html:2790,Availability,error,error,2790," c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vir",MatchSource.WIKI,root/html528/TQtRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtRootGuiFactory.html
https://root.cern/root/html528/TQtWidget.html:9440,Deployability,release,released,9440,"s properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release event to the ROOT TCanvas events; kKeyUp = 14. void enterEvent(QEvent* ); Map the Qt mouse enters widget event to the ROOT TCanvas events; kMouseEnter = 52. void leaveEvent(QEvent* ); Map the Qt mouse",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:9763,Deployability,release,release,9763,"ystems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release event to the ROOT TCanvas events; kKeyUp = 14. void enterEvent(QEvent* ); Map the Qt mouse enters widget event to the ROOT TCanvas events; kMouseEnter = 52. void leaveEvent(QEvent* ); Map the Qt mouse leaves widget event to the ROOT TCanvas events; kMouseLeave = 53. void resizeEvent(QResizeEvent* ); The widget will be erased and receive a paint event immediately after; processing the resize event.; No drawing need be (or should be) done inside this handler. void SetSaveFormat(const char* format); Set the default save format for the widget. bool Save(const char* fileName) const.",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:10185,Deployability,release,release,10185," ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release event to the ROOT TCanvas events; kKeyUp = 14. void enterEvent(QEvent* ); Map the Qt mouse enters widget event to the ROOT TCanvas events; kMouseEnter = 52. void leaveEvent(QEvent* ); Map the Qt mouse leaves widget event to the ROOT TCanvas events; kMouseLeave = 53. void resizeEvent(QResizeEvent* ); The widget will be erased and receive a paint event immediately after; processing the resize event.; No drawing need be (or should be) done inside this handler. void SetSaveFormat(const char* format); Set the default save format for the widget. bool Save(const char* fileName) const. TQtWidget::Save(const QString &fileName) is a public Qt slot.; it saves the double buffer of this object using the default save; format defined the file extension; If the ""fileName"" has no extension the ""default"" format is to be used instead; The deafult format is ""PNG"".; It can be changed with the TQtWidget::SetSaveFormat method. bool Save(const QString& fileName) const. TQtWidget::Save(const QString &fil",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:12453,Deployability,update,update,12453,"hod. bool Save(const char* fileName, const char* format, int quality = 60) const. bool Save(const QString& fileName, const char* format, int quality = 60) const; TQtWidget::save is a public Qt slot.; it saves the double buffer of this object using QPixmap facility. void SetDoubleBuffer(bool on = TRUE); Set the double buffered mode on/off. void stretchWidget(QResizeEvent* e); Stretch the widget during sizing. void exitSizeEvent(); Response to the ""exit size event"". bool paintFlag(bool mode = TRUE); Set new fPaint flag; Returns: the previous version of the flag. void showEvent(QShowEvent* ); Custom handler of the Qt show event; Non-spontaneous show events are sent to widgets immediately before; they are shown.; The spontaneous show events of top-level widgets are delivered afterwards. void paintEvent(QPaintEvent* ); Custom handler of the Qt paint event; A paint event is a request to repaint all or part of the widget.; It can happen as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanv",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:392,Integrability,interface,interface,392,". TQtWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TQtWidget. class TQtWidget: public QWidget. TQtWidget is a QWidget with the QPixmap double buffer; It is designed to back the ROOT TCanvasImp class interface and it can be used; as a regular Qt Widget to create Qt-based GUI with the embedded TCanvas objects. This widget can be used as a Qt ""custom widget""; to build a custom GUI interfaces with Qt Designer. The class emits the Qt signals and has Qt public slots. Public slots: (Qt). virtual void cd(); // make the associated TCanvas the current one (shortcut to TCanvas::cd()); virtual void cd(int subpadnumber); // as above - shortcut to Canvas::cd(int subpadnumber); void Disconnect(); // disconnect the QWidget from the ROOT TCanvas (used in the class dtor); void Refresh(); // force the associated TCanvas::Update to be called; virtual bool Save(const QString &fileName) const; // Save the widget image with some ppixmap file; virtual bool Save(const char *fileName) const;; virtual bool Save(const QString &fileName,const char *format,int quality=60) const;; virtual bool Save(const char *fileName,const char *format,int quality=60) const;. signals (Qt). CanvasPainted(); // Signal the TCanvas has been painted onto the screen; Saved(bool ok); // Signal the TCanvas has been saved into the file; RootEventProcessed(TObject *selected, unsigned int event, TCanvas *c);; // Signal the Qt mouse/keyboard event has been process by ROOT; // This ""signal"" is emitted by the enabled mouse events only.; // See: EnableSignalEvents; // --- DisableSignalEvents. public methods:; The methods below define whether the TQtWidget object emits ""RootEventProcessed"" Qt signals; (By default no RootEventProcessed Qt signal is emitted ); void EnableSignalEvents (UInt_t f); void DisableSignalEvents(UInt_t f),; where f ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:574,Integrability,interface,interfaces,574,". TQtWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TQtWidget. class TQtWidget: public QWidget. TQtWidget is a QWidget with the QPixmap double buffer; It is designed to back the ROOT TCanvasImp class interface and it can be used; as a regular Qt Widget to create Qt-based GUI with the embedded TCanvas objects. This widget can be used as a Qt ""custom widget""; to build a custom GUI interfaces with Qt Designer. The class emits the Qt signals and has Qt public slots. Public slots: (Qt). virtual void cd(); // make the associated TCanvas the current one (shortcut to TCanvas::cd()); virtual void cd(int subpadnumber); // as above - shortcut to Canvas::cd(int subpadnumber); void Disconnect(); // disconnect the QWidget from the ROOT TCanvas (used in the class dtor); void Refresh(); // force the associated TCanvas::Update to be called; virtual bool Save(const QString &fileName) const; // Save the widget image with some ppixmap file; virtual bool Save(const char *fileName) const;; virtual bool Save(const QString &fileName,const char *format,int quality=60) const;; virtual bool Save(const char *fileName,const char *format,int quality=60) const;. signals (Qt). CanvasPainted(); // Signal the TCanvas has been painted onto the screen; Saved(bool ok); // Signal the TCanvas has been saved into the file; RootEventProcessed(TObject *selected, unsigned int event, TCanvas *c);; // Signal the Qt mouse/keyboard event has been process by ROOT; // This ""signal"" is emitted by the enabled mouse events only.; // See: EnableSignalEvents; // --- DisableSignalEvents. public methods:; The methods below define whether the TQtWidget object emits ""RootEventProcessed"" Qt signals; (By default no RootEventProcessed Qt signal is emitted ); void EnableSignalEvents (UInt_t f); void DisableSignalEvents(UInt_t f),; where f ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:6111,Integrability,wrap,wrapper,6111," voidSetBit(UInt_t f, Bool_t set); TQtWidgetBuffer&SetBuffer(); voidSetCanvas(TCanvas* c); voidSetCanvasDecorator(TQtCanvasPainter* decorator); voidSetDoubleBuffer(bool on = TRUE); virtual voidSetSaveFormat(const char* format); virtual voidShowMembers(TMemberInspector& insp); virtual QSizesizeHint() const; virtual QSizePolicysizePolicy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tTestBit(UInt_t f) const; Int_tTestBits(UInt_t f) const. protected:. voidAdjustBufferSize(); TCanvas*Canvas(); TQtCanvasPainter*CanvasDecorator(); virtual voidcontextMenuEvent(QContextMenuEvent*); virtual voidcustomEvent(QEvent*); virtual voidEmitCanvasPainted(); virtual voidenterEvent(QEvent*); virtual voidexitSizeEvent(); virtual voidfocusInEvent(QFocusEvent*); virtual voidfocusOutEvent(QFocusEvent*); QWidget*GetRootID() const; voidInit(); virtual voidkeyPressEvent(QKeyEvent*); virtual voidkeyReleaseEvent(QKeyEvent*); virtual voidleaveEvent(QEvent*); virtual voidmouseDoubleClickEvent(QMouseEvent*); virtual voidmouseMoveEvent(QMouseEvent*); virtual voidmousePressEvent(QMouseEvent*); virtual voidmouseReleaseEvent(QMouseEvent*); virtual voidpaintEvent(QPaintEvent*); boolpaintFlag(bool mode = TRUE); boolPaintingActive() const; voidResetCanvas(); virtual voidresizeEvent(QResizeEvent*); voidSetIgnoreLeaveEnter(int ignore = 1); voidSetRootID(QWidget* wrapper); virtual voidSetSizeHint(const QSize& size); virtual voidshowEvent(QShowEvent*); virtual voidstretchWidget(QResizeEvent* e). private:. TQtWidget(const TQtWidget&); voidoperator=(const TQtWidget&). Data Members; public:. enum { kBitMask; kEXITSIZEMOVE; kENTERSIZEMOVE; kFORCESIZE; };. protected:. TCanvas*fCanvas; boolfDoubleBufferOn; boolfEmbedded; intfIgnoreLeaveEnter; boolfInsidePaintEvent; QPointfOldMousePos; boolfPaint; TQtWidgetBuffer*fPixmapIDDouble buffer of this widget; TQtWidgetBuffer*fPixmapScreenDouble buffer for no-double buffer operation; QTimer*fRefreshTimer; QStringfSaveFormat; boolfSizeChang",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:13277,Integrability,wrap,wrapper,13277,"ards. void paintEvent(QPaintEvent* ); Custom handler of the Qt paint event; A paint event is a request to repaint all or part of the widget.; It can happen as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:13300,Integrability,wrap,wrapper,13300,"vent* ); Custom handler of the Qt paint event; A paint event is a request to repaint all or part of the widget.; It can happen as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:8580,Performance,perform,performance,8580," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is move",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:8324,Safety,avoid,avoid,8324,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:8539,Safety,redund,redundand,8539," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is move",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:9054,Safety,avoid,avoid,9054,"oid Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Do",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:9230,Safety,avoid,avoid,9230,"edded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release even",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:13402,Security,access,access,13402," as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t f); { fBits ^= f & kBitMask; }. TQtCanvasPainter * CanvasDecorator(); { return fCanvasDecorator; }. void SetCanvasDecorator(TQ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQtWidget.html:14888,Testability,test,test,14888,"ected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t f); { fBits ^= f & kBitMask; }. TQtCanvasPainter * CanvasDecorator(); { return fCanvasDecorator; }. void SetCanvasDecorator(TQtCanvasPainter* decorator); { fCanvasDecorator = decorator;}. void EnableSignalEvents(UInt_t f); { SetBit (f); }. void DisableSignalEvents(UInt_t f); { ResetBit(f); }. Bool_t IsSignalEventEnabled(UInt_t f) const; { return TestBit (f); }. void EmitSignal(UInt_t f); {if (IsSignalEventEnabled(f)) EmitTestedSignal();}. void SetIgnoreLeaveEnter(int ignore = 1); { fIgnoreLeaveEnter = ignore; }. void operator=(const TQtWidget& ); ----- Private bits, clients can only test but not change them. void ResetCanvas(); { fCanvas = 0;}. bool IsDoubleBuffered() const; { return fDoubleBufferOn; }. void EmitCanvasPainted(); { emit CanvasPainted(); }. » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TQtWidget.h 33707 2010-06-02 06:27:34Z brun $ » Last generated: 2010-10-05 11:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
https://root.cern/root/html528/TQuaternion.html:5826,Availability,error,error,5826,"const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TQuaternionConjugate() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TQuaternion&DivideLeft(const TVector3& vector); TQuaternion&DivideLeft(const TQuaternion& quaternion); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetQAngle() const; voidGetRXYZ(Double_t* carray) const; voidGetRXYZ(Float_t* carray) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html528/TQuaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQuaternion.html
https://root.cern/root/html528/TQuaternion.html:5910,Availability,error,error,5910,"rowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TQuaternionConjugate() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TQuaternion&DivideLeft(const TVector3& vector); TQuaternion&DivideLeft(const TQuaternion& quaternion); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetQAngle() const; voidGetRXYZ(Double_t* carray) const; voidGetRXYZ(Float_t* carray) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char",MatchSource.WIKI,root/html528/TQuaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQuaternion.html
https://root.cern/root/html528/TQuaternion.html:3763,Performance,optimiz,optimized,3763," -Q|V is its inverse quaternion.; ; One verifies that :; Q.Q-1 = Q-1.Q = Q|r*Q|r + Q|V*Q|V + Q|r*Q|V -Q|r*Q|V + Q|VXQ|V; = Q�|r + Q�|V = 1; . The rotation of a vector V by the rotation described by a unit quaternion Q is obtained by the following operation : V' = Q*V*Q-1, considering V as a quaternion whose real part is null.; ; Numeric computation considerations :. Numerically, the quaternion multiplication involves 12 additions and 16 multiplications.; It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; ; On the contrary, rotation of a vector by the above formula ( Q*V*Q-1 ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; ; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; ; More information :. en.wikipedia.org/wiki/Quaternions_and_spatial_rotation .; . en.wikipedia.org/wiki/Quaternion .; ; _______________________________________________; ; This Class represents all quaternions (unit or non-unit); It possesses a Normalize() method to make a given quaternion unit; The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; ; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied.; . Function Members (Methods); public:. TQuaternion(const Double_t*); TQuaternion(const Float_t*); TQuaternion(const TQuaternion&); TQuaternion(const TVector3& vector, Double_t real = 0); TQuaternion(Double_t real = 0, Double_t X = 0, Double_t Y = 0, Double_t Z = 0); virtual~TQuaterni",MatchSource.WIKI,root/html528/TQuaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQuaternion.html
https://root.cern/root/html528/TQuaternion.html:4330,Performance,perform,perform,4330,"tiplication involves 12 additions and 16 multiplications.; It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; ; On the contrary, rotation of a vector by the above formula ( Q*V*Q-1 ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; ; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; ; More information :. en.wikipedia.org/wiki/Quaternions_and_spatial_rotation .; . en.wikipedia.org/wiki/Quaternion .; ; _______________________________________________; ; This Class represents all quaternions (unit or non-unit); It possesses a Normalize() method to make a given quaternion unit; The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; ; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied.; . Function Members (Methods); public:. TQuaternion(const Double_t*); TQuaternion(const Float_t*); TQuaternion(const TQuaternion&); TQuaternion(const TVector3& vector, Double_t real = 0); TQuaternion(Double_t real = 0, Double_t X = 0, Double_t Y = 0, Double_t Z = 0); virtual~TQuaternion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TQuater",MatchSource.WIKI,root/html528/TQuaternion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQuaternion.html
https://root.cern/root/html528/TQueryDescription.html:1483,Availability,error,error,1483,"eryDescription(); TQueryDescription(const TQueryDescription&); ~TQueryDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TQueryDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryDescription.html
https://root.cern/root/html528/TQueryDescription.html:1567,Availability,error,error,1567," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html528/TQueryDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryDescription.html
https://root.cern/root/html528/TQueryResult.html:1368,Availability,error,error,1368," TQueryResult(); TQueryResult(const TQueryResult&); virtual~TQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetEndTime() const; Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:1452,Availability,error,error,1452,"(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetEndTime() const; Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; TList*GetInputList(); TObject*GetInputObject(const char* classname) const; const char*GetLibList() const; TMacro*GetLogFile() const; virtual const char*TNamed::GetName() const; Int_tGetNumWrks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; TList*GetOutputList(); const",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:9076,Deployability,update,update,9076," Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances. The header is searched for in the same directory; of the implementation file. void RecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); End of query settings. void SetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.); Set processing info. void AddLogLine(const char* logline); Fill log file. void AddInput(TObject* obj); Add obj to the input list. void SetArchived(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQ",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:7306,Integrability,message,messages,7306,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:7259,Performance,load,loaded,7259,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:7553,Performance,load,loaded,7553,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:10036,Security,access,access,10036,"d(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec). void SetFinalized(); { fFinalized = kTRUE; }. TQueryResult(); { }. Int_t GetSeqNum() const; { return fSeqNum; }. EQueryStatus GetStatus() const; { return fStatus; }. TDatime GetStartTime() const; { return fStart; }. TDatime GetEndTime() const; { return fEnd; }. const char * GetOptions() const; { return fOptions; }. TList * GetInputList(); { return fInputList; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetFirst() const; { return fFirst; }. Long64_t GetBytes() const; { return fBytes; }. Float_t GetUsedCPU() const; { return fUsedCPU; }. TMacro * GetLogFile() const; { return fLogFile; }. TMacro * GetSelecHdr() const; { return fSelecHdr; }. TMacro * GetSelecImp() const; { return fSelecImp; }. const char * GetLibList() const; { return fLibList; }. const char * GetParList() const; { return fParList; }. TList * GetOutputList(); { return fOu",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:5823,Testability,log,logline,5823,"idTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); voidAddInput(TObject* obj); voidAddLogLine(const char* logline); TQueryResult*CloneInfo(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); voidSaveSelector(const char* selec); voidSetArchived(const char* archfile); virtual voidSetFinalized(); virtual voidSetInputList(TList* in, Bool_t adopt = kTRUE); virtual voidSetOutputList(TList* out, Bool_t adopt = kTRUE); virtual voidSetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.). Data Members; public:. enum EQueryStatus { kAborted; kSubmitted; kRunning; kStopped; kCompleted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tf",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:7302,Testability,log,log,7302,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:8947,Testability,log,logline,8947,"ject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances. The header is searched for in the same directory; of the implementation file. void RecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); End of query settings. void SetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.); Set processing info. void AddLogLine(const char* logline); Fill log file. void AddInput(TObject* obj); Add obj to the input list. void SetArchived(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* c",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResult.html:8962,Testability,log,log,8962,"ject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances. The header is searched for in the same directory; of the implementation file. void RecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); End of query settings. void SetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.); Set processing info. void AddLogLine(const char* logline); Fill log file. void AddInput(TObject* obj); Add obj to the input list. void SetArchived(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* c",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
https://root.cern/root/html528/TQueryResultManager.html:1631,Availability,error,error,1631,"d) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCpuTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; void",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
https://root.cern/root/html528/TQueryResultManager.html:1715,Availability,error,error,1715,"s(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCpuTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIncrementDrawQueries(); voidIncrementSeqNum(); virtual voidTObject::Info(const char*",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
https://root.cern/root/html528/TQueryResultManager.html:6658,Integrability,depend,dependent,6658,"ning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidAddLogFile(TProofQueryResult* pq). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStopwatchfComputemeasures time spend processing a query on the master; Int_tfDrawQueriesnumber of draw queries processed; Int_tfKeptQueriesnumber of queries fully in memory and in dir; TProofLockPath*fLockdir locker; FILE*fLogFilelog file; TList*fPreviousQuerieslist of TProofQueryResult objects from previous sections; TList*fQuerieslist of TProofQueryResult objects; TStringfQueryDirdirectory containing query results and status; Int_tfSeqNumsequential number of last processed query; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the session. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddLogFile(TProofQueryResult* pq). TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0). const char * QueryDir() const; { return fQueryDir.Data(); }. Int_t SeqNum() const; { return fSeqNum; }. Int_t DrawQueries() const; { return fDrawQueries; }. Int_t KeptQueries() const; { return fKeptQueries; }. TList * Queries() const; { return fQueries; }. TList * PreviousQueries() const; { return fPreviousQueries; }. void IncrementSeqNum(); { fSeqNum++; }. void IncrementDrawQueries(); { fDrawQueries++; }. Int_t ApplyMaxQueries(Int_t mxq). Int_t CleanupQ",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
https://root.cern/root/html528/TQueryResultManager.html:544,Testability,log,logfile,544," TQueryResultManager(const TQueryResultManager&); TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); virtual~TQueryResultManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
https://root.cern/root/html528/TQueryResultManager.html:6946,Testability,log,logfile,6946,"MustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStopwatchfComputemeasures time spend processing a query on the master; Int_tfDrawQueriesnumber of draw queries processed; Int_tfKeptQueriesnumber of queries fully in memory and in dir; TProofLockPath*fLockdir locker; FILE*fLogFilelog file; TList*fPreviousQuerieslist of TProofQueryResult objects from previous sections; TList*fQuerieslist of TProofQueryResult objects; TStringfQueryDirdirectory containing query results and status; Int_tfSeqNumsequential number of last processed query; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the session. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddLogFile(TProofQueryResult* pq). TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0). const char * QueryDir() const; { return fQueryDir.Data(); }. Int_t SeqNum() const; { return fSeqNum; }. Int_t DrawQueries() const; { return fDrawQueries; }. Int_t KeptQueries() const; { return fKeptQueries; }. TList * Queries() const; { return fQueries; }. TList * PreviousQueries() const; { return fPreviousQueries; }. void IncrementSeqNum(); { fSeqNum++; }. void IncrementDrawQueries(); { fDrawQueries++; }. Int_t ApplyMaxQueries(Int_t mxq). Int_t CleanupQueriesDir(). Bool_t FinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); { return fCompute.CpuTime(); }. Float_t GetRealTime(); { return fCompute.RealTime(); }. TProofQueryResult * LocateQuery(TString queryref, Int_t& qry, TString& qdir). void RemoveQuery(TQueryResult* qr, Bool_t soft = kFALSE). void RemoveQuery(const char* queryref, TList* otherlist = 0). void ResetTime(); { fCompute.Start(); }. void SaveQuery(TProofQueryResult* qr, const char* fout ",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
https://root.cern/root/html528/TQUndoManager.html:818,Availability,down,downwards,818,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:7625,Availability,error,error,7625,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*TQCommand::GetCommand(); TQCommand*GetCurrent() const; static TCollection*TCollection::GetCurrentCollection(); TQCommand*GetCursor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; UInt_tGetLimit() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:7709,Availability,error,error,7709,":Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*TQCommand::GetCommand(); TQCommand*GetCurrent() const; static TCollection*TCollection::GetCurrentCollection(); TQCommand*GetCursor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; UInt_tGetLimit() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TQCommand::GetName() const; Int_tTQCommand::GetNRargs() const; Int_tTQCommand:",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2186,Deployability,update,update,2186,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::Ab",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2240,Deployability,update,update,2240,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::Ab",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2740,Performance,perform,performing,2740,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(T",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:16805,Performance,cache,cache,16805,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:17378,Testability,log,logging,17378,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:18753,Testability,log,logging,18753," actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:18782,Testability,log,log,18782,"; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located i",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:18801,Testability,log,logging,18801,"; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located i",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:19521,Testability,log,logging,19521,"c Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:570,Usability,undo,undo,570,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:757,Usability,undo,undo,757,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:846,Usability,undo,undo,846,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1286,Usability,undo,undo,1286,"OT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1310,Usability,undo,undo,1310," based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macr",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1337,Usability,undo,undo,1337," based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macr",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1577,Usability,undo,undo,1577,"ges to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in firs",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1775,Usability,undo,undo,1775,"aversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register co",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1820,Usability,undo,undo,1820,"aversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register co",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:1859,Usability,undo,undo,1859,"and in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2038,Usability,undo,undo,2038,"h command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo t",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2138,Usability,undo,undo,2138,"_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Func",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2638,Usability,undo,undo,2638,"or();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:2751,Usability,undo,undo,2751,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(T",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:3015,Usability,undo,undo,3015,"m->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::Appen",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:3064,Usability,undo,undo,3064," commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQO",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:15884,Usability,undo,undo,15884,"entStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTQCommand::Init(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNo",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:17475,Usability,undo,undo,17475,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:17726,Usability,undo,undo,17726,"in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:18056,Usability,undo,undoing,18056,"in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:19182,Usability,undo,undo,19182,"r Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/TQUndoManager.html:19453,Usability,undo,undo,19453,"c Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option string can contain the following substrings:; ""merge"" - input command will be merged; ""compress"" - input command will be compressed. void CurrentChanged(TQCommand* c); emit signal. void Undo(Option_t* option = """"); Performs undo action. Move cursor position backward in history stack. void Redo(Option_t* option = """"); Performs redo action. Move cursor position forward in history stack. Bool_t CanRedo() const; Returns kTRUE if redo action is possible. Bool_t CanUndo() const; Returns kTRUE if undo action is possible. Bool_t IsLogging() const; Returns kTRUE if logging is ON. TQCommand * GetCurrent() const; Returns the last executed command. TQCommand * GetCursor() const; Returns a command correspondent to the current cursor position in stack. void SetLimit(UInt_t limit); Returns a maximum number of commands which could be located in stack. UInt_t GetLimit() const; Returns a maximum number of commands which could be located in stack. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
https://root.cern/root/html528/Track.html:4137,Availability,error,error,4137,,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:4221,Availability,error,error,4221,"); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetBx() const; Float_tGetBy() const; Double32_tGetCharge() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Float_tGetMass2() const; Float_tGetMeanCharge() const; Int_tGetN() const; virtual const char*TObject::GetName() const; Int_tGetNpoint() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double32_tGetPointValue(Int_t i = 0) const; Float_tGetPt() const; Float_tGetPx() const; Float_tGetPy() const; Float_tGetPz() const; Float_tGetRandom() const; virtual const char*TObject::GetTitle() const; TBits&GetTriggerBits();",MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:1616,Energy Efficiency,charge,charge,1616,TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:8642,Energy Efficiency,charge,charge,8642,"UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Float16_tfBx[0,0,10] X intercept at the vertex; Float16_tfBy[0,0,10] Y intercept at the vertex; Double32_tfCharge[-1,1,2] Charge of this track; Float16_tfMass2[0,0,8] The mass square of this particle; Float_tfMeanChargeMean charge deposition of all hits of this track; Int_tfNpointNumber of points for this track; Int_tfNspNumber of points for this track with a special value; Double32_t*fPointValue[fNsp][0,3] a special quantity for some point.; Float_tfPxX component of the momentum; Float_tfPyY component of the momentum; Float_tfPzZ component of the momentum; Float_tfRandomA random track quantity; TBitsfTriggerBitsBits triggered by this track.; Short_tfValidValidity criterion; Double32_tfVertex[3][-30,30,16] Track vertex position; Float16_tfXfirstX coordinate of the first point; Float16_tfXlastX coordinate of the last point; Float16_tfYfirstY coordinate of the first point; Float16_tfYlastY coordinate of the last point; Float16_tfZfirstZ coordinate of the first point; Float16_tfZlastZ coordinate of the last point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Track(const Track& orig); Copy a track object. Track(Float_t random); Create a track object.; Note that ",MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:1155,Modifiability,variab,variable,1155,iption; function members; data members; class charts. ROOT; » TEST; » Track. class Track: public TObject. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //N,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:2879,Modifiability,variab,variables,2879,"he first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken care of by the HistogramManager class. Note: This version of the class Event (see EventMT.h and EventMT.cxx; for an alternative) uses static variables to improve performance (by; reducing the number of memory allocations). Consequently, only one; instance of the class Event should be in use at a time (a 2nd instance; would share the array of Tracks with the first instance). Function Members (Methods); public:. Track(); Track(const Track& orig); Track(Float_t random); virtual~Track(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:2900,Performance,perform,performance,2900,"he first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken care of by the HistogramManager class. Note: This version of the class Event (see EventMT.h and EventMT.cxx; for an alternative) uses static variables to improve performance (by; reducing the number of memory allocations). Consequently, only one; instance of the class Event should be in use at a time (a 2nd instance; would share the array of Tracks with the first instance). Function Members (Methods); public:. Track(); Track(const Track& orig); Track(Float_t random); virtual~Track(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/Track.html:320,Usability,simpl,simple,320,. Track. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TEST; » Track. class Track: public TObject. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of th,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
https://root.cern/root/html528/TRandom.html:6100,Availability,error,error,6100,"t* option = """"); virtual Int_tBinomial(Int_t ntot, Double_t prob); virtual Double_tBreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tExp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tGetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:6184,Availability,error,error,6184,"reitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tExp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tGetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, co",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:12610,Availability,avail,available,12610,"mended instead; (with mean =*ntot+0.5 and standard deviation sqrt(ntot*prob*(1-prob)). Double_t BreitWigner(Double_t mean = 0, Double_t gamma = 1); Return a number distributed following a BreitWigner function with mean and gamma. void Circle(Double_t& x, Double_t& y, Double_t r); generates random vectors, uniformly distributed over a circle of given radius.; Input : r = circle radius; Output: x,y a random 2-d vector of length r. Double_t Exp(Double_t tau); returns an exponential deviate. exp( -t/tau ). Double_t Gaus(Double_t mean = 0, Double_t sigma = 1). samples a random number from the standard Normal (Gaussian) Distribution; with the given mean and sigma.; Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; This is one of the fastest existing method for generating normal random variables.; It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); implemented for example in GSL and available in the MathMore library. REFERENCE: - W. Hoermann and G. Derflinger (1990):; The ACR Method for generating normal random variables,; OR Spektrum 12 (1990), 181-185. Implementation taken from; UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien. UInt_t Integer(UInt_t imax); returns a random integer on [ 0, imax-1 ]. Double_t Landau(Double_t mean = 0, Double_t sigma = 1); Generate a random number following a Landau distribution; with mpv(most probable value) and sigma; Use function landau_quantile(x,sigma) which provides; the inverse of the landau cumulative distribution; landau_quantile has been converted from CERNLIB ranlan(G110). Int_t Poisson(Double_t mean); Generates a random integer N according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). Use a different procedure according to the mean value.; The algorithm is the same used by CLHEP; For lower value (mean < 25) use the rejection method based on; the exp",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:2349,Deployability,continuous,continuous,2349,"242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:2098,Energy Efficiency,power,powerful,2098,"lowing table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau.......",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:2257,Energy Efficiency,power,powerful,2257,"242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:13709,Integrability,rout,routine,13709,"ermann and G. Derflinger (1990):; The ACR Method for generating normal random variables,; OR Spektrum 12 (1990), 181-185. Implementation taken from; UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien. UInt_t Integer(UInt_t imax); returns a random integer on [ 0, imax-1 ]. Double_t Landau(Double_t mean = 0, Double_t sigma = 1); Generate a random number following a Landau distribution; with mpv(most probable value) and sigma; Use function landau_quantile(x,sigma) which provides; the inverse of the landau cumulative distribution; landau_quantile has been converted from CERNLIB ranlan(G110). Int_t Poisson(Double_t mean); Generates a random integer N according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). Use a different procedure according to the mean value.; The algorithm is the same used by CLHEP; For lower value (mean < 25) use the rejection method based on; the exponential; For higher values use a rejection method comparing with a Lorentzian; distribution, as suggested by several authors; This routine since is returning 32 bits integer will not work for values larger than 2*10**9; One should then use the Trandom::PoissonD for such large values. Double_t PoissonD(Double_t mean); Generates a random number according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). This function is a variant of TRandom::Poisson returning a double; instead of an integer. void Rannor(Float_t& a, Float_t& b); Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. void Rannor(Double_t& a, Double_t& b); Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. void ReadRandom(const char* filename). Reads saved random generator status from filename. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Based on the BSD Unix (Rand) Linear congrential generator; Produces uniformly-distributed floating points between 0 and 1.; Identical sequence on all machines of >= 32 bits.; Periodicity = ",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:15332,Integrability,depend,depends,15332,"a=1. void ReadRandom(const char* filename). Reads saved random generator status from filename. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Based on the BSD Unix (Rand) Linear congrential generator; Produces uniformly-distributed floating points between 0 and 1.; Identical sequence on all machines of >= 32 bits.; Periodicity = 2**31; generates a number in ]0,1]; Note that this is a generator which is known to have defects; (the lower random bits are correlated) and therefore should NOT be; used in any statistical study. void RndmArray(Int_t n, Double_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void RndmArray(Int_t n, Float_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void SetSeed(UInt_t seed = 0); Set the random generator seed. Note that default value is zero, which is different than the; default value used when constructing the class.; If the seed is zero the seed is set to a random value; which in case of TRandom depends on the machine clock.; Note that the machine clock is returned with a precision of 1 second.; If one calls SetSeed(0) within a loop and the loop time is less than 1s,; all generated numbers will be identical!; Instead if a different generator implementation is used (TRandom1 , 2 or 3) the seed is generated using; a 128 bit UUID. This results in different seeds and then random sequence for every SetSeed(0) call. void Sphere(Double_t& x, Double_t& y, Double_t& z, Double_t r); generates random vectors, uniformly distributed over the surface; of a sphere of given radius.; Input : r = sphere radius; Output: x,y,z a random 3-d vector of length r; Method: (based on algorithm suggested by Knuth and attributed to Robert E Knop); which uses less random numbers than the CERNLIB RN23DIM algorithm. Double_t Uniform(Double_t x1 = 1); returns a uniform deviate on the interval ]0, x1]. Double_t Uniform(Double_t x1, Double_t x2); returns a uniform deviate on the interv",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:2270,Modifiability,flexible,flexible,2270,"242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:12389,Modifiability,variab,variables,12389,"A-5061-MS. N is binomially distributed between 0 and ntot inclusive; with mean prob*ntot.; prob is between 0 and 1. Note: This function should not be used when ntot is large (say >100).; The normal approximation is then recommended instead; (with mean =*ntot+0.5 and standard deviation sqrt(ntot*prob*(1-prob)). Double_t BreitWigner(Double_t mean = 0, Double_t gamma = 1); Return a number distributed following a BreitWigner function with mean and gamma. void Circle(Double_t& x, Double_t& y, Double_t r); generates random vectors, uniformly distributed over a circle of given radius.; Input : r = circle radius; Output: x,y a random 2-d vector of length r. Double_t Exp(Double_t tau); returns an exponential deviate. exp( -t/tau ). Double_t Gaus(Double_t mean = 0, Double_t sigma = 1). samples a random number from the standard Normal (Gaussian) Distribution; with the given mean and sigma.; Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; This is one of the fastest existing method for generating normal random variables.; It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); implemented for example in GSL and available in the MathMore library. REFERENCE: - W. Hoermann and G. Derflinger (1990):; The ACR Method for generating normal random variables,; OR Spektrum 12 (1990), 181-185. Implementation taken from; UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien. UInt_t Integer(UInt_t imax); returns a random integer on [ 0, imax-1 ]. Double_t Landau(Double_t mean = 0, Double_t sigma = 1); Generate a random number following a Landau distribution; with mpv(most probable value) and sigma; Use function landau_quantile(x,sigma) which provides; the inverse of the landau cumulative distribution; landau_quantile has been converted from CERNLIB ranlan(G110). Int_t Poisson(Double_t mean); Generates a random integer N according to ",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:12741,Modifiability,variab,variables,12741," a number distributed following a BreitWigner function with mean and gamma. void Circle(Double_t& x, Double_t& y, Double_t r); generates random vectors, uniformly distributed over a circle of given radius.; Input : r = circle radius; Output: x,y a random 2-d vector of length r. Double_t Exp(Double_t tau); returns an exponential deviate. exp( -t/tau ). Double_t Gaus(Double_t mean = 0, Double_t sigma = 1). samples a random number from the standard Normal (Gaussian) Distribution; with the given mean and sigma.; Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger; This is one of the fastest existing method for generating normal random variables.; It is a factor 2/3 faster than the polar (Box-Muller) method used in the previous; version of TRandom::Gaus. The speed is comparable to the Ziggurat method (from Marsaglia); implemented for example in GSL and available in the MathMore library. REFERENCE: - W. Hoermann and G. Derflinger (1990):; The ACR Method for generating normal random variables,; OR Spektrum 12 (1990), 181-185. Implementation taken from; UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien. UInt_t Integer(UInt_t imax); returns a random integer on [ 0, imax-1 ]. Double_t Landau(Double_t mean = 0, Double_t sigma = 1); Generate a random number following a Landau distribution; with mpv(most probable value) and sigma; Use function landau_quantile(x,sigma) which provides; the inverse of the landau cumulative distribution; landau_quantile has been converted from CERNLIB ranlan(G110). Int_t Poisson(Double_t mean); Generates a random integer N according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). Use a different procedure according to the mean value.; The algorithm is the same used by CLHEP; For lower value (mean < 25) use the rejection method based on; the exponential; For higher values use a rejection method comparing with a Lorentzian; distribution, as suggested by several authors; This routine since is retu",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:2686,Testability,test,testrandom,2686,"distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN..",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:379,Usability,simpl,simple,379,". TRandom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom. class TRandom: public TNamed. TRandom. basic Random number generator class (periodicity = 10**9).; Note that this is a very simple generator (linear congruential); which is known to have defects (the lower random bits are correlated); and therefore should NOT be used in any statistical study.; One should use instead TRandom1, TRandom2 or TRandom3.; TRandom3, is based on the ""Mersenne Twister generator"", and is the recommended one,; since it has good random proprieties (period of about 10**6000 ) and it is fast.; TRandom1, based on the RANLUX algorithm, has mathematically proven random proprieties; and a period of about 10**171. It is however slower than the others.; TRandom2, is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; of being fast and using only 3 words (of 32 bits) for the state. The period is 10**26. The following table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDi",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom.html:4569,Usability,simpl,simple,4569,"000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000. Note that the time to generate a number from an arbitrary TF1 function; using TF1::GetRandom or using TUnuran is independent of the complexity of the function. TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name). can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram; or from an existing function. Note this interesting feature when working with objects. You can use several TRandom objects, each with their ""independent""; random sequence. For example, one can imagine; TRandom *eventGenerator = new TRandom();; TRandom *tracking = new TRandom();; eventGenerator can be used to generate the event kinematics.; tracking can be used to track the generated particles with random numbers; independent from eventGenerator.; This very interesting feature gives the possibility to work with simple; and very fast random number generators without worrying about; random number periodicity as it was the case with Fortran.; One can use TRandom::SetSeed to modify the seed of one generator. a TRandom object may be written to a Root file. -as part of another object; -or with its own key (example gRandom->Write(""Random"");. Function Members (Methods); public:. TRandom(UInt_t seed = 65539); TRandom(const TRandom&); virtual~TRandom(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBinomial(Int_t ntot, Double_t prob); virtual Double_tBreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Cop",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
https://root.cern/root/html528/TRandom1.html:1956,Availability,error,error,1956,"t_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLuxury() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; static voidGetTableSeeds(UInt_t* seeds, Int_t index); const UInt_t*GetTheSeeds() c",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:2040,Availability,error,error,2040,"r(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLuxury() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; static voidGetTableSeeds(UInt_t* seeds, Int_t index); const UInt_t*GetTheSeeds() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueI",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:7663,Integrability,rout,routine,7663,"tual voidTRandom::WriteRandom(const char* filename). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random n",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:7781,Testability,test,tests,7781,"n, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); T",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:7875,Testability,test,test,7875,"nDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); The initialisation is carried out using a Multiplicative; Congruential generator using formula constants of L'Ecuyer; as ",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:7906,Testability,test,test,7906,"nDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); The initialisation is carried out using a Multiplicative; Congruential generator using formula constants of L'Ecuyer; as ",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom1.html:7946,Testability,test,tests,7946,"bject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); The initialisation is carried out using a Multiplicative; Congruential generator using formula constants of L'Ecuyer; as described in ""A review of pseudorandom number generators""; (Fred James) published in Computer Physics",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
https://root.cern/root/html528/TRandom2.html:665,Availability,avail,available,665,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. TRandom2(UInt_t seed = 1); TRandom2(const TRandom2&); virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root/html528/TRandom2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom2.html
https://root.cern/root/html528/TRandom2.html:2037,Availability,error,error,2037,"t_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root/html528/TRandom2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom2.html
https://root.cern/root/html528/TRandom2.html:2121,Availability,error,error,2121,"r(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html528/TRandom2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom2.html
https://root.cern/root/html528/TRandom2.html:7479,Availability,mask,mask,7479,"riteRandom(const char* filename). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tTRandom::fSeedRandom number generator seed; UInt_tfSeed1Random number generator seed 1; UInt_tfSeed2Random number generator seed 2; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom2(UInt_t seed = 1); default constructor*-*-*-*-; *-* ===================. ~TRandom2(); default destructor*-*-*-*-; *-* ==================. Double_t Rndm(Int_t i = 0); TausWorth generator from L'Ecuyer, uses as seed 3x32bits integers; Use a mask of 0xffffffffUL to make in work on 64 bit machines; Periodicity of about 10**26. void RndmArray(Int_t n, Float_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void RndmArray(Int_t n, Double_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void SetSeed(UInt_t seed = 0); Set the generator seed.; If the seed given is zero, generate automatically seed values which; are different every time by using TRandom3 and TUUID; If a seed is given generate the other two needed for the generator state using; a linear congruential generator; The only condition, stated at the end of the 1999 L'Ecuyer paper is that the seeds; must be greater than 1,7 and 15. TRandom2(UInt_t seed = 1). » Author: Rene Brun 04/03/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TRandom2.h 22866 2008-03-27 15:32:50Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. Fo",MatchSource.WIKI,root/html528/TRandom2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom2.html
https://root.cern/root/html528/TRandom3.html:3062,Availability,error,error,3062,"t_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root/html528/TRandom3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom3.html
https://root.cern/root/html528/TRandom3.html:3146,Availability,error,error,3146,"r(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html528/TRandom3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom3.html
https://root.cern/root/html528/TRandom3.html:9097,Deployability,upgrade,upgraded,9097,"kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tTRandom::fSeedRandom number generator seed; TStringTNamed::fTitleobject title. private:. Int_tfCount624; UInt_tfMt[624]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom3(UInt_t seed = 4357); default constructor*-*-*-*-; If seed is 0, the seed is automatically computed via a TUUID object.; In this case the seed is guaranteed to be unique in space and time. ~TRandom3(); default destructor*-*-*-*-; *-* ==================. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Produces uniformly-distributed floating points in ]0,1]; Method: Mersenne Twistor. void RndmArray(Int_t n, Float_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void RndmArray(Int_t n, Double_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void SetSeed(UInt_t seed = 0); Set the random generator sequence; if seed is 0 (default value) a TUUID is generated and used to fill; the first 8 integers of the seed array.; In this case the seed is guaranteed to be unique in space and time.; Use upgraded seeding procedure to fix a known problem when seeding with values; with many zero in the bit pattern (like 2**28).; see http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html. void Streamer(TBuffer& b); Stream an object of class TRandom3. TRandom3(UInt_t seed = 4357). » Author: Peter Malzacher 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TRandom3.h 22866 2008-03-27 15:32:50Z rdm $ » Last generated: 2010-12-10 21:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRandom3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom3.html
https://root.cern/root/html528/TRealData.html:1764,Availability,error,error,1764,"DataMember* datamember); virtual~TRealData(); voidTObject::AbstractMethod(const char* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TMemberStreamer*GetStreamer() const; Long_tGetThisOffset() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html528/TRealData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRealData.html
https://root.cern/root/html528/TRealData.html:1848,Availability,error,error,1848,"* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TMemberStreamer*GetStreamer() const; Long_tGetThisOffset() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classn",MatchSource.WIKI,root/html528/TRealData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRealData.html
https://root.cern/root/html528/TRealData.html:421,Modifiability,inherit,inherits,421,". TRealData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TRealData. class TRealData: public TObject. The TRealData class manages the effective list of all data members; for a given class. For example for an object of class TLine that inherits; from TObject and TAttLine, the TRealData object for a line contains the; complete list of all data members of the 3 classes. The list of TRealData members in TClass is built when functions like; object.Inspect or object.DrawClass are called. Function Members (Methods); public:. TRealData(); TRealData(const char* name, Long_t offset, TDataMember* datamember); virtual~TRealData(); voidTObject::AbstractMethod(const char* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root/html528/TRealData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRealData.html
https://root.cern/root/html528/TRecCmdEvent.html:1333,Availability,error,error,1333," TRecCmdEvent(); TRecCmdEvent(const TRecCmdEvent&); ~TRecCmdEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html528/TRecCmdEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecCmdEvent.html
https://root.cern/root/html528/TRecCmdEvent.html:1417,Availability,error,error,1417," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetText() const; virtual TTimeTRecEvent::GetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inher",MatchSource.WIKI,root/html528/TRecCmdEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecCmdEvent.html
https://root.cern/root/html528/TRecEvent.html:2753,Availability,avail,available,2753,"er->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:3713,Availability,error,error,3713,,MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:3797,Availability,error,error,3797," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTimeGetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; v",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:319,Integrability,interface,interface,319,". TRecEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecEvent. class TRecEvent: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:1154,Testability,log,logfile,1154,"class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecEvent. class TRecEvent: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:2382,Usability,pause,pause,2382,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opt",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:2481,Usability,resume,resume,2481,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Op",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecEvent.html:2488,Usability,pause,paused,2488,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Op",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:3661,Availability,error,error,3661,,MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:3745,Availability,error,error,3745," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringGetText() const; virtual TTimeTRecEvent::GetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:336,Integrability,interface,interface,336,". TRecExtraEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecExtraEvent. class TRecExtraEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is n",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:1171,Testability,log,logfile,1171,"ption; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecExtraEvent. class TRecExtraEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:2399,Usability,pause,pause,2399,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:2498,Usability,resume,resume,2498,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMEN",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecExtraEvent.html:2505,Usability,pause,paused,2505,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMEN",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:3719,Availability,error,error,3719,"const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTimeTRecEvent::GetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:3803,Availability,error,error,3803,"d) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTimeTRecEvent::GetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classnam",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:8198,Availability,mask,mask,8198,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:356,Integrability,interface,interface,356,". TRecGuiEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecGuiEvent. class TRecGuiEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; ",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:8334,Integrability,message,message,8334,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:7884,Security,expose,exposes,7884,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:8042,Security,expose,exposed,8042,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:8371,Security,expose,exposed,8371,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:1191,Testability,log,logfile,1191,"scription; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecGuiEvent. class TRecGuiEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:2419,Usability,pause,pause,2419,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual vo",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:2518,Usability,resume,resume,2518,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecGuiEvent.html:2525,Usability,pause,paused,2525,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
https://root.cern/root/html528/TRecorder.html:3706,Availability,error,error,3706,"t TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TRecorder::ERecorderStateGetState() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:3790,Availability,error,error,3790,"Recorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TRecorder::ERecorderStateGetState() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inheri",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:345,Integrability,interface,interface,345,". TRecorder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorder. class TRecorder: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that cas",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:8442,Integrability,depend,depending,8442,"on = 0, Int_t bufsize = 0) const. protected:. voidChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EReplayModes { kRealtime; };; enum ERecorderState { kInactive; kRecording; kPaused; kReplaying; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfFilenameEvents file name. private:. TRecorderState*fRecorderState! Current state of recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorder(); Creates initial INACTIVE state for the recorder. TRecorder(const char* filename, Option_t* option = ""READ""); Creates a recorder with filename to replay or to record,; depending on option (NEW or RECREATE will start recording,; READ will start replaying). ~TRecorder(); Destructor. void Browse(TBrowser* ); Browse the recorder from a ROOT file. This allows to replay a; session from the browser. void Start(const char* filename, Option_t* option = ""RECREATE"", Window_t* w = 0, Int_t winCount = 0); Starts recording events. void Stop(Bool_t guiCommand = kFALSE); Stopps recording events. Bool_t Replay(const char* filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays events from 'filename'. void Pause(); Pauses replaying. void Resume(); Resumes replaying. void ReplayStop(); Cancells replaying. void ListCmd(const char* filename); Prints out recorded commandline events. void ListGui(const char* filename); Prints out recorded GUI events. void ChangeState(TRecorderState* newstate, Bool_t deletePreviousState = kTRUE); Changes state from the current to the passed one (newstate); Deletes the old state if delPrev",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:1180,Testability,log,logfile,1180,"class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorder. class TRecorder: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:2408,Usability,pause,pause,2408,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual void",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:2507,Usability,resume,resume,2507,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; ",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorder.html:2514,Usability,pause,paused,2514,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; ",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
https://root.cern/root/html528/TRecorderPaused.html:351,Usability,pause,paused,351,". TRecorderPaused. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderPaused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last ch",MatchSource.WIKI,root/html528/TRecorderPaused.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderPaused.html
https://root.cern/root/html528/TRecorderPaused.html:1480,Usability,pause,paused,1480,"aused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRecorderPaused.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderPaused.html
https://root.cern/root/html528/TRecorderPaused.html:1660,Usability,pause,paused,1660,"aused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRecorderPaused.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderPaused.html
https://root.cern/root/html528/TRecorderRecording.html:3525,Energy Efficiency,allocate,allocated,3525,"ed extra events (PaveLabels and Texts); TFile*fFileROOT file to store recorded events in; Bool_tfFilterEventPaveSpecial flag to filter events during the pave recording; Window_t*fFilteredIdsOnly when GUI for recorer is used: IDs of windows that creates that GUI.; Int_tfFilteredIdsCountOnly when GUI for recorder is used: Count of windows in GUI recorder; TRecGuiEvent*fGuiEventThe newest GUI event to be stored in TTree; TTree*fGuiTreeTTree with recorded GUI events; TTimer*fMouseTimerTimer used for recording mouse position; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered ROOT windows.; TTimer*fTimerTimer used for recording; ULong64_tfWinThe newest registered window to be stored in TTree; TTree*fWinTreeTTree with registered windows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount); Initializes TRecorderRecording for recording; What is allocated here is deleted in destructor. Bool_t StartRecording(); Connects appropriate signals and slots in order to gain all registered; windows and processed events in ROOT and then starts recording. void Stop(TRecorder* r, Bool_t guiCommand); Disconnects all slots and stopps recording. void RegisterWindow(Window_t w); This method is called when RegisteredWindow(Window_t) is emitted from; TGClient. void RecordCmdEvent(const char* line); Records commandline event (text and time) ans saves the previous; commandline event; This 1 event delay in saving ensures that the last commandline events; 'TRecorder::Stop' will be not stored. void RecordGuiEvent(Event_t* e, Window_t wid); Records GUI Event_t *e different from kConfigureNotify (they are; recorded in TRecorderRecording::RecordGuiCNEvent). It is called via signal-slot when an event is processed in; TGClient::HandleEvent(Event_t *event); or in TGClient::HandleMaskEve",MatchSource.WIKI,root/html528/TRecorderRecording.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderRecording.html
https://root.cern/root/html528/TRecorderReplaying.html:3595,Energy Efficiency,allocate,allocated,3595,"of GUI events that have been replayed; TMutex*fMutex; TRecEvent*fNextEventThe next event that is going to be replayed (GUI event or commandline); TTimefPreviousEventTimeExecution time of the previously replayed event.; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent()",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
https://root.cern/root/html528/TRecorderReplaying.html:3895,Testability,log,log,3895,"tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent(); Finds the next event in log file to replay and sets it to fNextEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must fir",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
https://root.cern/root/html528/TRecorderReplaying.html:4574,Testability,log,log,4574,"d for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent(); Finds the next event in log file to replay and sets it to fNextEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
https://root.cern/root/html528/TRecorderReplaying.html:6103,Usability,pause,paused,6103,"xtEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
https://root.cern/root/html528/TRecorderState.html:2752,Availability,avail,available,2752,"er->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRU",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:318,Integrability,interface,interface,318,". TRecorderState. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderState. class TRecorderState. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to ",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:1153,Testability,log,logfile,1153,"ons:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderState. class TRecorderState. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:2381,Usability,pause,pause,2381,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virt",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:2480,Usability,resume,resume,2480,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). p",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:2487,Usability,pause,paused,2487,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). p",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecorderState.html:4263,Usability,pause,paused,4263,"order*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRUE); Changes state to the new one.; See class documentation for information about state changing. void Start(const char *filename, Option_t *option = ""RECREATE"", Window_t *w = 0, Int_t winCount = 0); Starts recording of events to the given file. void Stop(Bool_t guiCommand = kFALSE); Stops recording of events. Bool_t Replay(const char *filename, Bool_t showMouseCursor = kTRUE, TRecorder::EReplayModes mode = kRealtime); Replays recorded events from given file. void Pause(); Pauses replaying. void Resume(); Resumes paused replaying. void ReplayStop(); Stops (cancels) replaying. void ListCmd(const char* ); Prints out the list of recorded commandline events. void ListGui(const char* ); Prints out the list of recorded GUI events. TRecorder::ERecorderState GetState() const; Gets current state of recorder. void PrevCanvases(const char* , Option_t* ); Saves all the canvases previous to the TRecorder. virtual ~TRecorderState(); {}. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
https://root.cern/root/html528/TRecWinPair.html:3692,Availability,error,error,3692,"Pair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:3776,Availability,error,error,3776," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:351,Integrability,interface,interface,351,". TRecWinPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecWinPair. class TRecWinPair: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In th",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:1186,Testability,log,logfile,1186,"s description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecWinPair. class TRecWinPair: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:2414,Usability,pause,pause,2414,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass()",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:2513,Usability,resume,resume,2513,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject:",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRecWinPair.html:2520,Usability,pause,paused,2520,"are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject:",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
https://root.cern/root/html528/TRedirectOutputGuard.html:377,Safety,safe,safe,377,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRedirectOutputGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRedirectOutputGuard.html
https://root.cern/root/html528/TRedirectOutputGuard.html:695,Safety,safe,safe,695,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRedirectOutputGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRedirectOutputGuard.html
https://root.cern/root/html528/TRef.html:10633,Availability,error,error,10633," obj); TRef(const TRef& ref); virtual~TRef(); voidTObject::AbstractMethod(const char* method) const; static Int_tAddExec(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TObjArray*GetListOfExecs(); virtual const char*TObject::GetName() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TProcessID*GetPID() const; static TObject*GetStaticObject(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual void",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:10717,Availability,error,error,10717,"* method) const; static Int_tAddExec(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TObjArray*GetListOfExecs(); virtual const char*TObject::GetName() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TProcessID*GetPID() const; static TObject*GetStaticObject(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:1709,Deployability,update,updated,1709,"t only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to the value; stored in the TObjArray of TFile::fProcessIDs (fProcessIDs[pidf]).; The pidf is stored in the bits 24->31 of the fUniqueID of the TR",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:814,Integrability,depend,dependencies,814,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The ",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:6388,Performance,load,load,6388,"med to be the name of a TExec object.; When a file is connected, the dictionary of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keywork ""EXEC:"" in case a TExec with a same name does; not already exist.; The action to be executed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the int",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:798,Safety,avoid,avoid,798,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The ",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:4166,Safety,avoid,avoid,4166," read by TObject::Streamer, the pidf is read.; At this point, robj is entered into the table of objects of the TProcessID; corresponding to pidf. WARNING1: If MyClass is the class of the referenced object, The TObject; part of MyClass must be Streamed. One should not; call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2: A TRef cannot point to another TRef. ObjectNumber. When an object is referenced (see TRef assignement operator or TRefArray::Add); a unique identifier is computed and stored in both the fUniqueID of the; referenced and referencing object. This uniqueID is computed by incrementing; by one the static global in TProcessID::fgNumber. fUniqueID is some sort of; serial object number in the current session. One can retrieve at any time; the current value of fgNumber by calling the static function TProcessID::GetObjectCount; or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example,; one processes many events in a loop, it might be necessary to reset the; ObjectNumber at the end of processing of one event. See an example; in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be; saved at the beginning of one event and reset to this original value; at the end of the event via TProcessID::SetObjectCount(saveNumber). These; actions may be stacked. Action on Demand. The normal behaviour of a TRef has been described above. In addition,; TRef supports also ""Actions on Demand"". It may happen that the object; referenced is not yet in memory, on a separate file or not yet computed.; In this case TRef is able to automatically execute an action:; - call to a compiled function (static function of member function); - call to an interpreted function; - execution of a CINT script. How to select this option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; Whe",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:8265,Safety,detect,detected,8265,"function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the function GetWebHistogram. This script connects a file; with histograms: pippa.root on the ROOT Web site and returns the object h6; to TRef::GetObject.; Note that if the definition of the TRef fWebHistogram had been:; TRef fWebHistogram; //EXEC:GetWebHistogram(); then, the compiled or interpreted function GetWebHistogram() would have; been called instead of the CINT script GetWebHistogram.C. Special case of a TRef pointing to an object with a TUUID. If the referenced object has a TUUID, its bit kHasUUID has been set.; This case is detected by the TRef assignement operator.; (For example, TFile and TDirectory have a TUUID); The TRef fPID points directly to the single object TProcessUUID (deriving; from TProcessID) and managing the list of TUUIDs for a process.; The TRef kHasUUID bit is set and its fUniqueID is set to the fUniqueID; of the referenced object.; When the TRef is streamed to a buffer, the corresponding TUUID is also; streamed with the TRef. When a TRef is read from a buffer, the corresponding; TUUID is also read and entered into the global list of TUUIDs (if not; already there). The TRef fUniqueID is set to the UUIDNumber.; see TProcessUUID for more details. Array of TRef. The special class TRefArray should be used to store multiple references.; A TRefArray has one single pointer fPID for all objects in the array.; It has a dynamic compact table of fUniqueIDs. Use a TRefArray rather; then a collection of TRefs if all TRefs stem from the same process. Example:; Suppose a TObjArray *mytracks containing a list of Trac",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:6685,Security,access,access,6685,"ed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the funct",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:6842,Security,access,accessing,6842,"; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the function GetWebHistogram. This script connects a file; with histograms: pippa.root on the ROOT Web site and returns t",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:16468,Security,access,access,16468,"TRef assignment operator. Int_t AddExec(const char* name); If Exec with name does not exist in the list of Execs, it is created.; returns the index of the Exec in the list. TObjArray * GetListOfExecs(); Return a pointer to the static TObjArray holding the list of Execs. TObject * GetObject() const; Return a pointer to the referenced object. void SetAction(const char* name); Store the exec number (in the ROOT list of Execs); into the fBits of this TRef. void SetAction(TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corresponding exec number into fBits.; This function searches a data member in the class of parent with an; offset corresponding to this.; If a comment ""TEXEC:"" is found in the comment field of the data member,; the function stores the exec identifier of the exec statement; following this keyword. TObject * GetStaticObject(); Returns the static object. void SetObject(TObject* obj); static Obsolete function kept for back compatibility.; In the near future will print a Warning, then will be deleted. void SetStaticObject(TObject* obj); Static function to set the object found on the Action on Demand function.; This function may be called by the user in the function called; when a ""EXEC:"" keyword is specified in the data member field of the TRef.; The function can get access to the dereferencing TRef (i.e. this)using; the static function GetStaticObject(). void Streamer(TBuffer& b); Stream an object of class TRef. TRef(); { }. virtual ~TRef(); { }. TProcessID * GetPID() const; {return fPID;}. Bool_t IsValid() const; {return GetUniqueID()!=0 ? kTRUE : kFALSE;}. » Author: Rene Brun 28/09/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TRef.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-12-10 21:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:4391,Testability,test,test,4391,"; corresponding to pidf. WARNING1: If MyClass is the class of the referenced object, The TObject; part of MyClass must be Streamed. One should not; call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2: A TRef cannot point to another TRef. ObjectNumber. When an object is referenced (see TRef assignement operator or TRefArray::Add); a unique identifier is computed and stored in both the fUniqueID of the; referenced and referencing object. This uniqueID is computed by incrementing; by one the static global in TProcessID::fgNumber. fUniqueID is some sort of; serial object number in the current session. One can retrieve at any time; the current value of fgNumber by calling the static function TProcessID::GetObjectCount; or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example,; one processes many events in a loop, it might be necessary to reset the; ObjectNumber at the end of processing of one event. See an example; in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be; saved at the beginning of one event and reset to this original value; at the end of the event via TProcessID::SetObjectCount(saveNumber). These; actions may be stacked. Action on Demand. The normal behaviour of a TRef has been described above. In addition,; TRef supports also ""Actions on Demand"". It may happen that the object; referenced is not yet in memory, on a separate file or not yet computed.; In this case TRef is able to automatically execute an action:; - call to a compiled function (static function of member function); - call to an interpreted function; - execution of a CINT script. How to select this option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; When the special keyword ""EXEC:"" is found in the comment field of the member,; the next string is assumed to be the name of",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:7158,Testability,test,test,7158,">SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the function GetWebHistogram. This script connects a file; with histograms: pippa.root on the ROOT Web site and returns the object h6; to TRef::GetObject.; Note that if the definition of the TRef fWebHistogram had been:; TRef fWebHistogram; //EXEC:GetWebHistogram(); then, the compiled or interpreted function GetWebHistogram() would have; been called instead of the CINT script GetWebHistogram.C. Special case o",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRef.html:1616,Usability,simpl,simply,1616,"ent Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to t",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
https://root.cern/root/html528/TRefArray.html:1246,Availability,error,error,1246,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = ",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:4121,Availability,error,error,4121,"ction::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; Int_tGetEntriesFast() const; virtual const char*TObject::GetIconName() const; Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetO",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:4205,Availability,error,error,4205,"); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; Int_tGetEntriesFast() const; virtual const char*TObject::GetIconName() const; Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TProcessID*GetPID() const; virtual Int_tTCollection::GetSize() const;",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:12991,Availability,error,error,12991,"nsertion semantics; use either a TList or a TOrdCollection. void AddLast(TObject* obj); Add object in the next empty slot in the array. Expand the array; if necessary. void AddBefore(const TObject* before, TObject* obj); Add object in the slot before object before. If before=0 add object; in the first slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array and free the internal memory. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * GetFromTable(Int_t idx) const; the reference may be in the TRefTable. void Streamer(TBuffer& b); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 ",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:15196,Availability,error,error,15196,"u want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetLast()+1. Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. UInt_t GetUID(Int_t at) const; Return UID of element at. Int_t IndexOf(const TObject* obj) const; obj != 0 Return index of object in array.; Returns lowerBound-1 in case array doesn't contain the obj. obj == 0 Return the index of the first empty slot.; Returns lowerBound-1 in case array doesn't contain any empty slot. void Init(Int_t s, Int_t lowerBound); Initialize a TRefArray. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns an array iterator. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void SetLast(Int_t last); Set index of last object in array, effectively truncating the; array. Use carefully since whenever last position has to be; recalculated, e.g. after a Remove() or Sort() it will be reset; to the last non-empty slot. If last is -2 this will force the; recalculation of the last used slot. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. Int_t BinarySearch(TObject* obj, Int_t upto = kMaxInt); Find object using a binary search. Array must first have been sorted.; Search can be limited by setting upto to desired index. Bool_t BoundsOk(const char* where, Int_t at) const. TObject * operator[](Int_t at) const. TObject * At(Int_t at) const; Return the object at position i. Returns 0 if i is out of bounds",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:1252,Integrability,message,message,1252,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = ",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefArray.html:1743,Testability,test,test,1743," process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = 0); virtual~TRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tAddAtFree(TObject* obj); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual vo",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
https://root.cern/root/html528/TRefTable.html:2649,Availability,error,error,2649,"wner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExpand(Int_t pid, Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(TBuffer& b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN(Int_t pid) const; virtual const char*TObject::GetName() const; Int_tGetNumPIDs() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetOwner() const; TObject*GetParent(Int_t uid, TProcessID* context = 0) const; TObjArray*GetParents() const; static TRefTable*GetRefTable(); Int_tGetSize(Int_t pid) const",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:2733,Availability,error,error,2733,"od) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExpand(Int_t pid, Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(TBuffer& b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN(Int_t pid) const; virtual const char*TObject::GetName() const; Int_tGetNumPIDs() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetOwner() const; TObject*GetParent(Int_t uid, TProcessID* context = 0) const; TObjArray*GetParents() const; static TRefTable*GetRefTable(); Int_tGetSize(Int_t pid) const; virtual const char*TObject::GetTitle() const; UInt_tGetUID() const; TProcessID*Get",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:7264,Energy Efficiency,allocate,allocated,7264,"rIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<std::string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:623,Performance,load,loaded,623,". TRefTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TRefTable. class TRefTable: public TObject. A TRefTable maintains the association between a referenced object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """")",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:1424,Performance,load,loading,1424,"object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:1512,Performance,cache,cached,1512,"e corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidT",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:7403,Performance,cache,cache,7403,"rIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<std::string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:6777,Usability,guid,guid,6777,"ol_t stat); virtual Int_tSetParent(const TObject* parent, Int_t branchID); static voidSetRefTable(TRefTable* table); virtual voidSetUID(UInt_t uid, TProcessID* context = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tAddInternalIdxForPID(TProcessID* procid); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tExpandForIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumP",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:9171,Usability,guid,guid,9171," Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static function returning the current TRefTable. Bool_t Notify(); This function is called by TRef::Streamer or TStreamerInfo::ReadBuffer; when reading a reference.; This function, in turns, notifies the TRefTable owner for action.; eg, when the owner is a TBranchRef, TBranchRef::Notify is called; to read the branch containing the referenced object. void ReadBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::ReadLeaves. vo",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRefTable.html:9237,Usability,guid,guid,9237," Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. void Clear(Option_t* = """"); Clear all entries in the table. Int_t Expand(Int_t pid, Int_t newsize); Expand fParentIDs to newsize for ProcessID pid. Int_t ExpandForIID(Int_t iid, Int_t newsize); Expand fParentIDs to newsize for internel ProcessID index iid. void ExpandPIDs(Int_t numpids); Expand the arrays of managed PIDs. void FillBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::FillLeaves. Int_t FindPIDGUID(const char* guid) const; Get fProcessGUIDs' index of the TProcessID with GUID guid. TObject * GetParent(Int_t uid, TProcessID* context = 0) const; Return object corresponding to uid. Int_t GetInternalIdxForPID(TProcessID* procid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. Int_t GetInternalIdxForPID(Int_t pid) const; Get the index for fProcessIDs, fAllocSize, etc given a PID.; Uses fMapPIDtoInternal and the pid's GUID / fProcessGUID. TRefTable * GetRefTable(); Static function returning the current TRefTable. Bool_t Notify(); This function is called by TRef::Streamer or TStreamerInfo::ReadBuffer; when reading a reference.; This function, in turns, notifies the TRefTable owner for action.; eg, when the owner is a TBranchRef, TBranchRef::Notify is called; to read the branch containing the referenced object. void ReadBuffer(TBuffer& b); Fill buffer b with the fN elements in fParentdIDs.; This function is called by TBranchRef::ReadLeaves. vo",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
https://root.cern/root/html528/TRegexp.html:2452,Integrability,rout,routine,2452,"piled pattern; TRegexp::EStatValfStatStatus; static const unsigned intfgMaxpatMax length of compiled pattern. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRegexp(const char* re, Bool_t wildcard = kFALSE); Create a regular expression from the input string. If wildcard is true; then the input string contains a wildcard expression (see MakeWildcard()). TRegexp(const TString& re); Create a regular expression from a TString. TRegexp(const TRegexp& re); Copy ctor. ~TRegexp(); Destructor. TRegexp& operator=(const TRegexp& re); Assignment operator. TRegexp& operator=(const char* re); Assignment operator taking a char* and assigning it to a regexp. TRegexp& operator=(const TString& re); Assignment operator taking a TString. void GenPattern(const char* re); Generate the regular expression pattern. void CopyPattern(const TRegexp& re); Copy the regular expression pattern. const char * MakeWildcard(const char* re); This routine transforms a wildcarding regular expression into; a general regular expression used for pattern matching.; When using wildcards the regular expression is assumed to be; preceded by a ""^"" (BOL) and terminated by a ""$"" (EOL). Also, all; ""*""'s and ""?""'s (closures) are assumed to be preceded by a ""."" (i.e. any; character, except ""/""'s) and all .'s are escaped (so *.ps is different; from *.eps). The special treatment of ""/"" allows the easy matching of; pathnames, e.g. ""*.root"" will match ""aap.root"", but not ""pipo/aap.root"". Ssiz_t Index(const TString& str, Ssiz_t* len, Ssiz_t start = 0) const; Find the first occurance of the regexp in string and return the position.; Len is length of the matched string and i is the offset at which the; matching should start. EStatVal Status(). » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRegexp.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-29 11:48; This page has been automatically ge",MatchSource.WIKI,root/html528/TRegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRegexp.html
https://root.cern/root/html528/TRemoteObject.html:1808,Availability,error,error,1808,"* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClassName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetFileStat(FileStat_t* sbuf); virtual const char*TObject::GetIconName() const; const char*GetKeyClassName() const; const char*GetKeyObjectName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(T",MatchSource.WIKI,root/html528/TRemoteObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRemoteObject.html
https://root.cern/root/html528/TRemoteObject.html:1892,Availability,error,error,1892,"ect::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClassName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetFileStat(FileStat_t* sbuf); virtual const char*TObject::GetIconName() const; const char*GetKeyClassName() const; const char*GetKeyObjectName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const ",MatchSource.WIKI,root/html528/TRemoteObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRemoteObject.html
https://root.cern/root/html528/TRemoteObject.html:347,Integrability,protocol,protocol,347,". TRemoteObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRemoteObject. class TRemoteObject: public TNamed. TRemoteObject. The TRemoteObject class provides protocol for browsing ROOT objects; from a remote ROOT session.; It contains informations on the real remote object as:; - Object Properties (i.e. file stat if the object is a TSystemFile); - Object Name; - Class Name; - TKey Object Name (if the remote object is a TKey); - TKey Class Name (if the remote object is a TKey); - Remote object address. Function Members (Methods); public:. TRemoteObject(); TRemoteObject(const TRemoteObject&); TRemoteObject(const char* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(co",MatchSource.WIKI,root/html528/TRemoteObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRemoteObject.html
https://root.cern/root/html528/TResponseTable.html:2747,Availability,error,error,2747,"ws(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorTGenericTable::end(); TGenericTable::iteratorTGenericTable::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; static Int_tFindResponseLocation(TTableDescriptor& dsc); virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000",MatchSource.WIKI,root/html528/TResponseTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TResponseTable.html
https://root.cern/root/html528/TResponseTable.html:2831,Availability,error,error,2831,"ool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorTGenericTable::end(); TGenericTable::iteratorTGenericTable::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; static Int_tFindResponseLocation(TTableDescriptor& dsc); virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqColle",MatchSource.WIKI,root/html528/TResponseTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TResponseTable.html
https://root.cern/root/html528/TRint.html:3895,Availability,error,error,3895,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:3979,Availability,error,error,3979,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:4123,Availability,error,error,4123,"); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:7910,Availability,error,error,7910,"od) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintLogo(Bool_t lite = kFALSE); virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, cons",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:8031,Availability,error,error,8031,"lication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintLogo(Bool_t lite = kFALSE); virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); virtual const char*SetPrompt(const char* newPrompt); vo",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:11136,Availability,error,error,11136,"Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. TRint(const TRint&); voidExecLogon(); TRint&operator=(const TRint&); virtual Long_tProcessRemote(const char* line, Int_t* error = 0). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d]",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:11999,Availability,avail,available,11999,"ebug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. TRint(const TRint&); voidExecLogon(); TRint&operator=(const TRint&); virtual Long_tProcessRemote(const char* line, Int_t* error = 0). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are thr",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:13577,Availability,error,error,13577,"op via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Res",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:13620,Availability,error,error,13620,"op via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Res",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:14761,Availability,echo,echo,14761,"mpt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); Set console mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. TRint(const TRint& ). TRint& operator=(const TRint& ). void Interrupt(); { fInterrupt = kTRUE; }. » Author: Rene Brun 17/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TRint.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-27 22:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:14865,Availability,error,error,14865,"mpt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); Set console mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. TRint(const TRint& ). TRint& operator=(const TRint& ). void Interrupt(); { fInterrupt = kTRUE; }. » Author: Rene Brun 17/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TRint.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-27 22:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12541,Integrability,interface,interface,12541,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12601,Modifiability,inherit,inheritance,12601,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:14686,Modifiability,variab,variable,14686,"a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); Set console mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. TRint(const TRint& ). TRint& operator=(const TRint& ). void Interrupt(); { fInterrupt = kTRUE; }. » Author: Rene Brun 17/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TRint.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-27 22:33; This page has been automatically generated. For comments",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:15016,Modifiability,variab,variable,15016,"mpt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); Set console mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. TRint(const TRint& ). TRint& operator=(const TRint& ). void Interrupt(); { fInterrupt = kTRUE; }. » Author: Rene Brun 17/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TRint.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-27 22:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:349,Security,access,access,349,". TRint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TRint. class TRint: public TApplication. Rint. Rint is the ROOT Interactive Interface. It allows interactive access; to the ROOT system via the CINT C/C++ interpreter. Function Members (Methods); public:. TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); virtual~TRint(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; static voidTApplication::CreateApplication(); ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12667,Security,access,access,12667,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12773,Testability,log,logon,12773,"of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12814,Testability,log,logon,12814,"used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]""",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12862,Testability,log,logon,12862,"used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]""",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12909,Testability,log,logon,12909,"ockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:12997,Testability,log,logon,12997,"of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:13110,Testability,log,logon,13110,"ruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:13742,Testability,log,logo,13742,"Rint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRint.html:14637,Testability,log,logoff,14637,"f any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. char * GetPrompt(); Get prompt from interpreter. Either ""root [n]"" or ""end with '}'"". const char * SetPrompt(const char* newPrompt); Set a new default prompt. It returns the previous prompt.; The prompt may contain a %d which will be replaced by the commend; number. The default prompt is ""root [%d] "". The maximum length of; the prompt is 55 characters. To set the prompt in an interactive; session do:; root [0] ((TRint*)gROOT->GetApplication())->SetPrompt(""aap> ""); aap>. Bool_t HandleTermInput(); Handle input coming from terminal. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Terminate(int status); Terminate the application. Reset the terminal to sane mode and call; the logoff macro defined via Rint.Logoff environment variable. void SetEchoMode(Bool_t mode); Set console mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. TRint(const TRint& ). TRint& operator=(const TRint& ). void Interrupt(); { fInterrupt = kTRUE; }. » Author: Rene Brun 17/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id: TRint.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-27 22:33; This",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
https://root.cern/root/html528/TRobustEstimator.html:567,Availability,robust,robust,567,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:633,Availability,robust,robustness,633,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:669,Availability,robust,robust,669,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1005,Availability,robust,robust,1005,"imator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1081,Availability,error,errors,1081," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1185,Availability,reliab,reliably,1185," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1375,Availability,robust,robust,1375,"ast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this al",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1473,Availability,robust,robust,1473," Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; th",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1533,Availability,robust,robust,1533,"Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter i",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:2502,Availability,robust,robust,2502,"stances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter is a tool to robustify; other multivariate techniques such as, for example, principal-component analysis; and discriminant analysis. Technical details of the algorithm:; 0.The default h = (n+nvariables+1)/2, but the user may choose any interger h with; (n+nvariables+1)/2<=h<=n. The program then reports the MCD's breakdown value; (n-h+1)/n. If you are sure that the dataset contains less than 25% contamination; which is usually the case, a good compromise between breakdown value and; efficiency is obtained by putting h=[.75*n].; 1.If h=n,the MCD location estimate is the average of the whole dataset, and; the MCD scatter estimate is its covariance matrix. Report this and stop; 2.If nvariables=1 (univariate data), compute the MCD estimate by the exact; algorithm of Rousseeuw and Leroy (1987, pp.171-172) in O(nlogn)time and stop; 3.From here on, h<n and nvariables>=2.; 3a.If n is small:; - repeat (say) 500 times:; -- construct an initial h-subset, starting from a random (nvar+1)-subset; -- carry out 2 C-steps (described in the com",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:2557,Availability,robust,robustify,2557,"stances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter is a tool to robustify; other multivariate techniques such as, for example, principal-component analysis; and discriminant analysis. Technical details of the algorithm:; 0.The default h = (n+nvariables+1)/2, but the user may choose any interger h with; (n+nvariables+1)/2<=h<=n. The program then reports the MCD's breakdown value; (n-h+1)/n. If you are sure that the dataset contains less than 25% contamination; which is usually the case, a good compromise between breakdown value and; efficiency is obtained by putting h=[.75*n].; 1.If h=n,the MCD location estimate is the average of the whole dataset, and; the MCD scatter estimate is its covariance matrix. Report this and stop; 2.If nvariables=1 (univariate data), compute the MCD estimate by the exact; algorithm of Rousseeuw and Leroy (1987, pp.171-172) in O(nlogn)time and stop; 3.From here on, h<n and nvariables>=2.; 3a.If n is small:; - repeat (say) 500 times:; -- construct an initial h-subset, starting from a random (nvar+1)-subset; -- carry out 2 C-steps (described in the com",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:4661,Availability,robust,robust,4661,"tion); - for the 10 results with lowest det(S):; -- carry out C-steps until convergence; - report the solution (T, S) with the lowest det(S); 3b.If n is larger (say, n>600), then; - construct up to 5 disjoint random subsets of size nsub (say, nsub=300); - inside each subset repeat 500/5 times:; -- construct an initial subset of size hsub=[nsub*h/n]; -- carry out 2 C-steps; -- keep the best 10 results (Tsub, Ssub); - pool the subsets, yielding the merged set (say, of size nmerged=1500); - in the merged set, repeat for each of the 50 solutions (Tsub, Ssub); -- carry out 2 C-steps; -- keep the 10 best results; - in the full dataset, repeat for those best results:; -- take several C-steps, using n and h; -- report the best final result (T, S); 4.To obtain consistency when the data comes from a multivariate normal; distribution, covariance matrix is multiplied by a correction factor; 5.Robust distances for all elements, using the final (T, S) are calculated; Then the very final mean and covariance estimates are calculated only for; values, whose robust distances are less than a cutoff value (0.975 quantile; of chi2 distribution with nvariables degrees of freedom). Function Members (Methods); public:. TRobustEstimator(); TRobustEstimator(const TRobustEstimator&); TRobustEstimator(Int_t nvectors, Int_t nvariables, Int_t hh = 0); virtual~TRobustEstimator(); voidTObject::AbstractMethod(const char* method) const; voidAddColumn(Double_t* col); voidAddRow(Double_t* row); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTO",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:6057,Availability,error,error,6057," voidAddRow(Double_t* row); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvaluate(); voidEvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBDPoint(); Double_tGetChiQuant(Int_t i) const; const TMatrixDSym*GetCorrelation() const; voidGetCorrelation(TMatrixDSym& matr); const TMatrixDSym*GetCovariance() const; voidGetCovariance(TMatrixDSym& matr); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TVectorD*GetHyperplane() const; voidGetHyperplane(TVectorD& vec); virtual const char*TObject::GetIconName() const; const TVectorD*GetMean() const; voidGetMean(TVectorD& means); virtual const char*TObject::GetName() const; Int_tGetNHyp(); Int_tGetNOut(); Int_tGetNumberObservations() const; Int_tGetNvar() const; virtual char*TObject::",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:6141,Availability,error,error,6141,"irtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvaluate(); voidEvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBDPoint(); Double_tGetChiQuant(Int_t i) const; const TMatrixDSym*GetCorrelation() const; voidGetCorrelation(TMatrixDSym& matr); const TMatrixDSym*GetCovariance() const; voidGetCovariance(TMatrixDSym& matr); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TVectorD*GetHyperplane() const; voidGetHyperplane(TVectorD& vec); virtual const char*TObject::GetIconName() const; const TVectorD*GetMean() const; voidGetMean(TVectorD& means); virtual const char*TObject::GetName() const; Int_tGetNHyp(); Int_tGetNOut(); Int_tGetNumberObservations() const; Int_tGetNvar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virt",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:11799,Availability,robust,robust,11799,"ubdat, Int_t ngroup, Int_t* indsubdat). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSymfCorrelationcorrelation matrix; TMatrixDSymfCovariancecovariance matrix estimate; TMatrixDfDatathe original data; Int_tfExactif there was an exact fit, stores the number of points on a hyperplane ; Int_tfHalgorithm parameter, determining the subsample size; TVectorDfHyperplanein case more than fH observations lie on a hyperplane; TMatrixDSymfInvcovarianceinverse of the covariance matrix; TVectorDfMeanlocation estimate (mean values); Int_tfNnumber of observations; Int_tfNvarnumber of variables; TArrayIfOutarray of indexes of ouliers, size <0.5*n; TVectorDfRdarray of robust distances, size n; TVectorDfSdarray of standard deviations; Int_tfVarTempnumber of variables already added to the data matrix; Int_tfVecTempnumber of observations already added to the data matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRobustEstimator(); this constructor should be used in a univariate case:; first call this constructor, then - the EvaluateUni(..) function. TRobustEstimator(Int_t nvectors, Int_t nvariables, Int_t hh = 0); constructor. void AddColumn(Double_t* col); adds a column to the data matrix; it is assumed that the column has size fN; variable fVarTemp keeps the number of columns l; already added. void AddRow(Double_t* row); adds a vector to the data matrix; it is supposed that the vector is of size fNvar. void Evaluate(); Finds the estimate of multivariate mean and variance. void EvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works o",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:13615,Availability,robust,robust,13615,"); Finds the estimate of multivariate mean and variance. void EvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determi",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:16610,Availability,robust,robust,16610,"d S_inv - the inverse of its covariance matrix, then; htotal elements with smallest distances will have covariance matrix with determinant; less or equal to the determinant of the input subset covariance matrix. determinant for this htotal-subset with smallest distances is returned. Int_t Exact(Double_t* ndist); for the exact fit situaions; returns number of observations on the hyperplane. Int_t Exact2(TMatrixD& mstockbig, TMatrixD& cstockbig, TMatrixD& hyperplane, Double_t* deti, Int_t nbest, Int_t kgroup, TMatrixD& sscp, Double_t* ndist); This function is called if determinant of the covariance matrix of a subset=0. If there are more then fH vectors on a hyperplane,; returns this hyperplane and stops; else stores the hyperplane coordinates in hyperplane matrix. Int_t Partition(Int_t nmini, Int_t* indsubdat); divides the elements into approximately equal subgroups; number of elements in each subgroup is stored in indsubdat; number of subgroups is returned. Int_t RDist(TMatrixD& sscp); Calculates robust distances.Then the samples with robust distances; greater than a cutoff value (0.975 quantile of chi2 distribution with; fNvar degrees of freedom, multiplied by a correction factor), are given; weiht=0, and new, reweighted estimates of location and scatter are calculated; The function returns the number of outliers. void RDraw(Int_t* subdat, Int_t ngroup, Int_t* indsubdat); Draws ngroup nonoverlapping subdatasets out of a dataset of size n; such that the selected case numbers are uniformly distributed from 1 to n. Double_t KOrdStat(Int_t ntotal, Double_t* arr, Int_t k, Int_t* work); because I need an Int_t work array. TRobustEstimator(). virtual ~TRobustEstimator(); {;}. void GetCovariance(TMatrixDSym& matr). void GetCorrelation(TMatrixDSym& matr). Int_t GetNHyp(); {return fExact;}. void GetMean(TVectorD& means). void GetRDistances(TVectorD& rdist). Int_t GetNumberObservations() const; {return fN;}. Int_t GetNvar() const; {return fNvar;}. const TArrayI* GetOuliers() ",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:16649,Availability,robust,robust,16649,"ments with smallest distances will have covariance matrix with determinant; less or equal to the determinant of the input subset covariance matrix. determinant for this htotal-subset with smallest distances is returned. Int_t Exact(Double_t* ndist); for the exact fit situaions; returns number of observations on the hyperplane. Int_t Exact2(TMatrixD& mstockbig, TMatrixD& cstockbig, TMatrixD& hyperplane, Double_t* deti, Int_t nbest, Int_t kgroup, TMatrixD& sscp, Double_t* ndist); This function is called if determinant of the covariance matrix of a subset=0. If there are more then fH vectors on a hyperplane,; returns this hyperplane and stops; else stores the hyperplane coordinates in hyperplane matrix. Int_t Partition(Int_t nmini, Int_t* indsubdat); divides the elements into approximately equal subgroups; number of elements in each subgroup is stored in indsubdat; number of subgroups is returned. Int_t RDist(TMatrixD& sscp); Calculates robust distances.Then the samples with robust distances; greater than a cutoff value (0.975 quantile of chi2 distribution with; fNvar degrees of freedom, multiplied by a correction factor), are given; weiht=0, and new, reweighted estimates of location and scatter are calculated; The function returns the number of outliers. void RDraw(Int_t* subdat, Int_t ngroup, Int_t* indsubdat); Draws ngroup nonoverlapping subdatasets out of a dataset of size n; such that the selected case numbers are uniformly distributed from 1 to n. Double_t KOrdStat(Int_t ntotal, Double_t* arr, Int_t k, Int_t* work); because I need an Int_t work array. TRobustEstimator(). virtual ~TRobustEstimator(); {;}. void GetCovariance(TMatrixDSym& matr). void GetCorrelation(TMatrixDSym& matr). Int_t GetNHyp(); {return fExact;}. void GetMean(TVectorD& means). void GetRDistances(TVectorD& rdist). Int_t GetNumberObservations() const; {return fN;}. Int_t GetNvar() const; {return fNvar;}. const TArrayI* GetOuliers() const; {return &fOut;}. » Last changed: root/physics:$Id: TRobust",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:13754,Deployability,update,update,13754," Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:2037,Modifiability,variab,variables,2037,"both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter is a tool to robustify; other multivariate techniques such as, for example, principal-component analysis; and discriminant analysis. Technical details of the algorithm:; 0.The default h = (n+nvariables+1)/2, but the user may choose any interger h with; (n+nvariables+1)/2<=h<=n. The program then reports the MCD's breakdown value; (n-h+1)/n. If you are sure that the dataset contains less than 25% contamination; which is usually the case, a good comp",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:11715,Modifiability,variab,variables,11715,"mt, va_list va) const; Int_tExact(Double_t* ndist); Int_tExact2(TMatrixD& mstockbig, TMatrixD& cstockbig, TMatrixD& hyperplane, Double_t* deti, Int_t nbest, Int_t kgroup, TMatrixD& sscp, Double_t* ndist); Double_tKOrdStat(Int_t ntotal, Double_t* arr, Int_t k, Int_t* work); voidTObject::MakeZombie(); Int_tPartition(Int_t nmini, Int_t* indsubdat); Int_tRDist(TMatrixD& sscp); voidRDraw(Int_t* subdat, Int_t ngroup, Int_t* indsubdat). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSymfCorrelationcorrelation matrix; TMatrixDSymfCovariancecovariance matrix estimate; TMatrixDfDatathe original data; Int_tfExactif there was an exact fit, stores the number of points on a hyperplane ; Int_tfHalgorithm parameter, determining the subsample size; TVectorDfHyperplanein case more than fH observations lie on a hyperplane; TMatrixDSymfInvcovarianceinverse of the covariance matrix; TVectorDfMeanlocation estimate (mean values); Int_tfNnumber of observations; Int_tfNvarnumber of variables; TArrayIfOutarray of indexes of ouliers, size <0.5*n; TVectorDfRdarray of robust distances, size n; TVectorDfSdarray of standard deviations; Int_tfVarTempnumber of variables already added to the data matrix; Int_tfVecTempnumber of observations already added to the data matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRobustEstimator(); this constructor should be used in a univariate case:; first call this constructor, then - the EvaluateUni(..) function. TRobustEstimator(Int_t nvectors, Int_t nvariables, Int_t hh = 0); constructor. void AddColumn(Double_t* col); adds a column to the data matrix; it is assumed that the column has size fN; variable fVarTemp keeps the number of columns l; already added. void AddR",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:11889,Modifiability,variab,variables,11889,"ubdat, Int_t ngroup, Int_t* indsubdat). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSymfCorrelationcorrelation matrix; TMatrixDSymfCovariancecovariance matrix estimate; TMatrixDfDatathe original data; Int_tfExactif there was an exact fit, stores the number of points on a hyperplane ; Int_tfHalgorithm parameter, determining the subsample size; TVectorDfHyperplanein case more than fH observations lie on a hyperplane; TMatrixDSymfInvcovarianceinverse of the covariance matrix; TVectorDfMeanlocation estimate (mean values); Int_tfNnumber of observations; Int_tfNvarnumber of variables; TArrayIfOutarray of indexes of ouliers, size <0.5*n; TVectorDfRdarray of robust distances, size n; TVectorDfSdarray of standard deviations; Int_tfVarTempnumber of variables already added to the data matrix; Int_tfVecTempnumber of observations already added to the data matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRobustEstimator(); this constructor should be used in a univariate case:; first call this constructor, then - the EvaluateUni(..) function. TRobustEstimator(Int_t nvectors, Int_t nvariables, Int_t hh = 0); constructor. void AddColumn(Double_t* col); adds a column to the data matrix; it is assumed that the column has size fN; variable fVarTemp keeps the number of columns l; already added. void AddRow(Double_t* row); adds a vector to the data matrix; it is supposed that the vector is of size fNvar. void Evaluate(); Finds the estimate of multivariate mean and variance. void EvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works o",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:12422,Modifiability,variab,variable,12422," points on a hyperplane ; Int_tfHalgorithm parameter, determining the subsample size; TVectorDfHyperplanein case more than fH observations lie on a hyperplane; TMatrixDSymfInvcovarianceinverse of the covariance matrix; TVectorDfMeanlocation estimate (mean values); Int_tfNnumber of observations; Int_tfNvarnumber of variables; TArrayIfOutarray of indexes of ouliers, size <0.5*n; TVectorDfRdarray of robust distances, size n; TVectorDfSdarray of standard deviations; Int_tfVarTempnumber of variables already added to the data matrix; Int_tfVecTempnumber of observations already added to the data matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRobustEstimator(); this constructor should be used in a univariate case:; first call this constructor, then - the EvaluateUni(..) function. TRobustEstimator(Int_t nvectors, Int_t nvariables, Int_t hh = 0); constructor. void AddColumn(Double_t* col); adds a column to the data matrix; it is assumed that the column has size fN; variable fVarTemp keeps the number of columns l; already added. void AddRow(Double_t* row); adds a vector to the data matrix; it is supposed that the vector is of size fNvar. void Evaluate(); Finds the estimate of multivariate mean and variance. void EvaluateUni(Int_t nvectors, Double_t* data, Double_t& mean, Double_t& sigma, Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hype",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:1197,Safety,detect,detected,1197," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:13826,Usability,clear,clear,13826,"ean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the inverse of the covariance matrix; htotal points with smallest distances are included in the",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRobustEstimator.html:14531,Usability,clear,clear,14531," GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the inverse of the covariance matrix; htotal points with smallest distances are included in the returned subset. void CreateOrtSubset(TMatrixD& dat, Int_t* index, Int_t hmerged, Int_t nmerged, TMatrixD& sscp, Double_t* ndist); creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane; hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0; This function is called in case when less than fH samples lie on a hyperplane. Double_t CStep(Int_t ntotal, Int_t htotal, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); from the input htotal-subset constructs another htotal subset with lower determinant. As proven by Peter J.Rousseeuw and Katrien Van Driessen, if distances for all elements; are calculated, using the f",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
https://root.cern/root/html528/TRolke.html:6516,Availability,error,error,6516,"(const TRolke&); TRolke(Double_t CL = 0.9, Option_t* option = """"); virtual~TRolke(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; boolGetBounding() const; Double_tGetCL() const; boolGetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; boolGetLimits(Double_t& low, Double_t& high); boolGetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); boolGetLimitsQuantile(Double_t& low, Double_t& high, Int_t& out_x, Double_t integral = 0.5); Double_tGetLowerLimit(); virtual con",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:6600,Availability,error,error,6600,"(const TRolke&); TRolke(Double_t CL = 0.9, Option_t* option = """"); virtual~TRolke(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; boolGetBounding() const; Double_tGetCL() const; boolGetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; boolGetLimits(Double_t& low, Double_t& high); boolGetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); boolGetLimitsQuantile(Double_t& low, Double_t& high, Int_t& out_x, Double_t integral = 0.5); Double_tGetLowerLimit(); virtual con",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:18560,Availability,error,error,18560,"s gives the median limits; in repeated experiments. The returned out_x is the corresponding; (e.g. median) value of x.; No uncertainties are considered for the Poisson weights when calculating; the Poisson integral . bool GetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); get the upper and lower limits for the most likely outcome.; The returned out_x is the corresponding value of x; No uncertainties are considered for the Poisson weights when finding ML . bool GetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); get the value of x corresponding to rejection of the null hypothesis.; This means a lower limit >0 with the pre-specified Confidence Level.; Optionally give maxtry; the maximum value of x to try. Of not, or if; maxtry<0 an automatic mode is used. void SetSwitch(bool bnd); Deprecated name for SetBounding. void Print(Option_t* ) const; Dump internals. Print members. Double_t CalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); Deprecated and error prone model selection interface.; It's use is trongly discouraged. 'mid' is the model ID (1 to 7).; This method is provided for backwards compatibility/developer use only. ; x : number of observed events in the experiment; y : number of observed events in background region; z : number of MC events observed; bm : estimate of the background; em : estimate of the efficiency; e : true efficiency (considered known); mid : internal model id (really, you should not use this method at all); sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. void SetModelParameters(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). x : number of observed events in ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:18588,Integrability,interface,interface,18588,"s gives the median limits; in repeated experiments. The returned out_x is the corresponding; (e.g. median) value of x.; No uncertainties are considered for the Poisson weights when calculating; the Poisson integral . bool GetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); get the upper and lower limits for the most likely outcome.; The returned out_x is the corresponding value of x; No uncertainties are considered for the Poisson weights when finding ML . bool GetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); get the value of x corresponding to rejection of the null hypothesis.; This means a lower limit >0 with the pre-specified Confidence Level.; Optionally give maxtry; the maximum value of x to try. Of not, or if; maxtry<0 an automatic mode is used. void SetSwitch(bool bnd); Deprecated name for SetBounding. void Print(Option_t* ) const; Dump internals. Print members. Double_t CalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); Deprecated and error prone model selection interface.; It's use is trongly discouraged. 'mid' is the model ID (1 to 7).; This method is provided for backwards compatibility/developer use only. ; x : number of observed events in the experiment; y : number of observed events in background region; z : number of MC events observed; bm : estimate of the background; em : estimate of the efficiency; e : true efficiency (considered known); mid : internal model id (really, you should not use this method at all); sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. void SetModelParameters(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). x : number of observed events in ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:1001,Safety,detect,detection,1001,". TRolke. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRolke. class TRolke: public TObject. TRolke. This class computes confidence intervals for the rate of a Poisson; process in the presence of uncertain background and/or efficiency. The treatment and the resulting limits are fully frequentist. The; limit calculations make use of the profile likelihood method. Author: Jan Conrad (CERN) 2004; Updated: Johan Lundberg (CERN) 2009. Copyright CERN 2004,2009 Jan.Conrad@cern.ch,; Johan.Lundberg@cern.ch. For a full list of methods and their syntax, and build instructions,; consult the header file TRolke.h. Examples/tutorials are found in the separate file Rolke.C. TRolke implements the following Models. The signal is always assumed to be Poisson, with the following; combinations of models of background and detection efficiency:. If unsure, first consider model 3, 4 or 5. 1: SetPoissonBkgBinomEff(x,y,z,tau,m). Background: Poisson; Efficiency: Binomial. when the background is simultaneously measured; from sidebands (or MC), and; the signal efficiency was determined from Monte Carlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal efficiency was determined fr",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:2274,Safety,detect,detection,2274,"rlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal efficiency was determined from Monte Carlo. 7: SetKnownBkgGaussEff(x,em,sde,b). Background: Known; Efficiency: Gaussian. when background is known and efficiency Gaussian. Parameters and further explanation. For all models:. x = number of observed events in the experiment. Efficiency (e or em) is the detection probability for signal.; A low efficiency hence generally means weaker limits.; If the efficiency of an experiment (with analysis cuts) is; dealt with elsewhere, em or e can be set to one. For Poisson background measurements (sideband or MC):. y = number of observed events in background region; tau =; Either: the ratio between signal and background region; in case background is observed.; Or: the ratio between observed and simulated live-time; in case background is determined from MC. For Gaussian efficiency or background:. bm = estimate of the background; sdb = corresponding standard deviation. em = estimate of the efficiency; sde = corresponding standard deviation. If the efficiency scale of dealt with elsewhere,; set em to 1 and sde to the relative uncertainty. For Binomial signal efficiency:. m = number of MC events generated; z = number of MC events observed. For the case of known background expectation or known efficiency:. e = true efficiency (considered known); b = back",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:26632,Testability,log,logGamma,26632," = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod7(Double_t mu, Double_t b, Double_t e, Int_t x, Double_t em, Double_t v); Profile Likelihood function for MODEL 6:; background known/ Efficiency gaussian. Double_t EvalPolynomial(Double_t x, const Int_t* coef, Int_t N); evaluate polynomial. Double_t EvalMonomial(Double_t x, const Int_t* coef, Int_t N); evaluate mononomial. Double_t LogFactorial(Int_t n); LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n!. TRolke(Double_t CL = 0.9, Option_t* option = """"); Constructor. Double_t GetCL() const; Get and set the Confidence Level. void SetCL(Double_t CL). void SetCLSigmas(Double_t CLsigmas); Set the Confidence Level in terms of Sigmas. bool GetBounding() const; Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . void SetBounding(const bool bnd); Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . » Last changed: Thu Sep 23 20:20:28 2010 » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TRolke.html:16986,Usability,simpl,simple,16986," true efficiency (considered known). void SetKnownBkgBinomEff(Int_t x, Int_t z, Int_t m, Double_t b); Model 6: Background - known, Efficiency - Binomial (x,z,m,b); x : number of observed events in the experiment; z : number of MC events observed; m : number of MC events generated; b : background expectation value (considered known). void SetKnownBkgGaussEff(Int_t x, Double_t em, Double_t sde, Double_t b); Model 7: Background - known, Efficiency - Gaussian (x,em,sde,b); x : number of observed events in the experiment; em : estimate of the efficiency; sde : efficiency estimate's standard deviation; b : background expectation value (considered known). bool GetLimits(Double_t& low, Double_t& high); Calculate and get the upper and lower limits for the pre-specified model. Double_t GetUpperLimit(); Calculate and get upper limit for the pre-specified model. Double_t GetLowerLimit(); Calculate and get lower limit for the pre-specified model. Double_t GetBackground(); Return a simple background value (estimate/truth) given the pre-specified model. bool GetSensitivity(Double_t& low, Double_t& high, Double_t pPrecision = 0.00001); get the upper and lower average limits based on the specified model.; No uncertainties are considered for the Poisson weights in the averaging sum. bool GetLimitsQuantile(Double_t& low, Double_t& high, Int_t& out_x, Double_t integral = 0.5); get the upper and lower limits for the outcome corresponding to; a given quantile.; For integral=0.5 this gives the median limits; in repeated experiments. The returned out_x is the corresponding; (e.g. median) value of x.; No uncertainties are considered for the Poisson weights when calculating; the Poisson integral . bool GetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); get the upper and lower limits for the most likely outcome.; The returned out_x is the corresponding value of x; No uncertainties are considered for the Poisson weights when finding ML . bool GetCriticalNumber(Int_t& ncrit, Int_t maxtry ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
https://root.cern/root/html528/TROOT.html:3727,Availability,error,error,3727,"irtual voidTDirectory::Close(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; static Int_tConvertVersionCode2Int(Int_t code); static Int_tConvertVersionInt2Code(Int_t v); virtual voidTDirectory::Copy(TObject&) const; static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); static Int_tDecreaseDirLevel(); virtual voidTDirectory::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplicat",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:3811,Availability,error,error,3811,"nst TObject* obj) const; static Int_tConvertVersionCode2Int(Int_t code); static Int_tConvertVersionInt2Code(Int_t v); virtual voidTDirectory::Copy(TObject&) const; static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); static Int_tDecreaseDirLevel(); virtual voidTDirectory::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGet",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:10251,Availability,error,error,10251,"dentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingMacro() const; virtual Bool_tIsFolder() const; Bool_tIsInterrupted() const; Bool_tIsLineProcessing() const; virtual Bool_tTDirectory::IsModified() const; Bool_tTObject::IsOnHeap() const; Bool_tIsProofServ() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectory::IsWritable() const; Bool_tTObject::IsZombie() const; TClass*LoadClass(const char* name, Bool_t silent = kFALSE) const; Int_tLoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Int_tLoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); virtual voidls(Option_t* option = """") const; Long_tMacro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Lo",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:10372,Availability,error,error,10372,"(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingMacro() const; virtual Bool_tIsFolder() const; Bool_tIsInterrupted() const; Bool_tIsLineProcessing() const; virtual Bool_tTDirectory::IsModified() const; Bool_tTObject::IsOnHeap() const; Bool_tIsProofServ() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTDirectory::IsWritable() const; Bool_tTObject::IsZombie() const; TClass*LoadClass(const char* name, Bool_t silent = kFALSE) const; Int_tLoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Int_tLoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); virtual voidls(Option_t* option = """") const; Long_tMacro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Long_tProcessLine(const char* line, Int_t* error = 0); Long_tProcessLineFast(const char* line, Int_t* error = 0); Long_tPro",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:11295,Availability,error,error,11295,"ls(Option_t* option = """") const; Long_tMacro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Long_tProcessLine(const char* line, Int_t* error = 0); Long_tProcessLineFast(const char* line, Int_t* error = 0); Long_tProcessLineSync(const char* line, Int_t* error = 0); virtual voidTDirectory::Purge(Short_t = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectory::ReadAll(Option_t* = """"); Bool_tReadingObject() const; virtual Int_tTDirectory::ReadKeys(Bool_t = kTRUE); virtual Int_tTDirectory::ReadTObject(TObject*, const char*); virtual voidTDirectory::RecursiveRemove(TObject* obj); voidRefreshBrowsers(); virtual TObject*TDirectory::Remove(TObject*); voidRemoveClass(TClass*); voidReset(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTDirectory::rmdir(const char* name); static Int_tRootVersionCode(); virtual voidTDirectory::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveContext(); virtual Int_tTDirectory::SaveObjectAs(const TObject*, const char* = """", Option_t* = """") const; virtual voidTObject::Sa",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:11354,Availability,error,error,11354,"lename, Int_t* error = 0, Bool_t padUpdate = kTRUE); TCanvas*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Long_tProcessLine(const char* line, Int_t* error = 0); Long_tProcessLineFast(const char* line, Int_t* error = 0); Long_tProcessLineSync(const char* line, Int_t* error = 0); virtual voidTDirectory::Purge(Short_t = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectory::ReadAll(Option_t* = """"); Bool_tReadingObject() const; virtual Int_tTDirectory::ReadKeys(Bool_t = kTRUE); virtual Int_tTDirectory::ReadTObject(TObject*, const char*); virtual voidTDirectory::RecursiveRemove(TObject* obj); voidRefreshBrowsers(); virtual TObject*TDirectory::Remove(TObject*); voidRemoveClass(TClass*); voidReset(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTDirectory::rmdir(const char* name); static Int_tRootVersionCode(); virtual voidTDirectory::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveContext(); virtual Int_tTDirectory::SaveObjectAs(const TObject*, const char* = """", Option_t* = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Op",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:11413,Availability,error,error,11413,"s*MakeDefCanvas() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Long_tProcessLine(const char* line, Int_t* error = 0); Long_tProcessLineFast(const char* line, Int_t* error = 0); Long_tProcessLineSync(const char* line, Int_t* error = 0); virtual voidTDirectory::Purge(Short_t = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectory::ReadAll(Option_t* = """"); Bool_tReadingObject() const; virtual Int_tTDirectory::ReadKeys(Bool_t = kTRUE); virtual Int_tTDirectory::ReadTObject(TObject*, const char*); virtual voidTDirectory::RecursiveRemove(TObject* obj); voidRefreshBrowsers(); virtual TObject*TDirectory::Remove(TObject*); voidRemoveClass(TClass*); voidReset(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTDirectory::rmdir(const char* name); static Int_tRootVersionCode(); virtual voidTDirectory::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveContext(); virtual Int_tTDirectory::SaveObjectAs(const TObject*, const char* = """", Option_t* = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectory::SaveSelf(Bool",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:27258,Availability,error,error,27258,"; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; comm",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:27576,Availability,error,error,27576,"st char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:27864,Availability,error,error,27864,"h will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous pr",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28078,Availability,error,error,28078,"f libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28127,Availability,error,error,28127,"libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28420,Availability,error,error,28420,"cts may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28684,Availability,error,error,28684,"filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29022,Availability,error,error,29022,"ilename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. vo",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29091,Availability,error,error,29091,"ool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt fi",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29307,Availability,error,error,29307,"mpiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed t",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29632,Availability,error,error,29632,"cessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpr",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29787,Availability,error,error,29787,"nchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, stru",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29986,Availability,error,error,29986,"().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the environment. IMPORTANT WARNING:; Do not use this call from within any function (neither compi",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:18210,Deployability,release,release,18210,mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:24756,Deployability,update,update,24756,"m CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (defa",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25160,Deployability,update,update,25160,"ithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initia",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25564,Deployability,update,update,25564,"with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28505,Deployability,update,update,28505,"ached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finis",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:30416,Deployability,update,update,30416,"n when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the environment. IMPORTANT WARNING:; Do not use this call from within any function (neither compiled nor; interpreted. This should only be used from a unnamed macro; (which starts with a { (curly braces) ). For example, using TROOT::Reset; from within an interpreted function will lead to the unloading of the; dictionary and source file, including the one defining the function being; executed. void SaveContext(); Save the current interpreter context. void SetCutClassName(const char* name = ""TCutG""); Set the default graphical cut class name for",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:36548,Deployability,release,release,36548,"st; { return fBrowsables; }. TFile * GetFile() const; { if (gDirectory != this) return gDirectory->GetFile(); else return 0;}. const TObject * GetSelectedPrimitive() const; { return fPrimitive; }. TVirtualPad * GetSelectedPad() const; { return fSelectPad; }. Int_t GetNclasses() const; { return fClasses->GetSize(); }. Int_t GetNtypes() const; { return fTypes->GetSize(); }. TFolder * GetRootFolder() const; { return fRootFolder; }. TProcessUUID * GetUUIDs() const; { return fUUIDs; }. Bool_t IsBatch() const; { return fBatch; }. Bool_t IsExecutingMacro() const; { return fExecutingMacro; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsInterrupted() const; { return fInterrupt; }. Bool_t IsEscaped() const; { return fEscape; }. Bool_t IsLineProcessing() const; { return fLineIsProcessing ? kTRUE : kFALSE; }. Bool_t IsProofServ() const; { return fName == ""proofserv"" ? kTRUE : kFALSE; }. Bool_t MustClean() const; { return fMustClean; }. Bool_t ReadingObject() const; { /* Deprecated (will be removed in next release) */ return fReadingObject; }. void SetApplication(TApplication* app); { fApplication = app; }. void SetBatch(Bool_t batch = kTRUE); { fBatch = batch; }. void SetDefCanvasName(const char* name = ""c1""); { fDefCanvasName = name; }. void SetEditHistograms(Bool_t flag = kTRUE); { fEditHistograms = flag; }. void SetExecutingMacro(Bool_t flag = kTRUE); { fExecutingMacro = flag; }. void SetFromPopUp(Bool_t flag = kTRUE); { fFromPopUp = flag; }. void SetInterrupt(Bool_t flag = kTRUE); { fInterrupt = flag; }. void SetEscape(Bool_t flag = kTRUE); { fEscape = flag; }. void SetLineIsProcessing(); { fLineIsProcessing++; }. void SetLineHasBeenProcessed(); { if (fLineIsProcessing) fLineIsProcessing--; }. void SetReadingObject(Bool_t flag = kTRUE); { fReadingObject = flag; }. void SetMustClean(Bool_t flag = kTRUE); { fMustClean=flag; }. void SetSelectedPrimitive(const TObject* obj); { fPrimitive = obj; }. void SetSelectedPad(TVirtualPad* pad); { fSelectPad = pad; }. void Time(I",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:17715,Integrability,message,message,17715,is TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSe,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:19356,Integrability,synchroniz,synchronize,19356,"ection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exi",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:26103,Integrability,interface,interface,26103,"ctions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28614,Integrability,message,message,28614,"= kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and P",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:16534,Modifiability,config,configure,16534,ory::UnregisterContext(TDirectory::TContext* ctxt). private:. TROOT&operator=(const TROOT&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:16597,Modifiability,config,configure,16597,,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:17460,Modifiability,variab,variables,17460,,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:17999,Modifiability,plugin,plugin,17999,ditor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ),MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23445,Modifiability,variab,variable,23445,"for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more e",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23649,Modifiability,variab,variable,23649," to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE)",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:29902,Modifiability,variab,variable,29902,". On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode. In; particular, error will equal to TInterpreter::kProcessing until the; CINT interpreted thread has finished executing the line.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineSync(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed synchronously (i.e. it will; only return when the CINT interpreter thread has finished executing; the line). On non-Win32 platforms there is no difference between; ProcessLine() and ProcessLineSync().; The possible error codes are defined by TInterpreter::EErrorCode.; Returns the result of the command, cast to a Long_t. Long_t ProcessLineFast(const char* line, Int_t* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the en",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:32032,Modifiability,extend,extend,32032,"ted. This should only be used from a unnamed macro; (which starts with a { (curly braces) ). For example, using TROOT::Reset; from within an interpreted function will lead to the unloading of the; dictionary and source file, including the one defining the function being; executed. void SaveContext(); Save the current interpreter context. void SetCutClassName(const char* name = ""TCutG""); Set the default graphical cut class name for the graphics editor; By default the graphics editor creates an instance of a class TCutG.; This function may be called to specify a different class that MUST; derive from TCutG. void SetEditorMode(const char* mode = """"); Set editor mode. void SetStyle(const char* stylename = ""Default""); Change current style to style with name stylename. Int_t DecreaseDirLevel(); Decrease the indentation level for ls(). Int_t GetDirLevel(); return directory level. const char * GetMacroPath(); Get macro search path. Static utility function. void SetMacroPath(const char* newpath); Set or extend the macro search path. Static utility function.; If newpath=0 or """" reset to value specified in the rootrc file. Int_t IncreaseDirLevel(); Increase the indentation level for ls(). void IndentLevel(); Functions used by ls() to indent an object hierarchy. Bool_t Initialized(); Return kTRUE if the TROOT object has been initialized. Bool_t MemCheck(); Return kTRUE if the memory leak checker is on. void SetDirLevel(Int_t level = 0); Return Indentation level for ls(). Int_t ConvertVersionCode2Int(Int_t code); Convert version code to an integer, i.e. 331527 -> 51507. Int_t ConvertVersionInt2Code(Int_t v); Convert version as an integer to version code as used in RVersion.h. Int_t RootVersionCode(); Return ROOT version code as defined in RVersion.h. TROOT& operator=(const TROOT& ). void * operator new(size_t l); { return TObject::operator new(l); }. void ForceStyle(Bool_t force = kTRUE); { fForceStyle = force; }. Bool_t FromPopUp() const; { return fFromPopUp; }. TPluginManager *",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:4565,Performance,load,load,4565,"t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:4901,Performance,load,load,4901,"TObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*Get",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:4996,Performance,load,load,4996,"ar*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGl",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:5802,Performance,load,load,5802,"; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollecti",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:5869,Performance,load,load,5869,"lass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:5968,Performance,load,load,5968,"pe_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessa",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:6073,Performance,load,load,6073,"t; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:6780,Performance,load,load,6780," char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, con",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:6832,Performance,load,load,6832,"tGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObj",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:7318,Performance,load,load,7318," TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(Bool_t load = kFALSE); virtual TList*TDirectory::GetListOfKeys() const; TSeqCollection*GetListOfMappedFiles() const; TSeqCollection*GetListOfMessageHandlers() const; TSeqCollection*GetListOfProofs() const; TSeqCollection*GetListOfSecContexts() const; TSeqCollection*GetListOfSockets() const; TSeqCollection*GetListOfSpecials() const; TSeqCollection*GetListOfStreamerInfo() const; TSeqCollection*GetListOfStyles() const; TSeqCollection*GetListOfTasks() const; TCollection*GetListOfTypes(Bool_t load = kFALSE); static const char*GetMacroPath(); virtual TObject*TDirectory::GetMother() const; virtual TDirectory*TDirectory::GetMotherDir() const; virtual const char*TNamed::GetName() const; virtual Int_tTDirectory::GetNbytesKeys() const; Int_tGetNclasses() const; virtual Int_tTDirectory::GetNkeys() const; Int_tGetNtypes() const; voidTDirectory::GetObject(const char* namecycle, void*& ptr); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() con",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:8721,Performance,load,load,8721,"void*TDirectory::GetObjectChecked(const char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() const; virtual Long64_tTDirectory::GetSeekKeys() const; virtual Long64_tTDirectory::GetSeekParent() const; TVirtualPad*GetSelectedPad() const; const TObject*GetSelectedPrimitive() const; TStyle*GetStyle(const char* name) const; const char*GetSvnBranch() const; const char*GetSvnDate(); Int_tGetSvnRevision() const; virtual const char*TNamed::GetTitle() const; TDataType*GetType(const char* name, Bool_t load = kFALSE) const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; TProcessUUID*GetUUIDs() const; const char*GetVersion() const; Int_tGetVersionCode() const; Int_tGetVersionDate() const; Int_tGetVersionInt() const; Int_tGetVersionTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingM",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:19368,Performance,multi-thread,multi-threads,19368,"ection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exi",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:19957,Performance,load,loaded,19957,"UIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.05/01; Int_tfVersionCodeROOT version code as used in RVersion.h; Int_tfVersionDateDate of ROOT version (ex 951226); Int_tfVersionIntROOT version in integer format (501); Int_tfVersionTimeTime of ROOT version (ex 1152); static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. private:. Int_tfLineIsProcessingTo synchronize multi-threads; static Int_tfgDirLevelIndentation level for ls(); static Bool_tfgMemCheckTurn on memory leak checker; static Bool_tfgRootInitSingleton initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TROOT(); Clean up and free resources used by ROOT (files, network sockets,; shared memory segments, etc.). void AddClass(TClass* cl); Add a class to the list and map of classes. void AddClassGenerator(TClassGenerator* gen); Add a class generator. This generator will be called by TClass::GetClass; in case its does not find a loaded rootcint dictionary to request the; creation of a TClass object. void Browse(TBrowser* b); Add browsable objects to TBrowser. Bool_t ClassSaved(TClass* cl); return class status bit kClassSaved for class cl; This function is called by the SavePrimitive functions writing; the C++ code for an object. TObject * FindObject(const TObject* obj) const; Find an object in one Root folder. TObject * FindObject(const char* name) const; Returns address of a ROOT object if it exists. If name contains at least one ""/"" the function calls FindObjectany; else; This function looks in the following order in the ROOT lists:; - List of files; - List of memory mapped files; - List of functions; - List of geometries; - List of canvases; - List of styles; - List of specials; - List of materials in current geometry; - List of shapes in current geometry; - List of matrices in current geometry; - List of Nodes in current geometry; - Current Directory in memory; - Current Directory on file. TObject * Fi",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:22264,Performance,load,load,22264,"rent geometry; - List of shapes in current geometry; - List of matrices in current geometry; - List of Nodes in current geometry; - Current Directory in memory; - Current Directory on file. TObject * FindObjectAny(const char* name) const; Return a pointer to the first object with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const ch",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:22556,Performance,load,load,22556," with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:22729,Performance,load,load,22729,"ClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals fro",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23059,Performance,load,load,23059," to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23398,Performance,load,load,23398,"for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more e",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23466,Performance,load,load,23466,"me). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const ch",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23602,Performance,load,load,23602," to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE)",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23680,Performance,load,load,23680,"Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execu",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23849,Performance,load,load,23849,"Class directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calli",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:23961,Performance,load,load,23961,"anvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:24209,Performance,load,load,24209,"tyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions eve",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:24320,Performance,load,load,24320,"Global(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TColle",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:24601,Performance,load,load,24601," const; Return pointer to global variable with address addr. If load is true; force reading of all currently defined globals from CINT (more; expensive). TFunction * GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); Return pointer to global function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:24932,Performance,load,load,24932,"bal function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t Ig",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25001,Performance,load,load,25001," global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; be",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25338,Performance,load,load,25338,"lso resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This func",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25397,Performance,load,load,25397,"he proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is '",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:25728,Performance,load,load,25728,"are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:26017,Performance,load,loaded,26017," * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be mad",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:26309,Performance,load,load,26309,"=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To li",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:26775,Performance,load,load,26775,"Sec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled b",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:27200,Performance,load,loading,27200,"; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; comm",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:28016,Performance,load,loading,28016,"f libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const TObject* obj); Process message id called by obj. Long_t ProcessLine(const char* line, Int_t* error = 0); Process interpreter command via TApplication::ProcessLine().; On Win32 the line will be processed asynchronously by sending; it to the CINT interpreter thread. For explicit synchronous processing; use ProcessLineSync(). On non-Win32 platforms there is no difference; between ProcessLine() and ProcessLineSync().; The possible error codes are",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:30771,Performance,load,loaded,30771,"* error = 0); Process interpreter command directly via CINT interpreter.; Only executable statements are allowed (no variable declarations),; In all other cases use TROOT::ProcessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadSvnInfo(); Read Subversion revision information and branch name from the; etc/svnrev.txt file. const char * GetSvnDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the environment. IMPORTANT WARNING:; Do not use this call from within any function (neither compiled nor; interpreted. This should only be used from a unnamed macro; (which starts with a { (curly braces) ). For example, using TROOT::Reset; from within an interpreted function will lead to the unloading of the; dictionary and source file, including the one defining the function being; executed. void SaveContext(); Save the current interpreter context. void SetCutClassName(const char* name = ""TCutG""); Set the default graphical cut class name for the graphics editor; By default the graphics editor creates an instance of a class TCutG.; This function may be called to specify a different class that MUST; derive from TCutG. void SetEditorMode(const char* mode = """"); Set editor mode. void SetStyle(const char* stylename = ""Default""); Change current style to style with name ",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:16544,Safety,detect,detected,16544,ory::UnregisterContext(TDirectory::TContext* ctxt). private:. TROOT&operator=(const TROOT&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:406,Security,access,accessible,406,". TROOT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TROOT. class TROOT: public TDirectory. R O O T top level object description. The TROOT object is the entry point to the ROOT system.; The single instance of TROOT is accessible via the global gROOT.; Using the gROOT pointer one has access to basically every object; created in a ROOT based program. The TROOT object is essentially a; container of several lists pointing to the main ROOT objects. The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers. The TROOT class provides also many useful services:; - Get pointer to an object in any of the lists above; - Time utilities TROOT::Time. The ROOT object must be created as a static object. An example; of a main program creating an interactive version is shown below:. Example of a main program. #include ""TRint.h"". int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);. // Init Intrinsics, build all windows, and enter event loop; theApp->Run();. return(0);; }; End of Main program. Function Members (Methods); public:. virtual~TROOT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectory::Add(TObject* obj, Bool_t replace = kFALSE); voidAddClass(TClass* cl); voidAddClassGenerator(TClassGenerator* gen); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); sta",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:472,Security,access,access,472,". TROOT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TROOT. class TROOT: public TDirectory. R O O T top level object description. The TROOT object is the entry point to the ROOT system.; The single instance of TROOT is accessible via the global gROOT.; Using the gROOT pointer one has access to basically every object; created in a ROOT based program. The TROOT object is essentially a; container of several lists pointing to the main ROOT objects. The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers. The TROOT class provides also many useful services:; - Get pointer to an object in any of the lists above; - Time utilities TROOT::Time. The ROOT object must be created as a static object. An example; of a main program creating an interactive version is shown below:. Example of a main program. #include ""TRint.h"". int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);. // Init Intrinsics, build all windows, and enter event loop; theApp->Run();. return(0);; }; End of Main program. Function Members (Methods); public:. virtual~TROOT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectory::Add(TObject* obj, Bool_t replace = kFALSE); voidAddClass(TClass* cl); voidAddClassGenerator(TClassGenerator* gen); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); sta",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:660,Security,access,accessible,660,". TROOT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TROOT. class TROOT: public TDirectory. R O O T top level object description. The TROOT object is the entry point to the ROOT system.; The single instance of TROOT is accessible via the global gROOT.; Using the gROOT pointer one has access to basically every object; created in a ROOT based program. The TROOT object is essentially a; container of several lists pointing to the main ROOT objects. The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers. The TROOT class provides also many useful services:; - Get pointer to an object in any of the lists above; - Time utilities TROOT::Time. The ROOT object must be created as a static object. An example; of a main program creating an interactive version is shown below:. Example of a main program. #include ""TRint.h"". int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);. // Init Intrinsics, build all windows, and enter event loop; theApp->Run();. return(0);; }; End of Main program. Function Members (Methods); public:. virtual~TROOT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectory::Add(TObject* obj, Bool_t replace = kFALSE); voidAddClass(TClass* cl); voidAddClassGenerator(TClassGenerator* gen); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); sta",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TROOT.html:18299,Security,secur,security,18299,mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
https://root.cern/root/html528/TRootAuth.html:329,Security,authenticat,authentication,329,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. TRootAuth(); TRootAuth(const TRootAuth&); virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootAuth(); { }. virtual ~TRootAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"). void ErrorMsg(const char* where, Int_t ecode = -1). const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootAuth.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootAuth.html
https://root.cern/root/html528/TRootBrowser.html:5152,Availability,error,error,5152,"ct::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGFrame*GetActFrame() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFra",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:5236,Availability,error,error,5236," Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGFrame*GetActFrame() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() ",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:21137,Availability,mask,mask,21137,,MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:22840,Modifiability,plugin,plugins,22840,"ND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCompositeFrame*fEditFrameFrame in ""Edit"" mode; Int_tfEditPosId of tab in ""Edit"" mode; Int_tfEditSubPosId of subtab in ""Edit"" mode; TGTab*fEditTabTab in ""Edit"" mode; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGHorizontalFrame*fH1Horizontal frame; TGHorizontalFrame*fH2Horizontal frame; TGHSplitter*fHSplitterHorizontal splitter; UInt_tTGFrame::fHeightframe height; TGHorizontalFrame*fHfHorizontal frame; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGLayoutHints*fLH0; TGLayoutHints*fLH1; TGLayoutHints*fLH2; TGLayoutHints*fLH3Layout hints, part 1; TGLayoutHints*fLH4; TGLayoutHints*fLH5; TGLayoutHints*fLH6; TGLayoutHints*fLH7Layout hints, part 2; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; TGMenuBar*fMenuBarMain (owned) menu bar; TGPopupMenu*fMenuExecPlugin""Exec Plugin"" popup menu; TGPopupMenu*fMenuFile""File"" popup menu; TGHorizontalFrame*fMenuFrameShared menu frame; TGPopupMenu*fMenuHelp""Browser Help"" popup menu; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Int_tfNbInitPluginsNumber of initial plugins (from .",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:23116,Modifiability,plugin,plugins,23116,,MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:26476,Modifiability,plugin,plugins,26476,"= """", Bool_t initshow = kTRUE); Create browser with a specified width and height. TRootBrowser(TBrowser* b, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """", Bool_t initshow = kTRUE); Create browser with a specified width and height and at position x, y. void CreateBrowser(const char* name). ~TRootBrowser(); Clean up all widgets, frames and layouthints that were used. void Add(TObject* obj, const char* name = 0, Int_t check = -1); Add items to the actual browser. This function has to be called; by the Browse() member function of objects when they are; called by a browser. If check < 0 (default) no check box is drawn,; if 0 then unchecked checkbox is added, if 1 checked checkbox is added. void BrowseObj(TObject* obj); Browse object. This, in turn, will trigger the calling of; TRootBrowser::Add() which will fill the IconBox and the tree.; Emits signal ""BrowseObj(TObject*)"". void CloneBrowser(); Clone the browser. A new Browser will be created, with the same; plugins executed in the current one. void CloseTab(Int_t id); Remove tab element id from right tab. void CloseWindow(); Called when window is closed via the window manager. void DoTab(Int_t id); Handle Tab navigation. Long_t ExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); Execute a macro and embed the created frame in the tab ""pos""; and tab element ""subpos"". Option_t * GetDrawOption() const; Returns drawing option. TGTab* GetTab(Int_t pos) const; Returns the TGTab at position pos. Bool_t HandleKey(Event_t* event); Handle keyboard events. void HandleMenu(Int_t id); Handle menu entries events. void InitPlugins(Option_t* opt = """"); Initialize default plugins. Could be also of the form:; StartEmbedding(0);; TPluginHandler *ph;; ph = gROOT->GetPluginManager()->FindHandler(""TGClassBrowser"");; if (ph && ph->LoadPlugin() != -1) {; ph->ExecPlugin(3, gClient->GetRoot(), 200, 500);; }; StopEmbedding();. void ReallyDelete();",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:27201,Modifiability,plugin,plugins,27201,"hecked checkbox is added. void BrowseObj(TObject* obj); Browse object. This, in turn, will trigger the calling of; TRootBrowser::Add() which will fill the IconBox and the tree.; Emits signal ""BrowseObj(TObject*)"". void CloneBrowser(); Clone the browser. A new Browser will be created, with the same; plugins executed in the current one. void CloseTab(Int_t id); Remove tab element id from right tab. void CloseWindow(); Called when window is closed via the window manager. void DoTab(Int_t id); Handle Tab navigation. Long_t ExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); Execute a macro and embed the created frame in the tab ""pos""; and tab element ""subpos"". Option_t * GetDrawOption() const; Returns drawing option. TGTab* GetTab(Int_t pos) const; Returns the TGTab at position pos. Bool_t HandleKey(Event_t* event); Handle keyboard events. void HandleMenu(Int_t id); Handle menu entries events. void InitPlugins(Option_t* opt = """"); Initialize default plugins. Could be also of the form:; StartEmbedding(0);; TPluginHandler *ph;; ph = gROOT->GetPluginManager()->FindHandler(""TGClassBrowser"");; if (ph && ph->LoadPlugin() != -1) {; ph->ExecPlugin(3, gClient->GetRoot(), 200, 500);; }; StopEmbedding();. void ReallyDelete(); Really delete the browser and the this GUI. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void RecursiveReparent(TGPopupMenu* popup); Recursively reparent TGPopupMenu to gClient->GetDefaultRoot(). void Refresh(Bool_t force = kFALSE); Refresh the actual browser contents. void RemoveTab(Int_t pos, Int_t subpos); Remove tab element ""subpos"" from tab ""pos"". void SetTab(Int_t pos = kRight, Int_t subpos = -1); Switch to Tab ""subpos"" in TGTab ""pos"". void SetTabTitle(const char* title, Int_t pos = kRight, Int_t subpos = -1); Set text ""title"" of Tab ""subpos"" in TGTab ""pos"". void SetStatusText(const char* txt, Int_t col); Set text in culumn col in status bar. void ShowMenu(TG",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:29106,Modifiability,plugin,plugin,29106,"pos = -1); Set text ""title"" of Tab ""subpos"" in TGTab ""pos"". void SetStatusText(const char* txt, Int_t col); Set text in culumn col in status bar. void ShowMenu(TGCompositeFrame* menu); Show the selected frame's menu and hide previous one. void StartEmbedding(Int_t pos = kRight, Int_t subpos = -1); Start embedding external frame in the tab ""pos"" and tab element ""subpos"". void StopEmbedding(const char* name, TGLayoutHints* layout); Stop embedding external frame in the current editable frame. void SwitchMenus(TGCompositeFrame* from); Move the menu from original frame to our TGMenuFrame, or display the; menu associated to the current tab. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void ExecuteDefaultAction(TObject* obj); Emits signal ""ExecuteDefaultAction(TObject*)"". TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); static contructor returning TBrowserImp,; as needed by the plugin mechanism. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); static contructor returning TBrowserImp,; as needed by the plugin mechanism. TRootBrowser(const TRootBrowser& ). TRootBrowser& operator=(const TRootBrowser& ). TGFrame * GetActFrame() const; { return (TGFrame *)fEditFrame; }. TGFrame * GetToolbarFrame() const; { return (TGFrame *)fToolbarFrame; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGTab * GetTabLeft() const; { return fTabLeft; }. TGTab * GetTabRight() const; { return fTabRight; }. TGTab * GetTabBottom() const; { return fTabBottom; }. void SetActBrowser(TBrowserImp* b); { fActBrowser = b; }. void StopEmbedding(const char* name = 0); { StopEmbedding(name, 0); }. void Show(); { MapRaised(); }. TGMainFrame * GetMainFrame() const; { return (TGMainFrame *)this; }. void ShowCloseTab(Bool",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowser.html:29308,Modifiability,plugin,plugin,29308," menu and hide previous one. void StartEmbedding(Int_t pos = kRight, Int_t subpos = -1); Start embedding external frame in the tab ""pos"" and tab element ""subpos"". void StopEmbedding(const char* name, TGLayoutHints* layout); Stop embedding external frame in the current editable frame. void SwitchMenus(TGCompositeFrame* from); Move the menu from original frame to our TGMenuFrame, or display the; menu associated to the current tab. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void ExecuteDefaultAction(TObject* obj); Emits signal ""ExecuteDefaultAction(TObject*)"". TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); static contructor returning TBrowserImp,; as needed by the plugin mechanism. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); static contructor returning TBrowserImp,; as needed by the plugin mechanism. TRootBrowser(const TRootBrowser& ). TRootBrowser& operator=(const TRootBrowser& ). TGFrame * GetActFrame() const; { return (TGFrame *)fEditFrame; }. TGFrame * GetToolbarFrame() const; { return (TGFrame *)fToolbarFrame; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGTab * GetTabLeft() const; { return fTabLeft; }. TGTab * GetTabRight() const; { return fTabRight; }. TGTab * GetTabBottom() const; { return fTabBottom; }. void SetActBrowser(TBrowserImp* b); { fActBrowser = b; }. void StopEmbedding(const char* name = 0); { StopEmbedding(name, 0); }. void Show(); { MapRaised(); }. TGMainFrame * GetMainFrame() const; { return (TGMainFrame *)this; }. void ShowCloseTab(Bool_t show); { fShowCloseTab = show; }. Bool_t IsCloseTabShown() const; { return fShowCloseTab; }. » Author: Bertrand Bellenot 26/09/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last change",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
https://root.cern/root/html528/TRootBrowserLite.html:5112,Availability,error,error,5112,"g_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecMacro(); virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:5196,Availability,error,error,5196,"it(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecMacro(); virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame:",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:20937,Availability,mask,mask,20937,,MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:28989,Deployability,update,update,28989," it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void SetDefaults(const char* iconStyle = 0, const char* sortBy = 0); Set defaults depending on settings in the user's .rootrc. void SetViewMode(Int_t new_mode, Bool_t force = kFALSE); Set iconbox's view mode and update menu and toolbar buttons accordingly. void SetSortMode(Int_t new_mode); Set iconbox's sort mode and update menu radio buttons accordingly. void Search(); starts serach dialog. void HideTextEdit(); hide text edit. void BrowseTextFile(const char* file); browse text file. void ExecMacro(); executed browsed text macro. void InterruptMacro(); interrupt browsed macro execution. void ShowMacroButtons(Bool_t show = kTRUE); show/hide macro buttons. void SetStatusText(const char* txt, Int_t col); Set text in column col in status bar. TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); Interface method to the old browser. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Interface method to the old browser. void Iconify(); { }. void ResizeBrowser(); { }. void Show(); { MapRaised(); }. TGListTree * GetListTree",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:29096,Deployability,update,update,29096,"id ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void SetDefaults(const char* iconStyle = 0, const char* sortBy = 0); Set defaults depending on settings in the user's .rootrc. void SetViewMode(Int_t new_mode, Bool_t force = kFALSE); Set iconbox's view mode and update menu and toolbar buttons accordingly. void SetSortMode(Int_t new_mode); Set iconbox's sort mode and update menu radio buttons accordingly. void Search(); starts serach dialog. void HideTextEdit(); hide text edit. void BrowseTextFile(const char* file); browse text file. void ExecMacro(); executed browsed text macro. void InterruptMacro(); interrupt browsed macro execution. void ShowMacroButtons(Bool_t show = kTRUE); show/hide macro buttons. void SetStatusText(const char* txt, Int_t col); Set text in column col in status bar. TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); Interface method to the old browser. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Interface method to the old browser. void Iconify(); { }. void ResizeBrowser(); { }. void Show(); { MapRaised(); }. TGListTree * GetListTree() const; { return fLt; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGMenuBar * GetMenuBar() cons",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:28859,Integrability,depend,depending,28859,"to the past. Bool_t HistoryForward(); go to the future. void DeleteListTreeItem(TGListTreeItem* item); delete list tree item, remove it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void SetDefaults(const char* iconStyle = 0, const char* sortBy = 0); Set defaults depending on settings in the user's .rootrc. void SetViewMode(Int_t new_mode, Bool_t force = kFALSE); Set iconbox's view mode and update menu and toolbar buttons accordingly. void SetSortMode(Int_t new_mode); Set iconbox's sort mode and update menu radio buttons accordingly. void Search(); starts serach dialog. void HideTextEdit(); hide text edit. void BrowseTextFile(const char* file); browse text file. void ExecMacro(); executed browsed text macro. void InterruptMacro(); interrupt browsed macro execution. void ShowMacroButtons(Bool_t show = kTRUE); show/hide macro buttons. void SetStatusText(const char* txt, Int_t col); Set text in column col in status bar. TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); Interface method to the old browser. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Interfac",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootBrowserLite.html:27781,Usability,clear,clear,27781," ""history"". TGFileContainer * GetIconBox() const; returns pointer to fIconBox object. void ReallyDelete(); Really delete the browser and the this GUI. void CloseWindow(); In case window is closed via WM we get here. void DisplayTotal(Int_t total, Int_t selected); Display in statusbar total number of objects and number of; selected objects in IconBox. void DisplayDirectory(); Display current directory in second label, fLbl2. void ExecuteDefaultAction(TObject* obj); Execute default action for selected object (action is specified; in the $HOME/.root.mimes or $ROOTSYS/etc/root.mimes file.; Emits signal ""ExecuteDefaultAction(TObject*)"". Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. void Chdir(TGListTreeItem* item); Make object associated with item the current directory. void HighlightListLevel(); helper method to track history. void AddToHistory(TGListTreeItem* item); helper method to track history. void ClearHistory(); clear navigation history. Bool_t HistoryBackward(); go to the past. Bool_t HistoryForward(); go to the future. void DeleteListTreeItem(TGListTreeItem* item); delete list tree item, remove it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void S",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
https://root.cern/root/html528/TRootCanvas.html:4671,Availability,error,error,4671,"voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitCanvas(); virtual voidForceUpdate(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; UInt_tGetCheight() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); UInt_tGetCwidth() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtua",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:4755,Availability,error,error,4755," signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitCanvas(); virtual voidForceUpdate(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; UInt_tGetCheight() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); UInt_tGetCwidth() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaul",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:20306,Availability,mask,mask,20306,,MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:25636,Integrability,interface,interface,25636,"bar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootCanvas(TCanvas* c = 0, const char* name = ""ROOT Canvas"", UInt_t width = 500, UInt_t height = 300); Create a basic ROOT canvas. TRootCanvas(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); Create a basic ROOT canvas. void CreateCanvas(const char* name); Create the actual canvas. ~TRootCanvas(); Delete ROOT basic canvas. Order is significant. Delete in reverse; order of creation. void Close(); Called via TCanvasImp interface by TCanvas. void ReallyDelete(); Really delete the canvas and this GUI. void CloseWindow(); In case window is closed via WM we get here. UInt_t GetCwidth() const; Return width of canvas container. UInt_t GetCheight() const; Return height of canvas container. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Gets the size and position of the window containing the canvas. This; size includes the menubar and borders. void SetStatusText(const char* txt = 0, Int_t partidx = 0); Set text in status bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Int_t InitWindow(); Called by TCanvas ctor to get window indetifier. void SetCanvasSize(UInt_t w, UInt_t h); Set size of canvas container. Units in pixels. void SetWindowPosition(Int_t x, Int_t y); Set canvas position (units in pixels). void SetWindowSize(UInt_t w, UInt_t h); Set size of canvas (units in pixels). void RaiseWindow(); Put canvas ",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:28012,Modifiability,config,configure,28012,"how = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenu",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:23634,Performance,load,loaded,23634,TGFrame::fgWhitePixel. private:. Bool_tfAutoFitwhen true canvas container keeps same size as canvas; Int_tfButtoncurrently pressed button; TRootContainer*fCanvasContainercontainer in canvas widget; Int_tfCanvasIDindex in fWindows array of TGX11; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TGCanvas*fCanvasWindowcanvas widget; TGLayoutHints*fDockLayoutlayout hints for dockable frame widget; TGPopupMenu*fEditClearMenuclear cascade submenu; TGPopupMenu*fEditMenuedit menu; TVirtualPadEditor*fEditorpointer to currently loaded pad editor; TGCompositeFrame*fEditorFrameside frame for current pad editor; TGLayoutHints*fEditorLayoutlayout for editor frame; TGPopupMenu*fFileMenufile menu; TGPopupMenu*fFileSaveMenusave cascade submenu; TGPopupMenu*fHelpMenuhelp menu; TGHorizontal3DLine*fHorizontal1toolbar sepatator; TGLayoutHints*fHorizontal1Layoutlayout hints for separator; const TGPicture*fIconPicicon picture; TGCompositeFrame*fMainFramemain frame containing canvas and side frame; TGLayoutHints*fMainFrameLayoutlayout for main frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TGPopupMenu*fOptionMenuoption menu; TGStatusBar*fStatusBarstatusbar widget; TGLayoutHints*fStatusBarLayoutlayout hints for statusbar; TGToolBar*fToolBaricon button toolbar; TGLayoutHints*fToolBarLayoutlayout for toolbar widget; TGHorizontal3DLine*fToolBarSeptoolbar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts,MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:28275,Security,expose,expose,28275,"bar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenuBarItemLayout; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGDockableFrame * GetToolDock() const; { return fToolDock; }. » Author: Fons Rademakers 15/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootCanvas.html:27732,Usability,undo,undocking,27732,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(cons",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
https://root.cern/root/html528/TRootContextMenu.html:521,Availability,down,downs,521,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:5800,Availability,error,error,5800,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGPopupMenu::EnableEntry(Int_t id); virtual Int_tTGPopupMenu::EndMenu(void*& userData); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual TContextMenu*TContextMenuImp::GetContextMenu() const; static Int_tTGWindow::GetCounter(); virtual TGMenuEntry*TGPopupMenu::GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWid",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:5884,Availability,error,error,5884,"bject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGPopupMenu::EnableEntry(Int_t id); virtual Int_tTGPopupMenu::EndMenu(void*& userData); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual TContextMenu*TContextMenuImp::GetContextMenu() const; static Int_tTGWindow::GetCounter(); virtual TGMenuEntry*TGPopupMenu::GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; TRootDialog*GetDialog() const; virtual TDNDData*TGFrame::GetDNDData(Atom",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:19333,Availability,mask,mask,19333,,MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:376,Integrability,interface,interface,376,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:23071,Integrability,depend,depending,23071,"el_tTGFrame::fgWhitePixel. private:. TRootDialog*fDialogdialog prompting for command line arguments; TList*fTrashlist of objects to be deleted before refilling menu. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); Create context menu. ~TRootContextMenu(); Delete a context menu. void DisplayPopup(Int_t x, Int_t y); Display context popup menu for currently selected object. TGPopupMenu * FindHierarchy(const char* commentstring, TString& last_component); Decodes the Hierarchy=""Level0/Level1/Level2/..."" statement from the comment field; and returns the - if needed - created sub menu ""Level0/Level1""; Returns the last component in last_component. void AddEntrySorted(TGPopupMenu* current, const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, Bool_t sorted = kTRUE); Add a entry to current menu with alphabetical ordering. void CreateMenu(TObject* object); Create the context menu depending on the selected object. void Dialog(TObject* object, TMethod* method); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""method"". void Dialog(TObject* object, TFunction* function); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""function"".; function may be a global function or a method. void DrawEntry(TGMenuEntry* entry); Draw context menu entry. Bool_t HandleButton(Event_t* event); Handle button event in the context menu. Bool_t HandleCrossing(Event_t* event); Handle pointer crossing event in context menu. Bool_t HandleMotion(Event_t* event); Handle pointer motion event in context menu. void OnlineHelp(); Open the online help matching the actual class/method. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle context menu messages. void RecursiveRemove(TObject* obj); Close the context menu if the object is deleted in the; RecursiveRemove() operation. TRootCon",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootContextMenu.html:23919,Integrability,message,messages,23919,"rchy(const char* commentstring, TString& last_component); Decodes the Hierarchy=""Level0/Level1/Level2/..."" statement from the comment field; and returns the - if needed - created sub menu ""Level0/Level1""; Returns the last component in last_component. void AddEntrySorted(TGPopupMenu* current, const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, Bool_t sorted = kTRUE); Add a entry to current menu with alphabetical ordering. void CreateMenu(TObject* object); Create the context menu depending on the selected object. void Dialog(TObject* object, TMethod* method); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""method"". void Dialog(TObject* object, TFunction* function); Create dialog object with OK and Cancel buttons. This dialog; prompts for the arguments of ""function"".; function may be a global function or a method. void DrawEntry(TGMenuEntry* entry); Draw context menu entry. Bool_t HandleButton(Event_t* event); Handle button event in the context menu. Bool_t HandleCrossing(Event_t* event); Handle pointer crossing event in context menu. Bool_t HandleMotion(Event_t* event); Handle pointer motion event in context menu. void OnlineHelp(); Open the online help matching the actual class/method. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle context menu messages. void RecursiveRemove(TObject* obj); Close the context menu if the object is deleted in the; RecursiveRemove() operation. TRootContextMenu(const TRootContextMenu& ). TRootContextMenu& operator=(const TRootContextMenu& ). TRootDialog * GetDialog() const; { return fDialog; }. » Author: Fons Rademakers 12/02/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRootContextMenu.h 32061 2010-01-20 07:51:15Z bellenot $ » Last generated: 2010-10-10 12:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
https://root.cern/root/html528/TRootControlBar.html:4547,Availability,error,error,4547,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; virtual TControlBarButton*TControlBarImp::GetClicked(); TGClient*TGObject::GetClient() const; virtual TControlBar*TControlBarImp::GetControlBar(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackgr",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootControlBar.html:4631,Availability,error,error,4631,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; virtual TControlBarButton*TControlBarImp::GetClicked(); TGClient*TGObject::GetClient() const; virtual TControlBar*TControlBarImp::GetControlBar(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFr",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootControlBar.html:19080,Availability,mask,mask,19080,,MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootControlBar.html:371,Integrability,interface,interface,371,". TRootControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootControlBar. class TRootControlBar: public TGMainFrame, public TControlBarImp. TRootControlBar. This class provides an interface to the GUI dependent functions of; the TControlBar class. A control bar is a horizontal or vertical bar; with a number of buttons (text or picture buttons). Function Members (Methods); public:. TRootControlBar(TControlBar* c = 0, const char* title = ""ROOT Control Bar"", Int_t x = -999, Int_t y = -999); virtual~TRootControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slo",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootControlBar.html:392,Integrability,depend,dependent,392,". TRootControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootControlBar. class TRootControlBar: public TGMainFrame, public TControlBarImp. TRootControlBar. This class provides an interface to the GUI dependent functions of; the TControlBar class. A control bar is a horizontal or vertical bar; with a number of buttons (text or picture buttons). Function Members (Methods); public:. TRootControlBar(TControlBar* c = 0, const char* title = ""ROOT Control Bar"", Int_t x = -999, Int_t y = -999); virtual~TRootControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slo",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootControlBar.html:22729,Integrability,message,messages,22729,"DefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. UInt_tfBwidthbutton width in pixels; TGLayoutHints*fL1button layout hints; TList*fWidgetslist of TGTextButton or TGPictureButtons. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootControlBar(TControlBar* c = 0, const char* title = ""ROOT Control Bar"", Int_t x = -999, Int_t y = -999); Create a ROOT native GUI controlbar. ~TRootControlBar(); Delete the control bar implementation. void Create(); Create the control bar. Loop over all buttons defined in the; TControlBar and create the buttons. void Show(); Show controlbar. If not yet created create it first. void Hide(); Hide controlbar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle controlbar button messages. void ReallyDelete(); Really delete the control bar and the this GUI. void CloseWindow(); Called when closed via window manager action. void SetFont(const char* fontName); sets new font for control bar buttons. void SetButtonState(const char* label, Int_t state = 0); sets new font for control bar buttons. void SetTextColor(const char* colorName); sets text color for control bar buttons, e.g.:; root > .x tutorials/demos.C; root > bar->SetTextColor(""red""). void SetButtonWidth(UInt_t width); Set button width in pixels. TList * GetWidgets() const; { return fWidgets; }. » Author: Fons Rademakers 22/02/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRootControlBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
https://root.cern/root/html528/TRootDialog.html:4751,Availability,error,error,4751,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TRootDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootDialog.html
https://root.cern/root/html528/TRootDialog.html:4835,Availability,error,error,4835,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TRootDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootDialog.html
https://root.cern/root/html528/TRootDialog.html:19019,Availability,mask,mask,19019,,MatchSource.WIKI,root/html528/TRootDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootDialog.html
https://root.cern/root/html528/TRootEmbeddedCanvas.html:4303,Availability,error,error,4303,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAutoFit() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TCanvas*GetCanvas() const; Int_tGetCanvasWindowId() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::Ge",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
https://root.cern/root/html528/TRootEmbeddedCanvas.html:4387,Availability,error,error,4387,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAutoFit() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TCanvas*GetCanvas() const; Int_tGetCanvasWindowId() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTG",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
https://root.cern/root/html528/TRootEmbeddedCanvas.html:16765,Availability,mask,mask,16765,,MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
https://root.cern/root/html528/TRootEmbeddedCanvas.html:19789,Modifiability,config,configure,19789," = 0, UInt_t w = 10, UInt_t h = 10, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create an TCanvas embedded in a TGFrame. A pointer to the TCanvas can; be obtained via the GetCanvas() member function. To embed a canvas; derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
https://root.cern/root/html528/TRootEmbeddedCanvas.html:20052,Security,expose,expose,20052,"derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId() const; { return fCWinId; }. Bool_t GetAutoFit() const; { return fAutoFit; }. void SetAutoFit(Bool_t fit = kTRUE); { fAutoFit = fit; }. » Author: Fons Rademakers 15/07/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: T",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
https://root.cern/root/html528/TRootGuiBuilder.html:7251,Availability,error,error,7251,"const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEraseStatusBar(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual TGFrame*ExecuteAction(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGMdiFrame*FindEditableMdiFrame(const TGWindow* win); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGuiBldAction*TGuiBuilder::GetAction() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static ULong_tGetBgnd(); static TGGC*GetBgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static",MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
https://root.cern/root/html528/TRootGuiBuilder.html:7335,Availability,error,error,7335,"aram); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEraseStatusBar(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual TGFrame*ExecuteAction(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGMdiFrame*FindEditableMdiFrame(const TGWindow* win); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGuiBldAction*TGuiBuilder::GetAction() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static ULong_tGetBgnd(); static TGGC*GetBgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); vi",MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
https://root.cern/root/html528/TRootGuiBuilder.html:22799,Availability,mask,mask,22799,,MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
https://root.cern/root/html528/TRootGuiBuilder.html:1123,Testability,test,tested,1123,"C header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUIBUILDER; » TRootGuiBuilder. class TRootGuiBuilder: public TGuiBuilder, public TGMainFrame. TRootGuiBuilder. ROOT GUI Builder principles. With the GUI builder, we try to make the next step from WYSIWYG; to embedded editing concept - WYSIWYE (""what you see is what you edit"").; The ROOT GUI Builder allows modifying real GUI objects.; For example, one can edit the existing GUI application created by; $ROOTSYS/tutorials/gui/guitest.C.; GUI components can be added to a design area from a widget palette,; or can be borrowed from another application.; One can drag and and drop TCanvas's menu bar into the application.; GUI objects can be resized and dragged, copied and pasted.; ROOT GUI Builder allows changing the layout, snap to grid, change object's; layout order via the GUI Builder toolbar, or by options in the right-click; context menus.; A final design can be immediatly tested and used, or saved as a C++ macro.; For example, it's possible to rearrange buttons in control bar,; add separators etc. and continue to use a new fancy control bar in the; application. The following is a short description of the GUI Builder actions and key shortcuts:. o Press Ctrl-Double-Click to start/stop edit mode; o Press Double-Click to activate quick edit action (defined in root.mimes). Selection, grabbing, dropping. It is possible to select, drag any frame and drop it to any frame. o Click left mouse button or Ctrl-Click to select an object to edit.; o Press right mouse button to activate context menu; o Mutiple selection (grabbing):; - draw lasso and press Return key; - press Shift key and draw lasso; o Dropping:; - select frame and press Ctrl-Return key; o Changing layout order:; - select frame and use arrow keys to change layout order; o Alignment:; - draw lasso and press arrow keys (or Shift-Arrow key) to align frames. Key shortcuts. o Return - grab selected frames; o C",MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
https://root.cern/root/html528/TRootGuiFactory.html:2475,Availability,error,error,2475,"nt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiFactory.html
https://root.cern/root/html528/TRootGuiFactory.html:2559,Availability,error,error,2559,"r* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html528/TRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiFactory.html
https://root.cern/root/html528/TRootHelpDialog.html:4593,Availability,error,error,4593,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TRootHelpDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootHelpDialog.html
https://root.cern/root/html528/TRootHelpDialog.html:4677,Availability,error,error,4677,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TRootHelpDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootHelpDialog.html
https://root.cern/root/html528/TRootHelpDialog.html:18896,Availability,mask,mask,18896,,MatchSource.WIKI,root/html528/TRootHelpDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootHelpDialog.html
https://root.cern/root/html528/TRootIOCtor.html:663,Availability,avail,available,663,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-10-29 07:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootIOCtor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootIOCtor.html
https://root.cern/root/html528/TRootSecContext.html:1869,Availability,error,error,1869,"ddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecC",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
https://root.cern/root/html528/TRootSecContext.html:1953,Availability,error,error,1953,"tion_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecContext::GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
https://root.cern/root/html528/TRootSecContext.html:7246,Security,secur,security,7246,"ate:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-11-02 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
https://root.cern/root/html528/TRootSecContext.html:7702,Security,secur,security,7702," key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-11-02 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
https://root.cern/root/html528/TRotation.html:4191,Availability,recover,recover,4191,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:6595,Availability,error,error,6595,"const TQuaternion&); virtual~TRotation(); voidTObject::AbstractMethod(const char* method) const; voidAngleAxis(Double_t&, TVector3&) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXPhi() const; Double_tGetXPsi() const; Double_tGetXTheta() const; Double_tGetYPhi() const; Double_tGetYPsi() const; Double_tGetYTheta() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObj",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:6679,Availability,error,error,6679,"thod) const; voidAngleAxis(Double_t&, TVector3&) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXPhi() const; Double_tGetXPsi() const; Double_tGetXTheta() const; Double_tGetYPhi() const; Double_tGetYPsi() const; Double_tGetYTheta() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:13980,Energy Efficiency,efficient,efficient,13980," of quaternion is null, creates identity rotation; if quaternion is non-unit, creates rotation corresponding to the normalized (unit) quaternion. TRotation & Rotate(Double_t , const TVector3& ); rotate along an axis. TRotation & RotateX(Double_t ); rotate around x. TRotation & RotateY(Double_t ); rotate around y. TRotation & RotateZ(Double_t ); rotate around z. TRotation & RotateAxes(const TVector3& newX, const TVector3& newY, const TVector3& newZ); rotate axes. Double_t PhiX() const; return Phi. Double_t PhiY() const; return Phi. Double_t PhiZ() const; return Phi. Double_t ThetaX() const; return Phi. Double_t ThetaY() const; return Theta. Double_t ThetaZ() const; return Theta. void AngleAxis(Double_t& , TVector3& ) const; rotation defined by an angle and a vector. TRotation & SetXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by; doing the explicit rotations. This is slightly less efficient than; directly applying the rotation, but makes the code much clearer. My; presumption is that this code is not going to be a speed bottle neck. TRotation & SetYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. TRotation & RotateXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention. TRotation & RotateYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:3588,Integrability,rout,routines,3588,"h::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis);. Rotation of local axes; Member function RotateAxes() adds a rotation of local axes to; the current rotation and returns the result:;   TVector3 newX(0,1,0);;   TVector3 newY(0,0,1);;   TVector3 newZ(1,0,0);;   a.RotateAxes(newX,newY,newZ);; Member functions ThetaX(), ThetaY(), ThetaZ(),; PhiX(), PhiY(),PhiZ() return azimuth and polar; angles of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotat",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:4584,Modifiability,variab,variable,4584,"routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   | xx xy xz | | x |;   | y' | = | yx yy yz | | y |;   | z' |   | zx zy zz | | z |; e.g.:;   TVector3 v(1,1,1);;   v = r * v;; You can also use the Transform() member function or the operator; *= of the; TVector3 class:;   TVector3 v;;   TRotation r;;   v.Transform(r);;   v *= r;  //Attention v = r * v. Function Members (Methods); public:. TRotation(); TRotation(const TRotation&); T",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:15420,Modifiability,variab,variable,15420,"les(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis(const TVector3& axis); set X axis. TRotation & SetYAxis(const TVector3& axis, const TVector3& yzPlane); set Y axis. TRotation & SetYAxis(const TVector3& axis); set Y axis. TRotation & SetZAxis(const TVector3& axis, const TVector3& zxPlane); set Z axis. TRotation & SetZAxis(const TVector3& axis); set Z axis. void MakeBasis(TVector3& xAxis, TVector3& yAxis, TVector3& zAxis) const; Make the Z axis into a unit variable. Double_t XX() const; { return fxx; }. Double_t XY() const; { return fxy; }. Double_t XZ() const; { return fxz; }. Double_t YX() const; { return fyx; }. Double_t YY() const; { return fyy; }. Double_t YZ() const; { return fyz; }. Double_t ZX() const; { return fzx; }. Double_t ZY() const; { return fzy; }. Double_t ZZ() const; { return fzz; }. Bool_t IsIdentity() const. TRotation & SetToIdentity(). TRotation & Transform(const TRotation& m). TRotation Inverse() const. TRotation & Invert(). TRotation & Rotate(Double_t psi, const TVector3* p). TRotationRow & operator=(const TRotation& m). virtual ~TRotation(); Copy constructor. {;}. » Author: Peter Malzacher 19/06/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/physics:$Id: TRotation.h 21795 2008-01-22 09:12:04Z brun $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentatio",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:4191,Safety,recover,recover,4191,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:1850,Testability,test,test,1850," xx  xy  xz |; | yx  yy  yz |; | zx  zy  zz |; It describes a so called active rotation, i.e. rotation of objects inside; a static system of coordinates. In case you want to rotate the frame and; want to know the coordinates of objects in the rotated system, you should; apply the inverse rotation to the objects. If you want to transform coordinates; from the rotated frame to the original frame you have to apply the direct; transformation.; A rotation around a specified axis means counterclockwise rotation around; the positive direction of the axis.;  . Declaration, Access, Comparisons;   TRotation r;    // r initialized as identity;   TRotation m(r); // m = r; There is no direct way to to set the matrix elements - to ensure that; a TRotation object always describes a real rotation. But you can get the; values by the member functions XX()..ZZ() or the (,); operator:;   Double_t xx = r.XX();     //  the; same as xx=r(0,0);            xx; = r(0,0);;   if (r==m) {...}          // test for equality;   if (r!=m) {..}           // test for inequality;   if (r.IsIdentity()) {...} // test for identity;  . Rotation around axes; The following matrices desrcibe counterclockwise rotations around coordinate; axes;         | 1   0      ; 0    |; Rx(a) = | 0 cos(a) -sin(a) |;         | 0 sin(a) cos(a) ; |;         | cos(a)  0 sin(a); |; Ry(a) = |   0     1   ; 0   |;         | -sin(a) 0 cos(a) |;         | cos(a) -sin(a) 0 |; Rz(a) = | sin(a) cos(a) 0 |;         |   0     ; 0     1 |; and are implemented as member functions RotateX(), RotateY(); and RotateZ():;   r.RotateX(TMath::Pi()); // rotation around the x-axis. Rotation around arbitary axis; The member function Rotate() allows to rotate around an arbitary vector; (not neccessary a unit one) and returns the result.;   r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis)",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:1899,Testability,test,test,1899,"It describes a so called active rotation, i.e. rotation of objects inside; a static system of coordinates. In case you want to rotate the frame and; want to know the coordinates of objects in the rotated system, you should; apply the inverse rotation to the objects. If you want to transform coordinates; from the rotated frame to the original frame you have to apply the direct; transformation.; A rotation around a specified axis means counterclockwise rotation around; the positive direction of the axis.;  . Declaration, Access, Comparisons;   TRotation r;    // r initialized as identity;   TRotation m(r); // m = r; There is no direct way to to set the matrix elements - to ensure that; a TRotation object always describes a real rotation. But you can get the; values by the member functions XX()..ZZ() or the (,); operator:;   Double_t xx = r.XX();     //  the; same as xx=r(0,0);            xx; = r(0,0);;   if (r==m) {...}          // test for equality;   if (r!=m) {..}           // test for inequality;   if (r.IsIdentity()) {...} // test for identity;  . Rotation around axes; The following matrices desrcibe counterclockwise rotations around coordinate; axes;         | 1   0      ; 0    |; Rx(a) = | 0 cos(a) -sin(a) |;         | 0 sin(a) cos(a) ; |;         | cos(a)  0 sin(a); |; Ry(a) = |   0     1   ; 0   |;         | -sin(a) 0 cos(a) |;         | cos(a) -sin(a) 0 |; Rz(a) = | sin(a) cos(a) 0 |;         |   0     ; 0     1 |; and are implemented as member functions RotateX(), RotateY(); and RotateZ():;   r.RotateX(TMath::Pi()); // rotation around the x-axis. Rotation around arbitary axis; The member function Rotate() allows to rotate around an arbitary vector; (not neccessary a unit one) and returns the result.;   r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis);. Rotation of local axes; Member function Rot",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:1951,Testability,test,test,1951,"on of objects inside; a static system of coordinates. In case you want to rotate the frame and; want to know the coordinates of objects in the rotated system, you should; apply the inverse rotation to the objects. If you want to transform coordinates; from the rotated frame to the original frame you have to apply the direct; transformation.; A rotation around a specified axis means counterclockwise rotation around; the positive direction of the axis.;  . Declaration, Access, Comparisons;   TRotation r;    // r initialized as identity;   TRotation m(r); // m = r; There is no direct way to to set the matrix elements - to ensure that; a TRotation object always describes a real rotation. But you can get the; values by the member functions XX()..ZZ() or the (,); operator:;   Double_t xx = r.XX();     //  the; same as xx=r(0,0);            xx; = r(0,0);;   if (r==m) {...}          // test for equality;   if (r!=m) {..}           // test for inequality;   if (r.IsIdentity()) {...} // test for identity;  . Rotation around axes; The following matrices desrcibe counterclockwise rotations around coordinate; axes;         | 1   0      ; 0    |; Rx(a) = | 0 cos(a) -sin(a) |;         | 0 sin(a) cos(a) ; |;         | cos(a)  0 sin(a); |; Ry(a) = |   0     1   ; 0   |;         | -sin(a) 0 cos(a) |;         | cos(a) -sin(a) 0 |; Rz(a) = | sin(a) cos(a) 0 |;         |   0     ; 0     1 |; and are implemented as member functions RotateX(), RotateY(); and RotateZ():;   r.RotateX(TMath::Pi()); // rotation around the x-axis. Rotation around arbitary axis; The member function Rotate() allows to rotate around an arbitary vector; (not neccessary a unit one) and returns the result.;   r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis);. Rotation of local axes; Member function RotateAxes() adds a rotation of local axes to; the curre",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotation.html:14052,Usability,clear,clearer,14052," of quaternion is null, creates identity rotation; if quaternion is non-unit, creates rotation corresponding to the normalized (unit) quaternion. TRotation & Rotate(Double_t , const TVector3& ); rotate along an axis. TRotation & RotateX(Double_t ); rotate around x. TRotation & RotateY(Double_t ); rotate around y. TRotation & RotateZ(Double_t ); rotate around z. TRotation & RotateAxes(const TVector3& newX, const TVector3& newY, const TVector3& newZ); rotate axes. Double_t PhiX() const; return Phi. Double_t PhiY() const; return Phi. Double_t PhiZ() const; return Phi. Double_t ThetaX() const; return Phi. Double_t ThetaY() const; return Theta. Double_t ThetaZ() const; return Theta. void AngleAxis(Double_t& , TVector3& ) const; rotation defined by an angle and a vector. TRotation & SetXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by; doing the explicit rotations. This is slightly less efficient than; directly applying the rotation, but makes the code much clearer. My; presumption is that this code is not going to be a speed bottle neck. TRotation & SetYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. TRotation & RotateXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention. TRotation & RotateYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
https://root.cern/root/html528/TRotMatrix.html:1708,Availability,error,error,1708,"theta3, Double_t phi3); virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_t*GetGLMatrix(Double_t* rGLMatrix) const; virtual const char*TObject::GetIconName() const; virtual Double_t*GetMatrix(); virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPhi() const; virtual Double_tGetPsi() const; virtual Double_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtua",MatchSource.WIKI,root/html528/TRotMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotMatrix.html
https://root.cern/root/html528/TRotMatrix.html:1792,Availability,error,error,1792,"* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_t*GetGLMatrix(Double_t* rGLMatrix) const; virtual const char*TObject::GetIconName() const; virtual Double_t*GetMatrix(); virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPhi() const; virtual Double_tGetPsi() const; virtual Double_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTO",MatchSource.WIKI,root/html528/TRotMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotMatrix.html
https://root.cern/root/html528/TRotMatrix.html:301,Safety,detect,detector,301,". TRotMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TRotMatrix. class TRotMatrix: public TNamed. Manages a detector rotation matrix. See class TGeometry. Function Members (Methods); public:. TRotMatrix(); TRotMatrix(const TRotMatrix&); TRotMatrix(const char* name, const char* title, Double_t* matrix); TRotMatrix(const char* name, const char* title, Double_t theta, Double_t phi, Double_t psi); TRotMatrix(const char* name, const char* title, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TRotMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotMatrix.html
https://root.cern/root/html528/TRWLock.html:1415,Availability,error,error,1415," TRWLock(); virtual~TRWLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
https://root.cern/root/html528/TRWLock.html:1499,Availability,error,error,1499," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
https://root.cern/root/html528/TRWLock.html:5241,Modifiability,variab,variable,5241,"ct::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteLock(); Int_tWriteUnLock(). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TRWLock(const TRWLock&); TRWLock&operator=(const TRWLock&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfLockFreerwlock condition variable; TMutexfMutexrwlock mutex; Int_tfReadersnumber of readers; Int_tfWritersnumber of writers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRWLock(); Create reader/write lock. Int_t ReadLock(); Obtain a reader lock. Returns always 0. Int_t ReadUnLock(); Unlock reader lock. Returns -1 if thread was not locked,; 0 if everything ok. Int_t WriteLock(); Obtain a writer lock. Returns always 0. Int_t WriteUnLock(); Unlock writer lock. Returns -1 if thread was not locked,; 0 if everything ok. TRWLock(const TRWLock& ). TRWLock& operator=(const TRWLock& ). virtual ~TRWLock(); { }. » Author: Fons Rademakers 04/01/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TRWLock.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
https://root.cern/root/html528/TRWLock.html:371,Security,access,accessed,371,". TRWLock. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TRWLock. class TRWLock: public TObject. TRWLock. This class implements a reader/writer lock. A rwlock allows; a resource to be accessed by multiple reader threads but only; one writer thread. Function Members (Methods); public:. TRWLock(); virtual~TRWLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
https://root.cern/root/html528/TSAXParser.html:3968,Availability,error,error,3968,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTXMLParser::GetParseCode() const; const char*TXMLParser::GetParseCodeMessage(Int_t parseCode) const; Bool_tTXMLParser::GetReplaceEntities() const; Bool_tTXMLParser::GetStopOn",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:4052,Availability,error,error,4052,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTXMLParser::GetParseCode() const; const char*TXMLParser::GetParseCodeMessage(Int_t parseCode) const; Bool_tTXMLParser::GetReplaceEntities() const; Bool_tTXMLParser::GetStopOnError() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:10464,Availability,error,errorcodes,10464,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:10643,Availability,error,error,10643,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:10754,Availability,error,error,10754,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:11987,Availability,error,error,11987,"; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndElement, where name is the Element's name. void OnCharacters(const char* characters); Emit a signal for OnCharacters, where characters are the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser.",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:12136,Availability,error,error,12136,"OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndElement, where name is the Element's name. void OnCharacters(const char* characters); Emit a signal for OnCharacters, where characters are the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This functi",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:12494,Availability,error,error,12494," void OnEndElement(const char* name); Emit a signal for OnEndElement, where name is the Element's name. void OnCharacters(const char* characters); Emit a signal for OnCharacters, where characters are the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » A",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:12719,Availability,error,error,12719," the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TSAXParser.h 29654 2009-07-31 14:34:14Z rdm $ » Last generated: 2010-09-23 20",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:12857,Availability,error,error,12857,"it a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TSAXParser.h 29654 2009-07-31 14:34:14Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:12955,Availability,error,error,12955,"it a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser. void ConnectToHandler(const char* handlerName, void* handler); A default TSAXParser to a user-defined Handler connection function.; This function makes connection between various function from TSAXParser; with the user-define SAX Handler, whose functions has to be exactly the; same as in TSAXParser. handlerName is the user-defined SAX Handler class name; handler is the pointer to the user-defined SAX Handler. See SAXHandler.C tutorial. TSAXParser(const TSAXParser& ). TSAXParser& operator=(const TSAXParser& ). » Author: Jose Lo 12/1/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/xmlparser:$Id: TSAXParser.h 29654 2009-07-31 14:34:14Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:524,Energy Efficiency,efficient,efficient,524,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:357,Integrability,wrap,wraper,357,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:433,Integrability,interface,interface,433,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:603,Integrability,rout,routines,603,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:9659,Integrability,message,message,9659,"pParser(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTXMLParser::InitializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSi",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:9726,Integrability,message,message,9726,"pParser(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTXMLParser::InitializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSi",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSAXParser.html:10687,Security,validat,validate,10687,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
https://root.cern/root/html528/TSecContext.html:1788,Availability,error,error,1788,"ddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetExpDate() const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; const char*GetID() const; Int_tGetMethod() const; const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffSet() const; virtual Option_t*TObject::GetOption() const; TList*GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*GetToken() const; virtual UInt_tT",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:1872,Availability,error,error,1872,"tion_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetExpDate() const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; const char*GetID() const; Int_tGetMethod() const; const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffSet() const; virtual Option_t*TObject::GetOption() const; TList*GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*GetToken() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; virtual Bool_tTObject::Hand",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:343,Security,secur,security,343,". TSecContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSecContext. class TSecContext: public TObject. TSecContext. Contains details about an established security context; Used by THostAuth. Function Members (Methods); public:. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); virtual~TSecContext(); voidTObject::AbstractMethod(const char* method) const; voidAddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, co",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:6461,Security,authenticat,authentication,6461,"t) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSecContext(const TSecContext&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TSecContext&operator=(const TSecContext&). private:. voidCleanup(); virtual Bool_tCleanupSecContext(Bool_t all). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fCleanupPoints to list with info for remote cleanup; void*fContextKrb5, Globus: ptr to specific sec context; TDatimefExpDateExpiring date (one sec precision); TStringfHostRemote host name; TStringfIDString identifying uniquely this context; Int_tfMethodAuthentication method used; TStringfMethodNameAuthentication method name; Int_tfOffSetoffset in remote host auth tab file (in bytes); TStringfTokenToken identifying this authentication; TStringfUserRemote login username. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActiva",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:7660,Security,secur,security,7660,"_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fO",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:8155,Security,secur,security,8155,"text(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyrig",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:8240,Security,secur,security,8240,"active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TSecContext.h 23091 2008-04-09 15:04:27Z rdm $ » Last ",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContext.html:6496,Testability,log,login,6496,"t) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSecContext(const TSecContext&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TSecContext&operator=(const TSecContext&). private:. voidCleanup(); virtual Bool_tCleanupSecContext(Bool_t all). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fCleanupPoints to list with info for remote cleanup; void*fContextKrb5, Globus: ptr to specific sec context; TDatimefExpDateExpiring date (one sec precision); TStringfHostRemote host name; TStringfIDString identifying uniquely this context; Int_tfMethodAuthentication method used; TStringfMethodNameAuthentication method name; Int_tfOffSetoffset in remote host auth tab file (in bytes); TStringfTokenToken identifying this authentication; TStringfUserRemote login username. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActiva",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
https://root.cern/root/html528/TSecContextCleanup.html:1484,Availability,error,error,1484,"ecContextCleanup(Int_t port, Int_t proto, Int_t type); virtual~TSecContextCleanup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; Int_tGetProtocol() const; virtual const char*TObject::GetTitle() const; Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TSecContextCleanup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContextCleanup.html
https://root.cern/root/html528/TSecContextCleanup.html:1568,Availability,error,error,1568," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; Int_tGetProtocol() const; virtual const char*TObject::GetTitle() const; Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bo",MatchSource.WIKI,root/html528/TSecContextCleanup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContextCleanup.html
https://root.cern/root/html528/TSecContextCleanup.html:364,Security,secur,security,364,". TSecContextCleanup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSecContextCleanup. class TSecContextCleanup: public TObject. TSecContext. Contains details about an established security context; Used by THostAuth. Function Members (Methods); public:. TSecContextCleanup(const TSecContextCleanup&); TSecContextCleanup(Int_t port, Int_t proto, Int_t type); virtual~TSecContextCleanup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*T",MatchSource.WIKI,root/html528/TSecContextCleanup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContextCleanup.html
https://root.cern/root/html528/TSelector.html:4059,Availability,error,error,4059,"const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; virtual TList*GetOutputList() const; static TSelector*GetSelector(const char* filename); virtual Long64_tGetStatus() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObjec",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:4143,Availability,error,error,4143,"d(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; virtual TList*GetOutputList() const; static TSelector*GetSelector(const char* filename); virtual Long64_tGetStatus() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTOb",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:8554,Availability,avail,available,8554," Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual intVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is lo",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:2539,Performance,perform,performs,2539,"o functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected events. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all events. When using PROOF Terminate() is call on; the client only. Typically one performs the fits on the produced; histograms or write the histograms to file in this method. WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call GetEntry(entry).; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. Function Members (Methods); public:. TSelector(); virtual~TSelector(); virtual voidAbort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) c",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9561,Performance,load,loaded,9561,"bject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kT",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9835,Performance,load,loaded,9835,"rited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. Bool_t ProcessCut(Long64_t ); { return kTRUE; }. void ProcessFill(Long64_",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:10024,Performance,load,loaded,10024,"tProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. Bool_t ProcessCut(Long64_t ); { return kTRUE; }. void ProcessFill(Long64_t ); { }. Bool_t Process(Long64_t ); { return kFALSE; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. void SetInputList(TList",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:10135,Performance,load,loaded,10135,"ile in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. Bool_t ProcessCut(Long64_t ); { return kTRUE; }. void ProcessFill(Long64_t ); { }. Bool_t Process(Long64_t ); { return kFALSE; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. void SetInputList(TList* input); { fInput = input; }. void SetStatus(Long64_t status); { fStatus = status; }. TList * GetOutputList() const; { return",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:1498,Safety,avoid,avoiding,1498,"attached.; void TSelector::Begin(). This method is called before looping on the; events in the Tree. The user can create his histograms in this; function. When using PROOF Begin() is called on the client only.; Histogram creation should preferable be done in SlaveBegin() in; that case.; void TSelector::SlaveBegin(). This method is called on each PROOF; worker node. The user can create his histograms in this method.; In local mode this method is called on the client too. Bool_t TSelector::Notify(). This method is called at the first entry; of a new file in a chain. Bool_t TSelector::Process(Long64_t entry). This method is called; to process an event. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; event is selected histograms can be filled. Processing stops; when this function returns kFALSE. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected events. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all events. When using PROOF Terminate() is call on; the clie",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9091,Safety,abort,aborted,9091,"rivate:. TSelector(const TSelector&); TSelector&operator=(const TSelector&). Data Members; public:. enum EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older tha",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9159,Safety,abort,aborted,9159,"nue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9269,Safety,abort,aborted,9269,"nue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TS",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9361,Safety,abort,abort,9361,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSele",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelector.html:9428,Safety,abort,abort,9428,"e; kWriteDelete; };. protected:. TSelector::EAbortfAbortabort status; TList*fInputlist of objects available during processing; TObject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() con",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
https://root.cern/root/html528/TSelectorCint.html:1570,Availability,error,error,1570,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual TClass*GetInterpretedClass() const; virtual TSelector*GetInterpretedSelector() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tGe",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
https://root.cern/root/html528/TSelectorCint.html:1654,Availability,error,error,1654,"tual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual TClass*GetInterpretedClass() const; virtual TSelector*GetInterpretedSelector() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tGetStatus() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
https://root.cern/root/html528/TSelectorCint.html:6765,Availability,avail,available,6765,"Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidSetFuncProto(CallFunc_t* cf, ClassInfo_t* cl, const char* fname, const char* argtype, Bool_t required = kTRUE). Data Members; public:. enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; ClassInfo_t*fClass!; CallFunc_t*fFuncBegin!; CallFunc_t*fFuncCut!; CallFunc_t*fFuncFill!; CallFunc_t*fFuncGetAbort!; CallFunc_t*fFuncGetStat!; CallFunc_t*fFuncInit!; CallFunc_t*fFuncInp!; CallFunc_t*fFuncNotif!; CallFunc_t*fFuncObj!; CallFunc_t*fFuncOption!; CallFunc_t*fFuncOut!; CallFunc_t*fFuncProc!; CallFunc_t*fFuncSlBegin!; CallFunc_t*fFuncSlTerm!; CallFunc_t*fFuncTerm!; CallFunc_t*fFuncVersion!; TList*TSelector::fInputlist of objects available during processing; TSelector*fIntSelectorPointer to interpreted selector (if interpreted); Bool_tfIsOwnerTrue if fIntSelector shoudl be deleted when the this object is deleted.; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorCint(); Default constructor for a Selector. ~TSelectorCint(); destructor for a Selector. void SetFuncProto(CallFunc_t* cf, ClassInfo_t* cl, const char* fname, const char* argtype, Bool_t required = kTRUE); Set the function prototype. void Build(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); ",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
https://root.cern/root/html528/TSelectorCint.html:7962,Availability,avail,available,7962,"e this object is deleted.; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorCint(); Default constructor for a Selector. ~TSelectorCint(); destructor for a Selector. void SetFuncProto(CallFunc_t* cf, ClassInfo_t* cl, const char* fname, const char* argtype, Bool_t required = kTRUE); Set the function prototype. void Build(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the T",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
https://root.cern/root/html528/TSelectorCint.html:8630,Availability,avail,available,8630,"etFuncProto(CallFunc_t* cf, ClassInfo_t* cl, const char* fname, const char* argtype, Bool_t required = kTRUE); Set the function prototype. void Build(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); Initialize the CallFunc objects when selector is interpreted. int Version() const; Invoke the Version function via the interpreter. void Init(TTree* ); Invoke the Init function via the interpreter. void Begin(TTree* tree); Invoke the Begin function via the interpreter. void SlaveBegin(TTree* ); Invoke the SlaveBegin function via the interpreter if available. Bool_t Notify(); Invoke the Notify function via the interpreter. Bool_t ProcessCut(Long64_t entry); Invoke the ProcessCut function via the interpreter. void ProcessFill(Long64_t entry); Invoke the ProcessFill function via the interpreter. Bool_t Process(Long64_t entry); Invoke the ProcessCut function via the interpreter. void SetOption(const char* option); Set the selector option. void SetObject(TObject* obj); Set the current object. void SetInputList(TList* input); Set the selector list of input objects. TList * GetOutputList() const; Return the list of output object. void SlaveTerminate(); Invoke the SlaveTerminate function via the interpreter if available. void Terminate(); Invoke the Terminate function via the interpreter. TSelector::EAbort GetAbort() const; Invoke the GetAbort function via the interpreter. Long64_t GetStatus() const; Invoke the GetStatus function via the interpreter. TClass * GetInterpretedClass() const; Retrieve the TClass object for the interpreted class. TSelector * GetInterpretedSelector() const; { return fIntSelector; }. » Author: Rene Brun 05/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TSelectorCint.h 34509 2010-07-20 12:18:17Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
https://root.cern/root/html528/TSelectorDraw.html:1474,Availability,error,error,1474," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual Long64_tGetDrawFlag() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TH1*GetOldHistogram()",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:1558,Availability,error,error,1558,"st char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual Long64_tGetDrawFlag() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TH1*GetOldHistogram() const; virtual const char*TSelector::GetOption() const; virtual TList*TSelector::Ge",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:7571,Availability,avail,available,7571,"char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidInitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TSelectorDraw(const TSelectorDraw&); TSelectorDraw&operator=(const TSelectorDraw&). Data Members; public:. enum { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfAction! Action type; Bool_tfCleanElisttrue if original Tree elist must be saved; Int_tfDimensionDimension of the current expression; Long64_tfDraw! Last entry loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer fo",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:10128,Availability,avail,available,10128,"ctor constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const T",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:10261,Energy Efficiency,allocate,allocated,10261,"(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const TSelectorDraw& ). TSelectorDraw& operator=(const TSelectorDraw& ). Int_t GetAction() const; {return fAction;}. Bool_t GetCleanElist() const; {return fCleanElist;}. Int_t GetDimension() const; {return",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:7695,Modifiability,variab,variability,7695,"char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidInitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TSelectorDraw(const TSelectorDraw&); TSelectorDraw&operator=(const TSelectorDraw&). Data Members; public:. enum { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfAction! Action type; Bool_tfCleanElisttrue if original Tree elist must be saved; Int_tfDimensionDimension of the current expression; Long64_tfDraw! Last entry loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer fo",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:8325,Modifiability,variab,variable,8325,"try loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formul",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:8579,Modifiability,variab,variables,8579,"try loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formul",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:8658,Modifiability,variab,variables,8658,"try loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formul",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:8732,Modifiability,variab,variable,8732,"try loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formul",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9347,Modifiability,variab,variables,9347," has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Not",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9876,Modifiability,variab,variable,9876,"tedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. voi",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9941,Modifiability,variab,variable,9941,"eight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill ti",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9999,Modifiability,variab,variable,9999," Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:10747,Modifiability,variab,variable,10747,"e:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const TSelectorDraw& ). TSelectorDraw& operator=(const TSelectorDraw& ). Int_t GetAction() const; {return fAction;}. Bool_t GetCleanElist() const; {return fCleanElist;}. Int_t GetDimension() const; {return fDimension;}. Long64_t GetDrawFlag() const; {return fDraw;}. TObject * GetObject() const; {return fObject;}. Int_t GetMultiplicity() const; {return fMultiplicity;}. Int_t GetNfill() const; {return fNfill;}. TH1 * GetOldHistogram() const; {return fOldHistogram;}. TTreeFormula * GetSelect() const; {return fSelect;}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TTree * GetTree() const; {return fTree;}. TTreeFormula * GetVar1() const; {return GetVar(0);}. TTreeForm",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:10855,Modifiability,variab,variable,10855,"s are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const TSelectorDraw& ). TSelectorDraw& operator=(const TSelectorDraw& ). Int_t GetAction() const; {return fAction;}. Bool_t GetCleanElist() const; {return fCleanElist;}. Int_t GetDimension() const; {return fDimension;}. Long64_t GetDrawFlag() const; {return fDraw;}. TObject * GetObject() const; {return fObject;}. Int_t GetMultiplicity() const; {return fMultiplicity;}. Int_t GetNfill() const; {return fNfill;}. TH1 * GetOldHistogram() const; {return fOldHistogram;}. TTreeFormula * GetSelect() const; {return fSelect;}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TTree * GetTree() const; {return fTree;}. TTreeFormula * GetVar1() const; {return GetVar(0);}. TTreeFormula * GetVar2() const; {return GetVar(1);}. TTreeFormula * GetVar3() cons",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9836,Security,authoriz,authorized,9836,"Dimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n)",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorDraw.html:9526,Usability,simpl,simplest,9526,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Call",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
https://root.cern/root/html528/TSelectorEntries.html:1906,Availability,error,error,1906," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; virtual Long64_tGetSelectedRows() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual cons",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
https://root.cern/root/html528/TSelectorEntries.html:1990,Availability,error,error,1990,"st char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; virtual Long64_tGetSelectedRows() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtua",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
https://root.cern/root/html528/TSelectorEntries.html:6848,Availability,avail,available,6848,"fmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TTree*fChain! pointer to the analyzed TTree or TChain; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries. protected:. TSelector::EAbortTSelector::fAbortabort status; TList*TSelector::fInputlist of objects available during processing; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorEntries(TTree* tree = 0, const char* selection = 0). TSelectorEntries(const char* selection). virtual ~TSelectorEntries(). Int_t Version() const; { return 2; }. void Begin(TTree* tree). void SlaveBegin(TTree* tree). void Init(TTree* tree). Bool_t Notify(). Bool_t Process(Long64_t entry). Int_t GetEntry(Long64_t entry, Int_t getall = 0). Long64_t GetSelectedRows() const; { return fSelectedRows; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. void SetSelection(const char* selection). TList * GetOutputList() const; { return fOutput; }. void SlaveTerminate().",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
https://root.cern/root/html528/TSelectorEntries.html:6684,Modifiability,variab,variable,6684,"l_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TTree*fChain! pointer to the analyzed TTree or TChain; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries. protected:. TSelector::EAbortTSelector::fAbortabort status; TList*TSelector::fInputlist of objects available during processing; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorEntries(TTree* tree = 0, const char* selection = 0). TSelectorEntries(const char* selection). virtual ~TSelectorEntries(). Int_t Version() const; { return 2; }. void Begin(TTree* tree). void SlaveBegin(TTree* tree). void Init(TTree* tree). Bool_t Notify(). Bool_t Process(Long64_t entry). Int_t GetEntry(Long64_t entry, Int_t getall = 0). Long64_t GetSelectedRows() const; { return fSelectedRows; }. void SetOption",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
https://root.cern/root/html528/TSelectorList.html:2606,Availability,error,error,2606,"voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t",MatchSource.WIKI,root/html528/TSelectorList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorList.html
https://root.cern/root/html528/TSelectorList.html:2690,Availability,error,error,2690,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual ",MatchSource.WIKI,root/html528/TSelectorList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorList.html
https://root.cern/root/html528/TSelectorList.html:9638,Performance,cache,cache,9638,":NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. Bool_tCheckDuplicateName(TObject* obj); Bool_tUnsetDirectory(TObject* obj). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t UnsetDirectory(TObject* obj); If the class of obj has the SetDirectory(TDirectory*) method; call it to unset the directory assiciation. The objects in the; selector list or owned by the list and not by the directory that; was active when they were created. Returns true in case of success. Bool_t CheckDuplicateName(TObject* obj); Check for duplicate object names in the list. If an object with; the same name is added then the merge function will fail that will; look up objects in different output lists by name. Returns true; in case name is unique. void AddFirst(TObject* obj); Add at the start of the list. void AddFirst(TObject* obj, Option_t* opt); Add at the",MatchSource.WIKI,root/html528/TSelectorList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorList.html
https://root.cern/root/html528/TSelectorScalar.html:1644,Availability,error,error,1644,"TSelectorScalar(const char* name = """", Long64_t val = 0); virtual~TSelectorScalar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TParameter<Long64_t>::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long long&TParameter<Long64_t>::GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidInc(Long_t n = 1); virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html528/TSelectorScalar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorScalar.html
https://root.cern/root/html528/TSelectorScalar.html:1728,Availability,error,error,1728," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TParameter<Long64_t>::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long long&TParameter<Long64_t>::GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidInc(Long_t n = 1); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classnam",MatchSource.WIKI,root/html528/TSelectorScalar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorScalar.html
https://root.cern/root/html528/TSemaphore.html:1393,Availability,error,error,1393," TSemaphore(UInt_t initial = 1); virtual~TSemaphore(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
https://root.cern/root/html528/TSemaphore.html:1477,Availability,error,error,1477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
https://root.cern/root/html528/TSemaphore.html:369,Integrability,synchroniz,synchronize,369,". TSemaphore. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TSemaphore. class TSemaphore: public TObject. TSemaphore. This class implements a counting semaphore. Use a semaphore; to synchronize threads. Function Members (Methods); public:. TSemaphore(UInt_t initial = 1); virtual~TSemaphore(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
https://root.cern/root/html528/TSemaphore.html:5220,Modifiability,variab,variable,5220,"har* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tTryWait(); virtual voidTObject::UseCurrentStyle(); Int_tWait(Int_t millisec = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TSemaphore.h 20882 2007-11-19 11:31:26Z rdm $ ",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
https://root.cern/root/html528/TSemaphore.html:5584,Safety,timeout,timeout,5584,"ual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TSemaphore.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
https://root.cern/root/html528/TSeqCollection.html:587,Availability,avail,available,587,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass(",MatchSource.WIKI,root/html528/TSeqCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSeqCollection.html
https://root.cern/root/html528/TSeqCollection.html:2324,Availability,error,error,2324,"ion::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TCollection::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; vi",MatchSource.WIKI,root/html528/TSeqCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSeqCollection.html
https://root.cern/root/html528/TSeqCollection.html:2408,Availability,error,error,2408," virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TCollection::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() con",MatchSource.WIKI,root/html528/TSeqCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSeqCollection.html
https://root.cern/root/html528/TServerSocket.html:2174,Availability,error,error,2174,"voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UChar_tGetAcceptOptions(); UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionLevel() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:2258,Availability,error,error,2258,"newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UChar_tGetAcceptOptions(); UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionLevel() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Boo",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:4648,Availability,error,error,4648,":GetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*TSocket::GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSocket::IsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTSocket::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidTSocket::NetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Optio",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:10890,Availability,error,error,10890," static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object for a named service. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:10929,Availability,error,error,10929,"*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object for a named service. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12013,Availability,error,error,12013,"all failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and n",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12052,Availability,error,error,12052," closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12914,Availability,error,error,12914,"t valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrv",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12998,Availability,avail,available,12998,"t valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrv",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13650,Availability,error,error,13650,"e call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13774,Availability,error,error,13774," also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:9902,Integrability,protocol,protocol,9902,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t b",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:419,Performance,perform,performs,419,". TServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TServerSocket. class TServerSocket: public TSocket. TServerSocket. This class implements server sockets. A server socket waits for; requests to come in over the network. It performs some operation; based on that request and then possibly returns a full duplex socket; to the requester. The actual work is done via the TSystem class; (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:10505,Performance,queue,queue,10505,"ize (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object for a named service. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:11514,Performance,queue,queue,11514,"ength; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12589,Performance,queue,queue,12589," mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:5845,Safety,timeout,timeout,5845,"ic voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetT",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:9677,Security,authenticat,authentication,9677,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t b",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:12374,Security,authenticat,authentication,12374,"et reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method T",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13058,Security,authenticat,authentication,13058," (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAc",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13119,Security,authenticat,authentication,13119," call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13164,Security,authenticat,authentication,13164," call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13226,Security,authenticat,authentication,13226,"t is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. T",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:13982,Security,authenticat,authentication,13982,"available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { M",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:14031,Security,authenticat,authentication,14031,"available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { M",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TServerSocket.html:14145,Security,authenticat,authentication,14145,"client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { MayNotUse(""Recv(Int_t &, Int_t &)""); return 0; }. Int_t Recv(char* , Int_t ); { MayNotUse(""Recv(char *, Int_t)""); return 0; }. Int_t Recv(char* , Int_t , Int_t&",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
https://root.cern/root/html528/TSessionDescription.html:1497,Availability,error,error,1497,"cription(); TSessionDescription(const TSessionDescription&); ~TSessionDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TSessionDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionDescription.html
https://root.cern/root/html528/TSessionDescription.html:1581,Availability,error,error,1581," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html528/TSessionDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionDescription.html
https://root.cern/root/html528/TSessionDescription.html:5567,Usability,feedback,feedback,5567,"t_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionDescription.html
https://root.cern/root/html528/TSessionFrame.html:4294,Availability,error,error,4294,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:4378,Availability,error,error,4378,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:17267,Availability,mask,mask,17267,,MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:19567,Availability,down,down,19567,"Click; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fApplyLogLevelapply log level button; TGTextButton*fApplyParallelapply parallel nodes button; TGTextButton*fBtnAddadd package button; TGTextButton*fBtnClearclear all packages button; TGTextButton*fBtnDisabledisable packages button; TGTextButton*fBtnDownmove package down button; TGTextButton*fBtnEnableenable packages button; TGTextButton*fBtnGetQueriesget entries button; TGTextButton*fBtnNewQuerynew query button; TGTextButton*fBtnRefreshrefresh list button; TGTextButton*fBtnRemoveremove package button; TGTextButton*fBtnRemoveDSetremove dataset button; TGTextButton*fBtnShowshow packages button; TGTextButton*fBtnShowEnabledshow enabled packages button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnUpmove package up button; TGTextButton*fBtnUploadupload packages button; TGTextButton*fBtnUploadDSetupload dataset button; TGTextButton*fBtnVerifyDSetverify dataset button; TGCheckButton*fChkEnableenable at session startup check; TGCheckButton*fChkMultimultiple selection check; TGCheckButton*fClearCheckclear text view after each command; TGTextBuffer*fCommandBufCommand line text buffer; TGTextEntry*fCommandTxtCommand line text entry; TGCanvas*fDSetViewdataset tree view; TGListTree*fDataSetTreedataset list tree; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFC; TGCompositeFrame*fFD; TGCompositeFrame*fFEfive tabs element; TGLabel*fInfoLine[19]infos on session; TGTextView*fInfoTextViewsummary on current query; TGListBox*fLBPackagespackages listbox; TGNumberEntry*fLogLevellog level number entry; TGTab*fTabmain tab frame; TGTextEntry*fTxtParallelparallel nodes text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSession",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:22512,Availability,down,down,22512,"rify that the files in the selected dataset are present on the cluster. void OnApplyLogLevel(); Apply selected log level on current session. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has b",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:13946,Testability,log,log,13946,"_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); voidSetLocal(Bool_t local = kTRUE); voidSetLogLevel(Int_t log); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); voidShutdownSession(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateC",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:19321,Testability,log,log,19321,"Click; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fApplyLogLevelapply log level button; TGTextButton*fApplyParallelapply parallel nodes button; TGTextButton*fBtnAddadd package button; TGTextButton*fBtnClearclear all packages button; TGTextButton*fBtnDisabledisable packages button; TGTextButton*fBtnDownmove package down button; TGTextButton*fBtnEnableenable packages button; TGTextButton*fBtnGetQueriesget entries button; TGTextButton*fBtnNewQuerynew query button; TGTextButton*fBtnRefreshrefresh list button; TGTextButton*fBtnRemoveremove package button; TGTextButton*fBtnRemoveDSetremove dataset button; TGTextButton*fBtnShowshow packages button; TGTextButton*fBtnShowEnabledshow enabled packages button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnUpmove package up button; TGTextButton*fBtnUploadupload packages button; TGTextButton*fBtnUploadDSetupload dataset button; TGTextButton*fBtnVerifyDSetverify dataset button; TGCheckButton*fChkEnableenable at session startup check; TGCheckButton*fChkMultimultiple selection check; TGCheckButton*fClearCheckclear text view after each command; TGTextBuffer*fCommandBufCommand line text buffer; TGTextEntry*fCommandTxtCommand line text entry; TGCanvas*fDSetViewdataset tree view; TGListTree*fDataSetTreedataset list tree; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFC; TGCompositeFrame*fFD; TGCompositeFrame*fFEfive tabs element; TGLabel*fInfoLine[19]infos on session; TGTextView*fInfoTextViewsummary on current query; TGListBox*fLBPackagespackages listbox; TGNumberEntry*fLogLevellog level number entry; TGTab*fTabmain tab frame; TGTextEntry*fTxtParallelparallel nodes text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSession",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:19988,Testability,log,log,19988,"Click; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fApplyLogLevelapply log level button; TGTextButton*fApplyParallelapply parallel nodes button; TGTextButton*fBtnAddadd package button; TGTextButton*fBtnClearclear all packages button; TGTextButton*fBtnDisabledisable packages button; TGTextButton*fBtnDownmove package down button; TGTextButton*fBtnEnableenable packages button; TGTextButton*fBtnGetQueriesget entries button; TGTextButton*fBtnNewQuerynew query button; TGTextButton*fBtnRefreshrefresh list button; TGTextButton*fBtnRemoveremove package button; TGTextButton*fBtnRemoveDSetremove dataset button; TGTextButton*fBtnShowshow packages button; TGTextButton*fBtnShowEnabledshow enabled packages button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnUpmove package up button; TGTextButton*fBtnUploadupload packages button; TGTextButton*fBtnUploadDSetupload dataset button; TGTextButton*fBtnVerifyDSetverify dataset button; TGCheckButton*fChkEnableenable at session startup check; TGCheckButton*fChkMultimultiple selection check; TGCheckButton*fClearCheckclear text view after each command; TGTextBuffer*fCommandBufCommand line text buffer; TGTextEntry*fCommandTxtCommand line text entry; TGCanvas*fDSetViewdataset tree view; TGListTree*fDataSetTreedataset list tree; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFC; TGCompositeFrame*fFD; TGCompositeFrame*fFEfive tabs element; TGLabel*fInfoLine[19]infos on session; TGTextView*fInfoTextViewsummary on current query; TGListBox*fLBPackagespackages listbox; TGNumberEntry*fLogLevellog level number entry; TGTab*fTabmain tab frame; TGTextEntry*fTxtParallelparallel nodes text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSession",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:21598,Testability,log,log,21598,"me*fFC; TGCompositeFrame*fFD; TGCompositeFrame*fFEfive tabs element; TGLabel*fInfoLine[19]infos on session; TGTextView*fInfoTextViewsummary on current query; TGListBox*fLBPackagespackages listbox; TGNumberEntry*fLogLevellog level number entry; TGTab*fTabmain tab frame; TGTextEntry*fTxtParallelparallel nodes text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionFrame(); Destructor. void Build(TSessionViewer* gui); Build session frame. void ProofInfos(); Display informations on current session. void OnBtnUploadDSet(); Open Upload Dataset dialog. void UpdateListOfDataSets(); Update list of dataset present on the cluster. void OnBtnRemoveDSet(); Remove dataset from the list and from the cluster. void OnBtnVerifyDSet(); Verify that the files in the selected dataset are present on the cluster. void OnApplyLogLevel(); Apply selected log level on current session. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof se",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:22641,Testability,log,log,22641,"sion. void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:23086,Testability,log,log,23086," void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionFrame.html:23118,Testability,log,log,23118," void OnApplyParallel(); Apply selected number of workers on current Proof session. void OnMultipleSelection(Bool_t on); Handle multiple selection check button. void OnStartupEnable(Bool_t on); Handle multiple selection check button. void UpdatePackages(); Update list of packages. void OnUploadPackages(); Upload selected package(s) to the current session. void OnEnablePackages(); Enable selected package(s) in the current session. void OnDisablePackages(); Disable selected package(s) in the current session. void OnClearPackages(); Clear (disable) all packages in the current session. void OnBtnAddClicked(); Open file dialog and add selected package file to the list. void OnBtnRemoveClicked(); Remove selected package from the list. void OnBtnUpClicked(); Move selected package entry one position up in the list. void OnBtnDownClicked(); Move selected package entry one position down in the list. void OnBtnDisconnectClicked(); Disconnect from current Proof session. void OnBtnShowLogClicked(); Show session log. void OnBtnNewQueryClicked(); Call ""New Query"" Dialog. void OnBtnGetQueriesClicked(); Get list of queries from current Proof server and populate the list tree. void OnCommandLine(); Command line handling. void SetLocal(Bool_t local = kTRUE); Switch widgets status/visibility for local/remote sessions. void ShutdownSession(); Shutdown current session. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void CheckAutoEnPack(Bool_t checked = kTRUE). TGTab * GetTab() const; { return fTab; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
https://root.cern/root/html528/TSessionInputFrame.html:4303,Availability,error,error,4303,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TSessionInputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionInputFrame.html
https://root.cern/root/html528/TSessionInputFrame.html:4387,Availability,error,error,4387,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TSessionInputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionInputFrame.html
https://root.cern/root/html528/TSessionInputFrame.html:16577,Availability,mask,mask,16577,,MatchSource.WIKI,root/html528/TSessionInputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionInputFrame.html
https://root.cern/root/html528/TSessionLogView.html:4507,Availability,error,error,4507,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TSessionLogView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionLogView.html
https://root.cern/root/html528/TSessionLogView.html:4591,Availability,error,error,4591,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html528/TSessionLogView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionLogView.html
https://root.cern/root/html528/TSessionLogView.html:18808,Availability,mask,mask,18808,,MatchSource.WIKI,root/html528/TSessionLogView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionLogView.html
https://root.cern/root/html528/TSessionLogView.html:371,Testability,log,logs,371,". TSessionLogView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TSessionLogView. class TSessionLogView: public TGTransientFrame. TSessionLogView. Dialog used to display session logs from the session viewer. Function Members (Methods); public:. TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h); virtual~TSessionLogView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddBuffer(const char* buffer); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearLogView(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tT",MatchSource.WIKI,root/html528/TSessionLogView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionLogView.html
https://root.cern/root/html528/TSessionLogView.html:22276,Testability,log,log,22276,"TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCloseOK button; TGLayoutHints*fL1layout of TGTextEdit; TGLayoutHints*fL2layout of OK button; TGTextView*fTextViewText view widget; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionLogView(TSessionViewer* viewer, UInt_t w, UInt_t h); Create an editor in a dialog. ~TSessionLogView(). void SetTitle(); Set title in editor window. void Popup(); Show editor. void AddBuffer(const char* buffer); Load a text buffer in the editor. void ClearLogView(); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the editor. void LoadFile(const char* file); Load a file in the editor. void CloseWindow(); Called when closed via window manager action. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process OK button. » Author: Bertrand Bellenot, Gerri Ganis 15/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionLogView.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionLogView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionLogView.html
https://root.cern/root/html528/TSessionOutputFrame.html:4308,Availability,error,error,4308,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TSessionOutputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html
https://root.cern/root/html528/TSessionOutputFrame.html:4392,Availability,error,error,4392,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html528/TSessionOutputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html
https://root.cern/root/html528/TSessionOutputFrame.html:16723,Availability,mask,mask,16723,,MatchSource.WIKI,root/html528/TSessionOutputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html
https://root.cern/root/html528/TSessionOutputFrame.html:18783,Usability,feedback,feedback,18783,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This pa",MatchSource.WIKI,root/html528/TSessionOutputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:4274,Availability,error,error,4274,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFram",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:4358,Availability,error,error,4358,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual In",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:17330,Availability,mask,mask,17330,,MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21035,Deployability,update,update,21035,"View*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the curr",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:8909,Safety,abort,aborted,8909,"er(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGCompositeFrame::HandleKey(Event_t*); virtual Bool_tTGCompositeFrame::HandleMotion(Event_t*); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); voidIndicateStop(Bool_t aborted); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21550,Safety,abort,aborted,21550,"TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has b",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:19560,Testability,log,log,19560,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21846,Testability,log,log,21846,"; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:20249,Usability,progress bar,progress bar,20249,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:20290,Usability,progress bar,progress bar,20290,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:20600,Usability,progress bar,progress bar,20600,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21042,Usability,feedback,feedback,21042,"View*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the curr",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21102,Usability,feedback,feedback,21102,"el*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update que",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21181,Usability,progress bar,progress bar,21181,"us; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionQueryFrame.html:21493,Usability,progress bar,progress bar,21493,"ame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.",MatchSource.WIKI,root/html528/TSessionQueryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:4279,Availability,error,error,4279,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAddress() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*GetConfigText() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize(",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:4363,Availability,error,error,4363,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAddress() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*GetConfigText() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:17141,Availability,mask,mask,17141,,MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:19917,Deployability,configurat,configuration,19917,"tatic Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:19985,Deployability,update,update,19985,"ic Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText()",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20118,Deployability,configurat,configuration,20118,"eGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; {",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20190,Deployability,configurat,configuration,20190,"dd"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20330,Deployability,configurat,configuration,20330,"g) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddr",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20402,Deployability,configurat,configuration,20402,"fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20609,Integrability,message,messages,20609,"*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_t port); { fNumPort->SetIntNumber(port); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void SetConfigText(const char* str); { fTxtConfig->SetText(str); }. void SetUserName(c",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:19917,Modifiability,config,configuration,19917,"tatic Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20118,Modifiability,config,configuration,20118,"eGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; {",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20190,Modifiability,config,configuration,20190,"dd"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20330,Modifiability,config,configuration,20330,"g) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddr",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20402,Modifiability,config,configuration,20402,"fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:20053,Security,expose,expose,20053,"tic UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAdd""Add"" button; TGTextButton*fBtnConnect""Connect"" button; TGCompositeFrame*fFrmNewServermain group frame; TGNumberEntry*fLogLevellog (debug) level selector; TGNumberEntry*fNumPortport number selector; TGCheckButton*fSyncsync / async flag selector; TGTextEntry*fTxtAddressserver address text entry; TGTextEntry*fTxtConfigconfiguration file text entry; TGTextEntry*fTxtNameconnection name text entry; TGTextEntry*fTxtUsrNameuser name text entry; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionServerFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionServerFrame(); Destructor. void Build(TSessionViewer* gui); Build server configuration frame. void SettingsChanged(); Settings have changed, update GUI accordingly. Bool_t HandleExpose(Event_t* event); Handle expose event in server frame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() co",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:13751,Testability,log,log,13751,"undColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidSetConfigText(const char* str); voidSetConnectEnabled(Bool_t on = kTRUE); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); voidSetLogLevel(Int_t log); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidSetName(const char* str); static voidTObject::SetObjectStat(Bool_t stat); voidSetPortNumber(Int_t port); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetSync(Bool_t sync); voidSettingsChanged(); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserName(const char* str); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; In",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:21463,Testability,log,log,21463,"ame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_t port); { fNumPort->SetIntNumber(port); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void SetConfigText(const char* str); { fTxtConfig->SetText(str); }. void SetUserName(const char* str); { fTxtUsrName->SetText(str); }. void SetSync(Bool_t sync). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionServerFrame.html:21495,Testability,log,log,21495,"ame. void OnConfigFileClicked(); Browse configuration files. void OnBtnDeleteClicked(); Delete selected session configuration (remove it from the list). void OnBtnConnectClicked(); Connect to selected server. void OnBtnNewServerClicked(); Reset server configuration fields. void OnBtnAddClicked(); Add newly created session configuration in the list of sessions. void Update(TSessionDescription* desc); Update fields with values from session description desc. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for session server frame.; Used to navigate between text entry fields. const char * GetName() const; { return fQueryName; }. const char * GetAddress() const; { return fTxtAddress->GetText(); }. Int_t GetPortNumber() const; { return fNumPort->GetIntNumber(); }. Int_t GetLogLevel() const; { return fLogLevel->GetIntNumber(); }. const char * GetConfigText() const; { return fTxtConfig->GetText(); }. const char * GetUserName() const; { return fTxtUsrName->GetText(); }. Bool_t IsSync() const; { return (Bool_t)(fSync->GetState() == kButtonDown); }. void SetAddEnabled(Bool_t on = kTRUE). void SetConnectEnabled(Bool_t on = kTRUE). void SetName(const char* str); { fTxtName->SetText(str); }. void SetAddress(const char* str); { fTxtAddress->SetText(str); }. void SetPortNumber(Int_t port); { fNumPort->SetIntNumber(port); }. void SetLogLevel(Int_t log); { fLogLevel->SetIntNumber(log); }. void SetConfigText(const char* str); { fTxtConfig->SetText(str); }. void SetUserName(const char* str); { fTxtUsrName->SetText(str); }. void SetSync(Bool_t sync). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionServerFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionServerFrame.html
https://root.cern/root/html528/TSessionViewer.html:4639,Availability,error,error,4639,"ject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableTimer(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TSessionDescription*GetActDesc() const; virtual Pixel_tTGFrame::GetBackground() const; const TGPicture*GetBasePict() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGPopupMenu*GetCascadeMenu() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; TGHProgressBar*GetConnectProg() const; TContextMenu*GetContextMenu() const; ",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:4723,Availability,error,error,4723,"l, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableTimer(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TSessionDescription*GetActDesc() const; virtual Pixel_tTGFrame::GetBackground() const; const TGPicture*GetBasePict() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGPopupMenu*GetCascadeMenu() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; TGHProgressBar*GetConnectProg() const; TContextMenu*GetContextMenu() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:20346,Availability,mask,mask,20346,,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25264,Deployability,configurat,configuration,25264,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25655,Deployability,configurat,configuration,25655," server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTim",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25996,Deployability,configurat,configuration,25996,"rbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof sessio",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26407,Deployability,configurat,configuration,26407," Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowE",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:28012,Deployability,configurat,configuration,28012,"tSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * G",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:27837,Integrability,message,message,27837,"g in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { ",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:28097,Integrability,message,messages,28097,"user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() con",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:28164,Integrability,message,messages,28164,"rrently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { re",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:23302,Modifiability,config,config,23302,Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TSessionDescription*fActDescactual session description; TGFrame*fActFrameactual (displayed) frame; Bool_tfAutoSavekTRUE if config is to be saved on exit; const TGPicture*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; con,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25264,Modifiability,config,configuration,25264,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25655,Modifiability,config,configuration,25655," server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTim",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25996,Modifiability,config,configuration,25996,"rbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof sessio",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26013,Modifiability,config,config,26013,"rbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof sessio",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26407,Modifiability,config,configuration,26407," Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowE",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:28012,Modifiability,config,configuration,28012,"tSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * G",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:16060,Testability,log,log,16060,"lassHints(const char* className, const char* resourceName); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); voidTGMainFrame::SetIconName(const char* name); const TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); voidSetLogWindow(TSessionLogView* log); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); voidShowEnabledPackages(); virtual voidTGCompositeFrame::S",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:23933,Testability,log,log,23933,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26585,Testability,log,logo,26585,"in Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the con",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26816,Testability,log,log,26816,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, In",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:26831,Testability,log,log,26831,"oid UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, In",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:27591,Testability,log,log,27591,"e right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame. void QueryResultReady(char* query); Handle signal ""query result ready"" coming from Proof session. void CleanupSession(); Clean-up Proof session. void ResetSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fA",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:29854,Testability,log,log,29854," fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:29875,Testability,log,log,29875," fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * GetQueryConPict() const; { return fQueryCon; }. const TGPicture * GetQueryDisconPict() const; { return fQueryDiscon; }. const TGPicture * GetBasePict() const; { return fBaseIcon; }. TGPopupMenu * GetPopupSrv() const; { return fPopupSrv; }. TGPopupMenu * GetPopupQry() const; { return fPopupQry; }. TContextMenu * GetContextMenu() const; { return fContextMenu; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGHProgressBar * GetConnectProg() const; { return fConnectProg; }. TGPopupMenu * GetCascadeMenu() const; { return fCascadeMenu; }. TGPopupMenu * GetOptionsMenu() const; { return fOptionsMenu; }. Bool_t IsBusy() const; { return fBusy; }. Bool_t IsAutoSave() const; { return fAutoSave; }. void SetBusy(Bool_t busy = kTRUE); { fBusy = busy; }. void SetChangePic(Bool_t change); { fChangePic = change;}. void SetLogWindow(TSessionLogView* log); { fLogWindow = log; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:23598,Usability,progress bar,progress bar,23598,re*fBaseIconbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. ,MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:25780,Usability,feedback,feedback,25780,"n sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStart; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessa",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TSessionViewer.html:27992,Usability,feedback,feedback,27992,"tSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * G",MatchSource.WIKI,root/html528/TSessionViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionViewer.html
https://root.cern/root/html528/TShape.html:1845,Availability,error,error,1845,"hod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html528/TShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TShape.html
https://root.cern/root/html528/TShape.html:1929,Availability,error,error,1929,"; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption()",MatchSource.WIKI,root/html528/TShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TShape.html
https://root.cern/root/html528/TShape.html:8547,Energy Efficiency,allocate,allocate,8547,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TShape.html
https://root.cern/root/html528/TShape.html:8707,Safety,avoid,avoid,8707,"le_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNumberShape number; TStringTNamed::fTitleobject title; Int_tfVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TShape(); Shape default constructor. TShape(const char* name, const char* title, const char* material); Shape normal constructor. TShape(const TShape& ); copy constructor. TShape& operator=(const TShape& ); assignement operator. ~TShape(); Shape default destructor. Int_t ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py); Distance to primitive. void Paint(Option_t* option = """"); This method is used only when a shape is painted outside a TNode. void SetPoints(Double_t* points) const; Set points. void Streamer(TBuffer& b); Stream an object of class TShape. void TransformPoints(Double_t* points, UInt_t NbPnts) const; Tranform points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections) const; We have to set kRawSize (unless already done) to allocate buffer space; before kRaw can be filled. Int_t GetBasicColor() const; Get basic solor. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Stub to avoid forcing implementation at this stage. void SetName(const char* name); { }. TMaterial * GetMaterial() const; {return fMaterial;}. Int_t GetNumber() const; {return fNumber;}. Int_t GetVisibility() const; {return fVisibility;}. void SetVisibility(Int_t vis); {fVisibility = vis;}. » Author: Nenad Buncic 17/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TShape.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TShape.html
https://root.cern/root/html528/TSignalHandler.html:3789,Availability,error,error,3789,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; ESignalsGetSignal() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidHandleDelayedSignal(); virtual Bool_tTObject::HandleTimer(",MatchSource.WIKI,root/html528/TSignalHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSignalHandler.html
https://root.cern/root/html528/TSignalHandler.html:3873,Availability,error,error,3873,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; ESignalsGetSignal() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidHandleDelayedSignal(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const",MatchSource.WIKI,root/html528/TSignalHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSignalHandler.html
https://root.cern/root/html528/TSlave.html:1502,Availability,error,error,1502," virtual~TSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchCompiler() const; Long64_tGetBytesRead() const; Float_tGetCpuTime() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:1586,Availability,error,error,1586,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchCompiler() const; Long64_tGetBytesRead() const; Float_tGetCpuTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetGroup() const; virtual const char*TObject::GetIconName() const; const char*GetImage() const; TFileHandler*GetInputHandler() const; const char*GetMsd() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOrdinal() const; Int_tGetParallel() const; Int_tGetPerfIdx() const; Int_tGetPort() const; TProof*GetProof() const; const char*GetProofWorkDir() const; Int_tGetProtocol() const; ",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:9855,Availability,error,error,9855,"itten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { r",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:9974,Availability,error,error,9974,"a s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProo",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10420,Availability,recover,recovered,10420,"eted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. Int_t GetPort() const; { return fPort; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetPerfIdx() const; { return fPerfIdx; }. Int_t GetProtocol() const; { return fProtocol; }. TSocket * GetSocket() const; { return fSocket; }. TProof ",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:7736,Integrability,protocol,protocol,7736,"ring wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tfBytesReadbytes read by slave (info is obtained from slave); Float_tfCpuTimeCPU time spent executing commands (info obtained from slave); TStringfGroupslave's group id; TStringfImageslave's image name; TFileHandler*fInputinput handler related to this slave; TStringfMsdmass storage domain of slave; TStringfNameslave's hostname; TStringfOrdinalslave's ordinal number; Int_tfParallelnumber of active slaves; Int_tfPerfIdxrelative CPU performance index; Int_tfPortslave's port number; TProof*fProofproof cluster to which slave belongs; TStringfProofWorkDirbase proofserv working directory (info obtained from slave); Int_tfProtocolslave's protocol level; TStringfROOTVersROOT version run by worker; Float_tfRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypefSlaveTypetype of slave (either kMaster or kSlave); TSocket*fSocketsocket to slave; Int_tfStatusremote return status; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSla",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10153,Integrability,message,message,10153,"t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. ",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:401,Performance,perform,performance,401,". TSlave. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TSlave. class TSlave: public TObject. TSlave. This class describes a PROOF slave server.; It contains information like the slaves host name, ordinal number,; performance index, socket, etc. Objects of this class can only be; created via TProof member functions. Function Members (Methods); public:. virtual~TSlave(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchCompiler() const; Long64_tGetBytesRead() const; Float_tGetCpuTime() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:7532,Performance,perform,performance,7532,"ring wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tfBytesReadbytes read by slave (info is obtained from slave); Float_tfCpuTimeCPU time spent executing commands (info obtained from slave); TStringfGroupslave's group id; TStringfImageslave's image name; TFileHandler*fInputinput handler related to this slave; TStringfMsdmass storage domain of slave; TStringfNameslave's hostname; TStringfOrdinalslave's ordinal number; Int_tfParallelnumber of active slaves; Int_tfPerfIdxrelative CPU performance index; Int_tfPortslave's port number; TProof*fProofproof cluster to which slave belongs; TStringfProofWorkDirbase proofserv working directory (info obtained from slave); Int_tfProtocolslave's protocol level; TStringfROOTVersROOT version run by worker; Float_tfRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypefSlaveTypetype of slave (either kMaster or kSlave); TSocket*fSocketsocket to slave; Int_tfStatusremote return status; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSla",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:9188,Performance,perform,performance,9188,"nheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to i",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:6151,Safety,abort,abort,6151,"ave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSlave(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFlushSocket(); voidInit(TSocket* s, Int_t stype); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char*, Int_t); virtual voidSetAlias(const char* alias); voidSetSocket(TSocket* s); virtual voidSetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. TSlave(const TSlave& s); TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); static TSlave*Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); voidInit(const char* host, Int_t port, Int_t stype); Int_tOldAuthSetup(Bool_t master, TString wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObj",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:6164,Safety,timeout,timeout,6164,"ave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSlave(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFlushSocket(); voidInit(TSocket* s, Int_t stype); virtual voidInterrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tPing(); virtual TObjString*SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tSendGroupPriority(const char*, Int_t); virtual voidSetAlias(const char* alias); voidSetSocket(TSocket* s); virtual voidSetStatus(Int_t st); virtual voidStopProcess(Bool_t abort, Int_t timeout). private:. TSlave(const TSlave& s); TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); static TSlave*Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); voidInit(const char* host, Int_t port, Int_t stype); Int_tOldAuthSetup(Bool_t master, TString wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObj",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:8974,Safety,avoid,avoid,8974,"tatus; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t ",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10005,Safety,abort,abort,10005,"ound a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10018,Safety,timeout,timeout,10018,"ound a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10038,Safety,abort,abort,10038,"ound a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:10420,Safety,recover,recovered,10420,"eted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. Int_t GetPort() const; { return fPort; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetPerfIdx() const; { return fPerfIdx; }. Int_t GetProtocol() const; { return fProtocol; }. TSocket * GetSocket() const; { return fSocket; }. TProof ",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlave.html:9457,Security,authenticat,authentication,9457,"ult constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlave ctor.; The Init method is technology specific and is overwritten by derived; classes. void Init(TSocket* s, Int_t stype); Init a PROOF slave object using the connection opened via s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. vo",MatchSource.WIKI,root/html528/TSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlave.html
https://root.cern/root/html528/TSlaveInfo.html:1668,Availability,error,error,1668,"host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); ~TSlaveInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDataDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*GetMsd() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOrdinal() const; SysInfo_tGetSysInfo() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(",MatchSource.WIKI,root/html528/TSlaveInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveInfo.html
https://root.cern/root/html528/TSlaveInfo.html:1752,Availability,error,error,1752,"veInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDataDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*GetMsd() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOrdinal() const; SysInfo_tGetSysInfo() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html528/TSlaveInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveInfo.html
https://root.cern/root/html528/TSlaveInfo.html:503,Integrability,message,messages,503,". TSlaveInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TSlaveInfo. class TSlaveInfo: public TObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. TSlaveInfo(const TSlaveInfo&); TSlaveInfo(const char* ordinal = """", const char* host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); ~TSlaveInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root/html528/TSlaveInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveInfo.html
https://root.cern/root/html528/TSlaveInfo.html:5761,Performance,perform,performance,5761,"_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum ESlaveStatus { kActive; kNotActive; kBad; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStringfDataDirdirectory for user data; TStringfHostNamehostname this slave is running on; TStringfMsdmass storage domain slave is in; TStringfOrdinalslave ordinal; Int_tfPerfIndexrelative performance of this slave; TSlaveInfo::ESlaveStatusfStatusslave status; SysInfo_tfSysInfoInfomation about its hardware. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t Compare(const TObject* obj) const; Used to sort slaveinfos by ordinal. void Print(Option_t* option = """") const; Print slave info. If opt = ""active"" print only the active; slaves, if opt=""notactive"" print only the not active slaves,; if opt = ""bad"" print only the bad slaves, else; print all slaves. void SetSysInfo(SysInfo_t si); Setter for fSysInfo. TProofInterruptHandler& operator=(const TSlaveInfo& ). TSlaveInfo(const char* ordinal = """", const char* host = """", Int_t perfidx = 0, const char* msd = """", const char* datadir = """"); { }. const char * GetDataDir() const; { return fDataDir; }. const char * GetMsd() const; { return fMsd; }. const char * GetName() const; { return fHostName; }. const char * GetOrdinal() const; { return fOrdinal; }.",MatchSource.WIKI,root/html528/TSlaveInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveInfo.html
https://root.cern/root/html528/TSlaveLite.html:1609,Availability,error,error,1609,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTSlave::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TSlave::GetArchCompiler() const; Long64_tTSlave::GetBytesRead() const; Float_tTSlave::GetCpuTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TSlave::GetGroup() const; virtual const char*TObject::GetIconName() const; const char*TSlave::GetImage() const; TFileHandler*TSlave::GetInputHandler() const; const char*TSlave::GetMsd() const; virtual const char*TSlave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*TSlave::GetOrdinal() const; Int_",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlaveLite.html:1693,Availability,error,error,1693,"ect::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTSlave::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TSlave::GetArchCompiler() const; Long64_tTSlave::GetBytesRead() const; Float_tTSlave::GetCpuTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TSlave::GetGroup() const; virtual const char*TObject::GetIconName() const; const char*TSlave::GetImage() const; TFileHandler*TSlave::GetInputHandler() const; const char*TSlave::GetMsd() const; virtual const char*TSlave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*TSlave::GetOrdinal() const; Int_tTSlave::GetParallel() const; Int_tTSlave::GetPerfIdx() const; Int_tTSlave::GetPort(",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlaveLite.html:7758,Integrability,protocol,protocol,7758," };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* wor",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlaveLite.html:7522,Performance,perform,performance,7522," };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSlave::fInputinput handler related to this slave; TStringTSlave::fMsdmass storage domain of slave; TStringTSlave::fNameslave's hostname; TStringTSlave::fOrdinalslave's ordinal number; Int_tTSlave::fParallelnumber of active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* wor",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlaveLite.html:6475,Safety,abort,abort,6475,"dTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSla",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlaveLite.html:6488,Safety,timeout,timeout,6488,"dTSlave::SetTXSlaveHook(TSlave_t xslavehook); virtual voidTObject::SetUniqueID(UInt_t uid); virtual Int_tSetupServ(Int_t stype, const char* conffile); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTSlave::Touch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSlave::FlushSocket(); virtual voidTSlave::Interrupt(Int_t type); voidTObject::MakeZombie(); virtual Int_tTSlave::Ping(); virtual TObjString*TSlave::SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); virtual Int_tTSlave::SendGroupPriority(const char*, Int_t); virtual voidTSlave::SetAlias(const char* alias); voidTSlave::SetSocket(TSocket* s); virtual voidTSlave::SetStatus(Int_t st); virtual voidTSlave::StopProcess(Bool_t abort, Int_t timeout). private:. voidInit(). Data Members; public:. enum TSlave::ESlaveType { kMaster; kSlave; };; enum TSlave::ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSlave::fArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tTSlave::fBytesReadbytes read by slave (info is obtained from slave); Float_tTSlave::fCpuTimeCPU time spent executing commands (info obtained from slave); TStringTSlave::fGroupslave's group id; TStringTSlave::fImageslave's image name; TFileHandler*TSla",MatchSource.WIKI,root/html528/TSlaveLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlaveLite.html
https://root.cern/root/html528/TSlider.html:7698,Availability,error,error,7698,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:7782,Availability,error,error,7782,"oidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTPad::GetEvent() const; virtual Int_tTPa",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:25675,Availability,down,down,25675,,MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:796,Deployability,release,released,796,". TSlider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TSlider. class TSlider: public TPad. TSlider. A TSlider object is a specialized TPad including a TSliderBox object; The TSliderBox can be moved in the pad.; Slider drawing options include the possibility to change the slider; starting and ending positions or only one of them. The current slider position can be retrieved via the functions; TSlider::GetMinimum and TSlider::GetMaximum; These two functions return numbers in the range [0,1]. if a method has been set (via SetMethod), the expression is; executed via the interpreter when the button 1 is released. if no method has been set, and an object is referenced (SetObject; has been called), while the slider is being moved/resized,; the object ExecuteEvent function is called. //. Example 1 using SetMethod macro xyslider.C. { ; Example of macro featuring two sliders; TFile *f = new TFile(""hsimple.root"");; TH2F *hpxpy = (TH2F*)f->Get(""hpxpy"");; TCanvas *c1 = new TCanvas(""c1"");; TPad *pad = new TPad(""pad"",""lego pad"",0.1,0.1,0.98,0.98);; pad->SetFillColor(33);; pad->Draw();; pad->cd();; gStyle->SetFrameFillColor(42);; hpxpy->SetFillColor(46);; hpxpy->Draw(""lego1"");; c1->cd();. Create two sliders in main canvas. When button1; of the mouse will be released, action.C will be called; TSlider *xslider = new TSlider(""xslider"",""x"",0.1,0.02,0.98,0.08);; xslider->SetMethod("".x action.C"");; TSlider *yslider = new TSlider(""yslider"",""y"",0.02,0.1,0.06,0.98);; yslider->SetMethod("".x action.C"");; } . macro action.C; { ; Int_t nx = hpxpy->GetXaxis()->GetNbins();; Int_t ny = hpxpy->GetYaxis()->GetNbins();; Int_t binxmin = nx*xslider->GetMinimum();; Int_t binxmax = nx*xslider->GetMaximum();; hpxpy->GetXaxis()->SetRange(binxmin,binxmax);; Int_t binymin = ny*yslider->GetMinimum();; Int_t binymax = ny*ysl",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:1452,Deployability,release,released,1452,"ility to change the slider; starting and ending positions or only one of them. The current slider position can be retrieved via the functions; TSlider::GetMinimum and TSlider::GetMaximum; These two functions return numbers in the range [0,1]. if a method has been set (via SetMethod), the expression is; executed via the interpreter when the button 1 is released. if no method has been set, and an object is referenced (SetObject; has been called), while the slider is being moved/resized,; the object ExecuteEvent function is called. //. Example 1 using SetMethod macro xyslider.C. { ; Example of macro featuring two sliders; TFile *f = new TFile(""hsimple.root"");; TH2F *hpxpy = (TH2F*)f->Get(""hpxpy"");; TCanvas *c1 = new TCanvas(""c1"");; TPad *pad = new TPad(""pad"",""lego pad"",0.1,0.1,0.98,0.98);; pad->SetFillColor(33);; pad->Draw();; pad->cd();; gStyle->SetFrameFillColor(42);; hpxpy->SetFillColor(46);; hpxpy->Draw(""lego1"");; c1->cd();. Create two sliders in main canvas. When button1; of the mouse will be released, action.C will be called; TSlider *xslider = new TSlider(""xslider"",""x"",0.1,0.02,0.98,0.08);; xslider->SetMethod("".x action.C"");; TSlider *yslider = new TSlider(""yslider"",""y"",0.02,0.1,0.06,0.98);; yslider->SetMethod("".x action.C"");; } . macro action.C; { ; Int_t nx = hpxpy->GetXaxis()->GetNbins();; Int_t ny = hpxpy->GetYaxis()->GetNbins();; Int_t binxmin = nx*xslider->GetMinimum();; Int_t binxmax = nx*xslider->GetMaximum();; hpxpy->GetXaxis()->SetRange(binxmin,binxmax);; Int_t binymin = ny*yslider->GetMinimum();; Int_t binymax = ny*yslider->GetMaximum();; hpxpy->GetYaxis()->SetRange(binymin,binymax);; pad->cd();; hpxpy->Draw(""lego1"");; c1->Update();; } ; The canvas and the sliders created in the above macro are shown; in the picture below. //; /*. */. Example 2 using SetObject macro xyslider.C. Same example as above. Instead of SetMethod:; Myclass *obj = new Myclass(); // Myclass derived from TObject; xslider->SetObject(obj);; yslider->SetObject(obj);. When the slider ",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:27255,Testability,log,log,27255,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Double_tfMaximumSlider maximum value in [0,1]; TStringfMethodcommand to be executed when slider is changed; Double_tfMinimumSlider minimum value in [0,1]; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TObject*fObject!Pointer to associated object; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap i",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:27312,Testability,log,log,27312,"2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Double_tfMaximumSlider maximum value in [0,1]; TStringfMethodcommand to be executed when slider is changed; Double_tfMinimumSlider minimum value in [0,1]; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TObject*fObject!Pointer to associated object; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (s",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSlider.html:27369,Testability,log,log,27369,"pad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Double_tfMaximumSlider maximum value in [0,1]; TStringfMethodcommand to be executed when slider is changed; Double_tfMinimumSlider minimum value in [0,1]; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TObject*fObject!Pointer to associated object; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing ",MatchSource.WIKI,root/html528/TSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSlider.html
https://root.cern/root/html528/TSliderBox.html:1778,Availability,error,error,1778,"Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTWbox::Copy(TObject& wbox) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTWbox::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html528/TSliderBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSliderBox.html
https://root.cern/root/html528/TSliderBox.html:1862,Availability,error,error,1862,"t; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTWbox::Copy(TObject& wbox) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTWbox::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::G",MatchSource.WIKI,root/html528/TSliderBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSliderBox.html
https://root.cern/root/html528/TSliderBox.html:7677,Availability,down,down,7677,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSliderBox(const TSliderBox& sb); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TSliderBox&operator=(const TSliderBox& sb). Data Members; public:. enum TBox::[unnamed] { kCannotMove; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Short_tTWbox::fBorderModeBordermode (-1=down, 0 = no border, 1=up); Short_tTWbox::fBorderSizewindow box bordersize in pixels; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tTBox::fResizing!True if box is being resized; TSlider*fSliderPointer to slider; Double_tTBox::fX1X of 1st point; Double_tTBox::fX2X of 2nd point; Double_tTBox::fY1Y of 1st point; Double_tTBox::fY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSliderBox(); SliderBox default constructor. TSliderBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 18, Short_t bordersize = 2, Short_t bordermode = -1); SliderBox normal constructor. ~TSliderBox(); SliderBox default destructor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Interaction with a slider. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. TSliderBox(const TSliderBox& sb); { }. TSliderBox& operator=(const TSliderBox& sb). void SetSlider(TSlider* slider); {fSlider=slider;}. » Author: Rene Brun 23/11/96 » Copyright (C) 1995-",MatchSource.WIKI,root/html528/TSliderBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSliderBox.html
https://root.cern/root/html528/TSocket.html:2153,Availability,error,error,2153,"ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; static Int_tGetClientProtocol(); Int_tGetCompressionLevel() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectS",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:2237,Availability,error,error,2237,"*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; static Int_tGetClientProtocol(); Int_tGetCompressionLevel() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; I",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:4404,Availability,error,error,4404," ULong64_tGetSocketBytesSent(); Int_tGetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voi",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:12765,Availability,down,down,12765," check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Se",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13075,Availability,error,error,13075,"dity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13209,Availability,error,error,13209,"perly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" fiel",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13400,Availability,avail,available,13400," Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an ackno",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13708,Availability,error,error,13708,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13915,Availability,error,error,13915,"dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:14301,Availability,error,error,14301,"d, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EP",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:14679,Availability,error,error,14679,"has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having re",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:14980,Availability,error,error,14980," been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:15541,Availability,error,error,15541,"NG); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on th",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:15914,Availability,error,error,15914,"ge object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16774,Availability,error,error,16774,"ndRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:17110,Availability,error,error,17110,"ss); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:17400,Availability,error,error,17400,"sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containin",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:17692,Availability,error,error,17692,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18101,Availability,error,error,18101," or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18865,Availability,error,error,18865,"e mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18908,Availability,error,error,18908,", Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = fo",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18974,Availability,error,error,18974,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", """,MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23156,Availability,error,error,23156,":CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionLevel() const; { return fCompress; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetSecContext() const; { return fSecContext; }. Int_t GetTc",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23170,Availability,error,error,23170,":CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionLevel() const; { return fCompress; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetSecContext() const; { return fSecContext; }. Int_t GetTc",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23196,Availability,error,error,23196,":CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionLevel() const; { return fCompress; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetSecContext() const; { return fSecContext; }. Int_t GetTc",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:9339,Integrability,protocol,protocol,9339,"tor=(const TSocket&). Data Members; public:. enum EStatusBits { kIsUnix; };; enum EInterest { kRead; kWrite; };; enum EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompresscompression level from 0 (not compressed); TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; Int_tfTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects; static Int_tfgClientProtocolclient ""protocol"" version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSocket(TInetAddress address, const char* service, Int_t tcpwindowsize = -1); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting wi",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13761,Integrability,message,message,13761,"(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:14145,Integrability,message,message,14145,". Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, makin",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16188,Integrability,message,message,16188,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16225,Integrability,message,message,16225,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16420,Integrability,message,message,16420,"ject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16591,Integrability,message,message,16591,"en or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMe",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16636,Integrability,message,message,16636," an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other sid",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16941,Integrability,message,message,16941,"r.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRe",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:16993,Integrability,message,message,16993,"-5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length byt",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:17265,Integrability,message,message,17265,"end only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:17608,Integrability,message,message,17608,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18351,Integrability,message,message,18351,"0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18398,Integrability,message,message,18398,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with sp",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18454,Integrability,message,message,18454,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with sp",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18558,Integrability,message,message,18558,"he user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TS",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18602,Integrability,message,message,18602,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18655,Integrability,message,message,18655,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:18928,Integrability,depend,depends,18928,"); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:19106,Integrability,message,message,19106,"case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remo",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:19352,Integrability,message,message,19352,"eive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An a",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20800,Integrability,protocol,protocol,20800,"options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21036,Integrability,protocol,protocol,21036,"RP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are mast",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22529,Integrability,protocol,protocol,22529,"cket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescrip",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22767,Integrability,protocol,protocol,22767," session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23107,Integrability,protocol,protocol,23107,"opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionLevel() const; { return fCompress; }. Int_t GetRemoteProtocol() const; { return fRemoteP",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23183,Integrability,depend,depending,23183,":CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionLevel() const; { return fCompress; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetSecContext() const; { return fSecContext; }. Int_t GetTc",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:5641,Safety,timeout,timeout,5641,"ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; vi",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13270,Safety,timeout,timeout,13270," Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13520,Safety,timeout,timeout,13520,"poses only. Use; this method to adopt e.g. a socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13587,Safety,timeout,timeout,13587,"socket created via socketpair(). TSocket(const TSocket& s); TSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13650,Safety,detect,detected,13650,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13667,Safety,timeout,timeout,13667,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:13689,Safety,timeout,timeout,13689,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:9141,Security,authenticat,authentication,9141,"tor=(const TSocket&). Data Members; public:. enum EStatusBits { kIsUnix; };; enum EInterest { kRead; kWrite; };; enum EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompresscompression level from 0 (not compressed); TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; Int_tfTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects; static Int_tfgClientProtocolclient ""protocol"" version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSocket(TInetAddress address, const char* service, Int_t tcpwindowsize = -1); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting wi",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:11440,Security,authenticat,authentication,11440," remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* host, const char* service, Int_t tcpwindowsize = -1); Create a socket. Connect to named service on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* host, Int_t port, Int_t tcpwindowsize = -1); Create a socket; see CreateAuthSocket for the form of url.; Connect to the specified port # on the remote host.; If user is specified in url, try authentication as user.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TSocket(Int_t descriptor, const char* sockpath); Create a socket. Th",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:19606,Security,authenticat,authenticates,19606,"eive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20057,Security,authenticat,authentication,20057,"example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication w",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20503,Security,authenticat,authenticated,20503,"owsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in '",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20772,Security,authenticat,authentication,20772,"options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20894,Security,authenticat,authenticated,20894,"or; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGi",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21008,Security,authenticat,authentication,21008,"RP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are mast",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21234,Security,authenticat,authenticated,21234,"o=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a r",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21276,Security,authenticat,authentication,21276,"o=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a r",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21484,Security,authenticat,authenticates,21484,"CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:21937,Security,authenticat,authentication,21937,"thSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of t",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22232,Security,authenticat,authenticated,22232,"creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of byt",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22501,Security,authenticat,authentication,22501,"cket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescrip",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22625,Security,authenticat,authenticated,22625," type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress()",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22739,Security,authenticat,authentication,22739," session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22965,Security,authenticat,authenticated,22965,"oofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionL",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:23007,Security,authenticat,authentication,23007,"oofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescriptor(). TSocket(); { }. TSocket& operator=(const TSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetCompressionL",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:20690,Usability,simpl,simple,20690,"options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSocket.html:22419,Usability,simpl,simple,22419,"cket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescrip",MatchSource.WIKI,root/html528/TSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSocket.html
https://root.cern/root/html528/TSortedList.html:2409,Availability,error,error,2409,"voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t",MatchSource.WIKI,root/html528/TSortedList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSortedList.html
https://root.cern/root/html528/TSortedList.html:2493,Availability,error,error,2493,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual ",MatchSource.WIKI,root/html528/TSortedList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSortedList.html
https://root.cern/root/html528/TSortedList.html:342,Modifiability,inherit,inheriting,342,". TSortedList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSortedList. class TSortedList: public TList. A sorted doubly linked list. All sortable classes inheriting from; TObject can be inserted in a TSortedList. Function Members (Methods); public:. TSortedList(Bool_t order = kSortAscending); ~TSortedList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidAddAfter(TObjLink*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddBefore(TObjLink*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); ",MatchSource.WIKI,root/html528/TSortedList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSortedList.html
https://root.cern/root/html528/TSortedList.html:9326,Performance,cache,cache,9326,"ompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Add(TObject* obj); Add object in sorted list. Uses object Compare() member to find right; position. void Add(TObject* obj, Option_t* opt); Add object in sorted list. Uses object Compare() member to find right; position and also store option. See TList::Add for explanation of; usage of option. TSortedList(Bool_t order = kSortAscending); { fAscending = order; }. Bool_t IsSorted() const; { return kTRUE; }. void AddFirst(TObject* obj); ---- the following methods are overridden to preserve sorting order. { Add(obj); }. void AddFirst(TObject* obj, Option_t* opt); { Add(obj, opt); }. void AddLast(TObject* obj); { Add(obj); }. void AddLast(TObject* obj, Option_t* opt)",MatchSource.WIKI,root/html528/TSortedList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSortedList.html
https://root.cern/root/html528/TSpectrum.html:1404,Availability,avail,available,1404,"nd estimation; One-dimensional smoothing; One-dimensional deconvolution; One-dimensional peak search. Author:. Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA; email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following references:. M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-132.; M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408.; M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as doc or ps files from:. Spectrum.doc; SpectrumDec.ps.gz; SpectrumSrc.ps.gz; SpectrumBck.ps.gz. . Function Members (Methods); public:. TSpectrum(); TSpectrum(Int_t maxpositions, Float_t resolution = 1); virtual~TSpectrum(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TH1*Background(const TH1* hist, Int_t niter = 20, Option_t* option = """"); const char*Background(float* spectrum, Int_t ssize, Int_t numberIterations, Int_t direction, Int_t filterOrder, bool smoothing, Int_t smoothWindow, bool compton); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(float* source, const float* response, Int_t ssize, Int_t num",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:3084,Availability,error,error,3084,"ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); const char*DeconvolutionRL(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNPeaks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_t*GetPositionX() const; Float_t*GetPositionY() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNa",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:3168,Availability,error,error,3168,"*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); const char*DeconvolutionRL(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNPeaks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_t*GetPositionX() const; Float_t*GetPositionY() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:13968,Availability,error,error,13968,"resolution; (smaller distance between peaks.; May be set later through SetResolution.; ; . const char * Background(float* spectrum, Int_t ssize, Int_t numberIterations, Int_t direction, Int_t filterOrder, bool smoothing, Int_t smoothWindow, bool compton). This function calculates background spectrum from source spectrum.; The result is placed in the vector pointed by spe1945ctrum pointer.; The goal is to separate the useful information (peaks) from useless; information (background). method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; algorithm.; new value in the channel ""i"" is calculated. where p = 1, 2, ..., numberIterations. In fact it represents second order; difference filter (-1,2,-1).; One can also change the; direction of the change of the clipping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience app",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:14018,Availability,error,error,14018,"resolution; (smaller distance between peaks.; May be set later through SetResolution.; ; . const char * Background(float* spectrum, Int_t ssize, Int_t numberIterations, Int_t direction, Int_t filterOrder, bool smoothing, Int_t smoothWindow, bool compton). This function calculates background spectrum from source spectrum.; The result is placed in the vector pointed by spe1945ctrum pointer.; The goal is to separate the useful information (peaks) from useless; information (background). method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; algorithm.; new value in the channel ""i"" is calculated. where p = 1, 2, ..., numberIterations. In fact it represents second order; difference filter (-1,2,-1).; One can also change the; direction of the change of the clipping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience app",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:25674,Availability,error,error,25674," nbins; i++) d2->SetBinContent(i + 1,source[i]);; d2->SetLineColor(kBlue);; d2->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,40,kBackDecreasingWindow,kBackOrder6,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,source[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,40,kBackDecreasingWindow,kBackOrder8,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d4->SetBinContent(i + 1,source[i]);; d4->SetLineColor(kMagenta);; d4->Draw(""SAME L"");; }. Example 6 script Background_smooth.c:. The estimate of the background can be influenced by noise present in the; spectrum. We proposed the algorithm of the background estimate with; simultaneous smoothing. In the original algorithm without smoothing, the; estimated background snatches the lower spikes in the noise. Consequently,; the areas of peaks are biased by this error. Figure 7 Principle of background estimation algorithm with simultaneous; smoothing. Figure 8 Illustration of non-smoothing (red line) and smoothing algorithm of; background estimation (blue line). Script:. // Example to illustrate the background estimator (class TSpectrum) including; // Compton edges. To execute this example, do:; // root > .x Background_smooth.C; #include ; void Background_smooth() {; Int_t i;; Double_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back4;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Estimation of background with noise"",10,10,1000,700);; h->SetAxisRange(3460,3830);;",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:29253,Availability,error,error,29253,"ew TH1F(""d1"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back3;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Estimation of background with Compton edges under peaks"",10,10,1000,700);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,10,kBackDecreasingWindow,kBackOrder8,kTRUE,; kBackSmoothing5,,kTRUE);; for (i = 0; i < nbins; i++) d1->SetBinContent(i + 1,source[i]);; d1->SetLineColor(kRed);; d1->Draw(""SAME L"");; }. . const char* SmoothMarkov(float* source, Int_t ssize, Int_t averWindow). One-dimensional markov spectrum smoothing function. This function calculates smoothed spectrum from source spectrum based on; Markov chain method. The result is placed in the array pointed by source; pointer. On successful completion it returns 0. On error it returns pointer; to the string describing error.; ; Function parameters:; ; source: pointer to the array of source spectrum; ssize: length of source array; averWindow: width of averaging smoothing window; ; The goal of this function is the suppression of the statistical fluctuations.; The algorithm is based on discrete Markov chain, which has very simple; invariant distribution:; . being defined; from the normalization condition; .; n is the length of the smoothed spectrum and; . Reference:; ; Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451.; . Example 14 - script Smoothing.c; . Fig. 23 Original noisy spectrum; . Fig. 24 Smoothed spectrum m=3; . Fig. 25 Smoothed spectrum; . Fig.26 Smoothed spectrum m=10; ; Script:; ; // Example to illustrate smoothing using Markov algorithm (class TSpectrum).; // To execute this example, do; // root > .x Smoothing.C; void Smoothing() {; Int_t i;; Double_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:29304,Availability,error,error,29304,"ew TH1F(""d1"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back3;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Estimation of background with Compton edges under peaks"",10,10,1000,700);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,10,kBackDecreasingWindow,kBackOrder8,kTRUE,; kBackSmoothing5,,kTRUE);; for (i = 0; i < nbins; i++) d1->SetBinContent(i + 1,source[i]);; d1->SetLineColor(kRed);; d1->Draw(""SAME L"");; }. . const char* SmoothMarkov(float* source, Int_t ssize, Int_t averWindow). One-dimensional markov spectrum smoothing function. This function calculates smoothed spectrum from source spectrum based on; Markov chain method. The result is placed in the array pointed by source; pointer. On successful completion it returns 0. On error it returns pointer; to the string describing error.; ; Function parameters:; ; source: pointer to the array of source spectrum; ssize: length of source array; averWindow: width of averaging smoothing window; ; The goal of this function is the suppression of the statistical fluctuations.; The algorithm is based on discrete Markov chain, which has very simple; invariant distribution:; . being defined; from the normalization condition; .; n is the length of the smoothed spectrum and; . Reference:; ; Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451.; . Example 14 - script Smoothing.c; . Fig. 23 Original noisy spectrum; . Fig. 24 Smoothed spectrum m=3; . Fig. 25 Smoothed spectrum; . Fig.26 Smoothed spectrum m=10; ; Script:; ; // Example to illustrate smoothing using Markov algorithm (class TSpectrum).; // To execute this example, do; // root > .x Smoothing.C; void Smoothing() {; Int_t i;; Double_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:31281,Availability,error,error,31281,"s];; TH1F *h = new TH1F(""h"",""Smoothed spectrum for m=3"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""smooth1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Smooth1 = gROOT->GetListOfCanvases()->FindObject(""Smooth1"");; if (!Smooth1) Smooth1 = new TCanvas(""Smooth1"",""Smooth1"",10,10,1000,700);; TSpectrum *s = new TSpectrum();; s->SmoothMarkov(source,1024,3); //3, 7, 10; for (i = 0; i < nbins; i++) h->SetBinContent(i + 1,source[i]);; h->SetAxisRange(330,880);; h->Draw(""L"");; }; ; . const char * Deconvolution(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Gold deconvolution algorithm. The result is placed; in the vector pointed by source pointer. On successful completion it; returns 0. On error it returns pointer to the string describing error. If; desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times.; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given below; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; ; The goal of this function is the improvement of the resolution in spectra,; decomposition of multiplets. The mathematical formulation of; the convolution system is:; . where h(i) is the impulse response function, x, y are input and output; vectors, respectively, N is the length of x and h vectors. In matrix form; we have:; . Let us assume that we know the response and the output vector (spectrum) of; the above given system. The deconvolution represents s",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:31331,Availability,error,error,31331,"s];; TH1F *h = new TH1F(""h"",""Smoothed spectrum for m=3"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""smooth1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Smooth1 = gROOT->GetListOfCanvases()->FindObject(""Smooth1"");; if (!Smooth1) Smooth1 = new TCanvas(""Smooth1"",""Smooth1"",10,10,1000,700);; TSpectrum *s = new TSpectrum();; s->SmoothMarkov(source,1024,3); //3, 7, 10; for (i = 0; i < nbins; i++) h->SetBinContent(i + 1,source[i]);; h->SetAxisRange(330,880);; h->Draw(""L"");; }; ; . const char * Deconvolution(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Gold deconvolution algorithm. The result is placed; in the vector pointed by source pointer. On successful completion it; returns 0. On error it returns pointer to the string describing error. If; desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times.; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given below; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; ; The goal of this function is the improvement of the resolution in spectra,; decomposition of multiplets. The mathematical formulation of; the convolution system is:; . where h(i) is the impulse response function, x, y are input and output; vectors, respectively, N is the length of x and h vectors. In matrix form; we have:; . Let us assume that we know the response and the output vector (spectrum) of; the above given system. The deconvolution represents s",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:40049,Availability,error,error,40049," s->Deconvolution(source,response,256,10000,1,1);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; . Example 10 - script Deconvolution_wide_boost.c :. Further let us employ boosting operation into deconvolution (Fig. 17).; . Figure 17 The original source spectrum is drawn with black color, the; spectrum after the deconvolution with red color. Number of iterations = 200,; number of repetitions = 50 and boosting coefficient = 1.2.; . Peak # Original/Estimated (max) position Original/Estimated area ; ; 1 50/49 10159/10419 ; ; 2 70/70 60957/58933 ; ; 3 80/79 20319/19935 ; ; 4 100/100 101596/105413 ; ; 5 110/117 10159/6676 ; . Table 2 Results of the estimation of peaks in spectrum shown in Figure 17.; ; One can observe that peaks are decomposed practically to delta functions.; Number of peaks is correct, positions of big peaks as well as their areas; are relatively well estimated. However there is a considerable error in; the estimation of the position of small right hand peak.; ; Script:; . // Example to illustrate deconvolution function (class TSpectrum).; // To execute this example, do; // root > .x Deconvolution_wide_boost.C; #include ; void Deconvolution_wide_boost() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * response = new float[nbins];; TH1F *h = new TH1F(""h"",""Deconvolution"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""decon3;1"");; TFile *fr = new TFile(""spectra\\TSpectrum.root"");; d=(TH1F*) fr->Get(""decon_response_wide;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:41789,Availability,error,error,41789,"t(i + 1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Gold deconvolution method"",10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * DeconvolutionRL(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Richardson-Lucy deconvolution algorithm. The result; is placed in the vector pointed by source pointer. On successful completion; it returns 0. On error it returns pointer to the string describing error.; If desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times (see Gold deconvolution).; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given above; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; . Richardson-Lucy deconvolution algorithm:. For discrete systems it has the form:; . for positive input data and response matrix this iterative method forces; the deconvoluted spectra to be non-negative. The Richardson-Lucy; iteration converges to the maximum likelihood solution for Poisson statistics; in the data.; ; References:. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; experimental data, NIM A 4",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:41839,Availability,error,error,41839,"t(i + 1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Gold deconvolution method"",10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * DeconvolutionRL(float* source, const float* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Richardson-Lucy deconvolution algorithm. The result; is placed in the vector pointed by source pointer. On successful completion; it returns 0. On error it returns pointer to the string describing error.; If desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times (see Gold deconvolution).; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given above; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; . Richardson-Lucy deconvolution algorithm:. For discrete systems it has the form:; . for positive input data and response matrix this iterative method forces; the deconvoluted spectra to be non-negative. The Richardson-Lucy; iteration converges to the maximum likelihood solution for Poisson statistics; in the data.; ; References:. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; experimental data, NIM A 4",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:47196,Availability,error,error,47196,"(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Richardson-Lucy deconvolution method"",; 10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->DeconvolutionRL(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * Unfolding(float* source, const float** respMatrix, Int_t ssizex, Int_t ssizey, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional unfolding function. This function unfolds source spectrum according to response matrix columns.; The result is placed in the vector pointed by source pointer.; The coefficients of the resulting vector represent contents of the columns; (weights) in the input vector. On successful completion it returns 0. On; error it returns pointer to the string describing error. If desired after; every numberIterations one can apply boosting operation (exponential; function with exponent given by boost coefficient) and repeat it; numberRepetitions times. For details we refer to [1].; ; Function parameters:; ; source: pointer to the vector of source spectrum; respMatrix: pointer to the matrix of response spectra; ssizex: length of source spectrum and # of columns of the response; matrix. ssizex must be >= ssizey.; ssizey: length of destination spectrum and # of rows of the response; matrix.; numberIterations: number of iterations; numberRepetitions: number of repetitions for boosted deconvolution.; It must be greater or equal to one.; boost: boosting coefficient, applies only if numberRepetitions is; greater than one.; . Unfolding:. The goal is the decomposition of spectrum to a given set of component; spectra.; ; The mathematical formulation of the discrete linear system is:; . References:. Jandel M., Morh�č M., Kliman J., Krupa ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:47246,Availability,error,error,47246,"(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Richardson-Lucy deconvolution method"",; 10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->DeconvolutionRL(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * Unfolding(float* source, const float** respMatrix, Int_t ssizex, Int_t ssizey, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional unfolding function. This function unfolds source spectrum according to response matrix columns.; The result is placed in the vector pointed by source pointer.; The coefficients of the resulting vector represent contents of the columns; (weights) in the input vector. On successful completion it returns 0. On; error it returns pointer to the string describing error. If desired after; every numberIterations one can apply boosting operation (exponential; function with exponent given by boost coefficient) and repeat it; numberRepetitions times. For details we refer to [1].; ; Function parameters:; ; source: pointer to the vector of source spectrum; respMatrix: pointer to the matrix of response spectra; ssizex: length of source spectrum and # of columns of the response; matrix. ssizex must be >= ssizey.; ssizey: length of destination spectrum and # of rows of the response; matrix.; numberIterations: number of iterations; numberRepetitions: number of repetitions for boosted deconvolution.; It must be greater or equal to one.; boost: boosting coefficient, applies only if numberRepetitions is; greater than one.; . Unfolding:. The goal is the decomposition of spectrum to a given set of component; spectra.; ; The mathematical formulation of the discrete linear system is:; . References:. Jandel M., Morh�č M., Kliman J., Krupa ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51526,Deployability,continuous,continuous,51526,"n. The highest peak is the first in; the list. On success it returns number of found peaks.; ; Function parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A4",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51787,Deployability,continuous,continuous,51787,"gma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:58319,Deployability,release,release,58319," source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 10, kTRUE, 3);; for (i = 0; i < nbins; i++) d2->SetBinContent(i + 1,dest[i]);; d2->SetLineColor(kBlue);; d2->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 100, kTRUE, 3);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,dest[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 1000, kTRUE, 3);; for (i = 0; i < nbins; i++) d4->SetBinContent(i + 1,dest[i]);; d4->SetLineColor(kMagenta);; d4->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; }; ; ; . Int_t Search1HighRes(float* source, float* destVector, Int_t ssize, float sigma, Double_t threshold, bool backgroundRemove, Int_t deconIterations, bool markov, Int_t averWindow). Old name of SearcHighRes introduced for back compatibility.; This function will be removed after the June 2006 release; ; . Int_t StaticSearch(const TH1* hist, Double_t sigma = 2, Option_t* option = ""goff"", Double_t threshold = 0.05). Static function, interface to TSpectrum::Search.; ; . TH1 * StaticBackground(const TH1* hist, Int_t niter = 20, Option_t* option = """"). Static function, interface to TSpectrum::Background.; ; . TSpectrum(const TSpectrum& ). TSpectrum& operator=(const TSpectrum& ). TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNPeaks() const; {return fNPeaks;}. Float_t * GetPositionX() const; {return fPositionX;}. Float_t * GetPositionY() const; {return fPositionY;}. » Author: Miroslav Morhac 27/05/99 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-30 18:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:18378,Energy Efficiency,green,green,18378,"nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; back=(TH1F*) f->Get(""back1;1"");; TCanvas *Background = gROOT->GetListOfCanvases()->FindObject(""Background"");; if (!Background) Background =; new TCanvas(""Background"",""Estimation of background with decreasing window"",; 10,10,1000,700);; back->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=back->GetBinContent(i + 1);; s->Background(source,nbins,6,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }. Example 3 script Background_width.c:. The question is how to choose the width of the clipping window, i.e.,; numberIterations parameter. The influence of this parameter on the estimated; background is illustrated in Figure 3. Figure 3 Example of the influence of clipping window width on the estimated; background for numberIterations=4 (red line), 6 (blue line) 8 (green line) using; decreasing clipping window algorithm. in general one should set this parameter so that the value; 2*numberIterations+1 was greater than the widths of preserved objects (peaks). Script:. // Example to illustrate the influence of the clipping window width on the; // estimated background. To execute this example, do:; // root > .x Background_width.C; #include ; void Background_width() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back1;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Influence of clipping win",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:20515,Energy Efficiency,green,green,20515,"h->GetBinContent(i + 1);; s->Background(source,nbins,4,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d1->SetBinContent(i + 1,source[i]);; d1->SetLineColor(kRed);; d1->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,6,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d2->SetBinContent(i + 1,source[i]);; d2->SetLineColor(kBlue);; d2->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,8,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,source[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME L"");; }. Example 4 script Background_width2.c:. another example for very complex spectrum is given in Figure 4. Figure 4 Example of the influence of clipping window width on the estimated; background for numberIterations=10 (red line), 20 (blue line), 30 (green line); and 40 (magenta line) using decreasing clipping window algorithm. Script:. // Example to illustrate the influence of the clipping window width on the; // estimated background. To execute this example, do:; // root > .x Background_width2.C; #include ; void Background_width2() {; Int_t i;; Double_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = (Double_t)4096;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back2;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Influence of clipping window width on the estimated background"",; 10,10,1000,700);; h->SetAxisRange(0,",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:23120,Energy Efficiency,green,green,23120,"eColor(kBlue);; d2->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,30,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,source[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME L"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,10,kBackDecreasingWindow,kBackOrder2,kFALSE,; kBackSmoothing3,kFALSE);; for (i = 0; i < nbins; i++) d4->SetBinContent(i + 1,source[i]);; d4->SetLineColor(kMagenta);; d4->Draw(""SAME L"");; }. Example 5 script Background_order.c:. Second order difference filter removes linear (quasi-linear) background and; preserves symmetrical peaks. However if the shape of the background is more; complex one can employ higher-order clipping filters (see example in Figure 5). Figure 5 Example of the influence of clipping filter difference order on the; estimated background for fNnumberIterations=40, 2-nd order red line, 4-th order; blue line, 6-th order green line and 8-th order magenta line, and using; decreasing clipping window algorithm. Script:. // Example to illustrate the influence of the clipping filter difference order; // on the estimated background. To execute this example, do; // root > .x Background_order.C; #include ; void Background_order() {; Int_t i;; Double_t nbins = 4096;; Double_t xmin = 0;; Double_t xmax = (Double_t)4096;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"","""",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""back2;1"");; TCanvas *background = gROOT->GetListOfCanvases()->FindObject(""background"");; if (!background) background = new TCanvas(""background"",; ""Influence of clipping filter difference order on the estimated backgro",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:35704,Energy Efficiency,green,green,35704,"""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""decon1;1"");; TFile *fr = new TFile(""spectra\\TSpectrum.root"");; d=(TH1F*) fr->Get(""decon_response;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",""Decon1"",10,10,1000,700);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,1000,1,1);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; . Examples of Gold deconvolution method:. First let us study the influence of the number of iterations on the; deconvolved spectrum (Figure 12).; . Figure 12 Study of Gold deconvolution algorithm.The original source spectrum; is drawn with black color, spectrum after 100 iterations with red color,; spectrum after 1000 iterations with blue color, spectrum after 10000; iterations with green color and spectrum after 100000 iterations with; magenta color.; ; For relatively narrow peaks in the above given example the Gold; deconvolution method is able to decompose overlapping peaks practically to; delta - functions. In the next example we have chosen a synthetic data; (spectrum, 256 channels) consisting of 5 very closely positioned, relatively; wide peaks (sigma =5), with added noise (Figure 13). Thin lines represent; pure Gaussians (see Table 1); thick line is a resulting spectrum with; additive noise (10% of the amplitude of small peaks).; . Figure 13 Testing example of synthetic spectrum composed of 5 Gaussians with; added noise.; . Peak # Position Height Area . 1 50 500 10159 . 2 70 3000 60957 . 3 80 1000 20319 . 4 100 5000 101596 . 5 110 500 10159 . Table 1 Positions, heights and areas of peaks in the spectrum shown in; Figure 13.; ; In ideal case, we should obtain the result given in Figure 14. The areas",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:55141,Energy Efficiency,green,green,55141,"kTRUE, 3, kTRUE, 3);; Float_t *xpeaks = s->GetPositionX();; for (i = 0; i < nfound; i++) {; a=xpeaks[i];; bin = 1 + Int_t(a + 0.5);; fPositionX[i] = h->GetBinCenter(bin);; fPositionY[i] = h->GetBinContent(bin);; }; TPolyMarker * pm = (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; if (pm) {; h->GetListOfFunctions()->Remove(pm);; delete pm;; }; pm = new TPolyMarker(nfound, fPositionX, fPositionY);; h->GetListOfFunctions()->Add(pm);; pm->SetMarkerStyle(23);; pm->SetMarkerColor(kRed);; pm->SetMarkerSize(1.3);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,dest[i]);; d->SetLineColor(kRed);; d->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; for(i=0;i; ; Example 16 - script SearchHR3.c:; ; ; Peak # Position Sigma ; 1 118 26 ; 2 162 41 ; 3 310 4 ; 4 330 8 ; 5 482 22 ; 6 491 26 ; 7 740 21 ; 8 852 15 ; 9 954 12 ; 10 989 13 ; ; ; Table 4 Positions and sigma of peaks in the following examples.; ; ; ; Fig. 30 Influence of number of iterations (3-red, 10-blue, 100- green,; 1000-magenta), sigma=8, smoothing width=3.; ; ; ; Fig. 31 Influence of sigma (3-red, 8-blue, 20- green, 43-magenta),; num. iter.=10, sm. width=3.; ; ; ; Fig. 32 Influence smoothing width (0-red, 3-blue, 7- green, 20-magenta), num.; iter.=10, sigma=8.; ; Script:; ; // Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR3.C; #include ; void SearchHR3() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""Influence of # of iterations in deconvolution in peak searching"",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xm",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:55246,Energy Efficiency,green,green,55246,"i];; bin = 1 + Int_t(a + 0.5);; fPositionX[i] = h->GetBinCenter(bin);; fPositionY[i] = h->GetBinContent(bin);; }; TPolyMarker * pm = (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; if (pm) {; h->GetListOfFunctions()->Remove(pm);; delete pm;; }; pm = new TPolyMarker(nfound, fPositionX, fPositionY);; h->GetListOfFunctions()->Add(pm);; pm->SetMarkerStyle(23);; pm->SetMarkerColor(kRed);; pm->SetMarkerSize(1.3);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,dest[i]);; d->SetLineColor(kRed);; d->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; for(i=0;i; ; Example 16 - script SearchHR3.c:; ; ; Peak # Position Sigma ; 1 118 26 ; 2 162 41 ; 3 310 4 ; 4 330 8 ; 5 482 22 ; 6 491 26 ; 7 740 21 ; 8 852 15 ; 9 954 12 ; 10 989 13 ; ; ; Table 4 Positions and sigma of peaks in the following examples.; ; ; ; Fig. 30 Influence of number of iterations (3-red, 10-blue, 100- green,; 1000-magenta), sigma=8, smoothing width=3.; ; ; ; Fig. 31 Influence of sigma (3-red, 8-blue, 20- green, 43-magenta),; num. iter.=10, sm. width=3.; ; ; ; Fig. 32 Influence smoothing width (0-red, 3-blue, 7- green, 20-magenta), num.; iter.=10, sigma=8.; ; Script:; ; // Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR3.C; #include ; void SearchHR3() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""Influence of # of iterations in deconvolution in peak searching"",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:55355,Energy Efficiency,green,green,55355,"in);; }; TPolyMarker * pm = (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; if (pm) {; h->GetListOfFunctions()->Remove(pm);; delete pm;; }; pm = new TPolyMarker(nfound, fPositionX, fPositionY);; h->GetListOfFunctions()->Add(pm);; pm->SetMarkerStyle(23);; pm->SetMarkerColor(kRed);; pm->SetMarkerSize(1.3);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,dest[i]);; d->SetLineColor(kRed);; d->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; for(i=0;i; ; Example 16 - script SearchHR3.c:; ; ; Peak # Position Sigma ; 1 118 26 ; 2 162 41 ; 3 310 4 ; 4 330 8 ; 5 482 22 ; 6 491 26 ; 7 740 21 ; 8 852 15 ; 9 954 12 ; 10 989 13 ; ; ; Table 4 Positions and sigma of peaks in the following examples.; ; ; ; Fig. 30 Influence of number of iterations (3-red, 10-blue, 100- green,; 1000-magenta), sigma=8, smoothing width=3.; ; ; ; Fig. 31 Influence of sigma (3-red, 8-blue, 20- green, 43-magenta),; num. iter.=10, sm. width=3.; ; ; ; Fig. 32 Influence smoothing width (0-red, 3-blue, 7- green, 20-magenta), num.; iter.=10, sigma=8.; ; Script:; ; // Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR3.C; #include ; void SearchHR3() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""Influence of # of iterations in deconvolution in peak searching"",nbins,xmin,xmax);; TH1F *d1 = new TH1F(""d1"","""",nbins,xmin,xmax);; TH1F *d2 = new TH1F(""d2"","""",nbins,xmin,xmax);; TH1F *d3 = new TH1F(""d3"","""",nbins,xmin,xmax);; TH1F *d4 = new TH1F(""d4"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""search3;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:58460,Integrability,interface,interface,58460," source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 10, kTRUE, 3);; for (i = 0; i < nbins; i++) d2->SetBinContent(i + 1,dest[i]);; d2->SetLineColor(kBlue);; d2->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 100, kTRUE, 3);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,dest[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 1000, kTRUE, 3);; for (i = 0; i < nbins; i++) d4->SetBinContent(i + 1,dest[i]);; d4->SetLineColor(kMagenta);; d4->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; }; ; ; . Int_t Search1HighRes(float* source, float* destVector, Int_t ssize, float sigma, Double_t threshold, bool backgroundRemove, Int_t deconIterations, bool markov, Int_t averWindow). Old name of SearcHighRes introduced for back compatibility.; This function will be removed after the June 2006 release; ; . Int_t StaticSearch(const TH1* hist, Double_t sigma = 2, Option_t* option = ""goff"", Double_t threshold = 0.05). Static function, interface to TSpectrum::Search.; ; . TH1 * StaticBackground(const TH1* hist, Int_t niter = 20, Option_t* option = """"). Static function, interface to TSpectrum::Background.; ; . TSpectrum(const TSpectrum& ). TSpectrum& operator=(const TSpectrum& ). TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNPeaks() const; {return fNPeaks;}. Float_t * GetPositionX() const; {return fPositionX;}. Float_t * GetPositionY() const; {return fPositionY;}. » Author: Miroslav Morhac 27/05/99 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-30 18:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:58596,Integrability,interface,interface,58596," source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 10, kTRUE, 3);; for (i = 0; i < nbins; i++) d2->SetBinContent(i + 1,dest[i]);; d2->SetLineColor(kBlue);; d2->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 100, kTRUE, 3);; for (i = 0; i < nbins; i++) d3->SetBinContent(i + 1,dest[i]);; d3->SetLineColor(kGreen);; d3->Draw(""SAME"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 1000, kTRUE, 3);; for (i = 0; i < nbins; i++) d4->SetBinContent(i + 1,dest[i]);; d4->SetLineColor(kMagenta);; d4->Draw(""SAME"");; printf(""Found %d candidate peaks\n"",nfound);; }; ; ; . Int_t Search1HighRes(float* source, float* destVector, Int_t ssize, float sigma, Double_t threshold, bool backgroundRemove, Int_t deconIterations, bool markov, Int_t averWindow). Old name of SearcHighRes introduced for back compatibility.; This function will be removed after the June 2006 release; ; . Int_t StaticSearch(const TH1* hist, Double_t sigma = 2, Option_t* option = ""goff"", Double_t threshold = 0.05). Static function, interface to TSpectrum::Search.; ; . TH1 * StaticBackground(const TH1* hist, Int_t niter = 20, Option_t* option = """"). Static function, interface to TSpectrum::Background.; ; . TSpectrum(const TSpectrum& ). TSpectrum& operator=(const TSpectrum& ). TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNPeaks() const; {return fNPeaks;}. Float_t * GetPositionX() const; {return fPositionX;}. Float_t * GetPositionY() const; {return fPositionY;}. » Author: Miroslav Morhac 27/05/99 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-30 18:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:14425,Modifiability,variab,variable,14425,"rmation (peaks) from useless; information (background). method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; algorithm.; new value in the channel ""i"" is calculated. where p = 1, 2, ..., numberIterations. In fact it represents second order; difference filter (-1,2,-1).; One can also change the; direction of the change of the clipping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectru",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:14750,Modifiability,variab,variable,14750,"ping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectrum is shown in black color, estimated background in red color. Script:. // Example to illustrate the background estimator (class TSpectrum).; // To execute this example, do; // root > .x Background_incr.C; #include ; void Background_incr() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:37061,Modifiability,variab,variables,37061," consisting of 5 very closely positioned, relatively; wide peaks (sigma =5), with added noise (Figure 13). Thin lines represent; pure Gaussians (see Table 1); thick line is a resulting spectrum with; additive noise (10% of the amplitude of small peaks).; . Figure 13 Testing example of synthetic spectrum composed of 5 Gaussians with; added noise.; . Peak # Position Height Area . 1 50 500 10159 . 2 70 3000 60957 . 3 80 1000 20319 . 4 100 5000 101596 . 5 110 500 10159 . Table 1 Positions, heights and areas of peaks in the spectrum shown in; Figure 13.; ; In ideal case, we should obtain the result given in Figure 14. The areas of; the Gaussian components of the spectrum are concentrated completely to; delta-functions. When solving the overdetermined system of linear equations; with data from Figure 13 in the sense of minimum least squares criterion; without any regularization we obtain the result with large oscillations; (Figure 15). From mathematical point of view, it is the optimal solution in; the unconstrained space of independent variables. From physical point of; view we are interested only in a meaningful solution. Therefore, we have to; employ regularization techniques (e.g. Gold deconvolution) and/or to; confine the space of allowed solutions to subspace of positive solutions.; . Figure 14 The same spectrum like in Figure 13, outlined bars show the; contents of present components (peaks).; . Figure 15 Least squares solution of the system of linear equations without; regularization.; ; Example 9 - script Deconvolution_wide.c. When we employ Gold deconvolution algorithm we obtain the result given in; Fig. 16. One can observe that the resulting spectrum is smooth. On the; other hand the method is not able to decompose completely the peaks in the; spectrum.; . Figure 16 Example of Gold deconvolution for closely positioned wide peaks.; The original source spectrum is drawn with black color, the spectrum after; the deconvolution (10000 iterations) with red color.; ; ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51006,Modifiability,variab,variable,51006,", Int_t averWindow). One-dimensional high-resolution peak search function. This function searches for peaks in source spectrum. It is based on; deconvolution method. First the background is removed (if desired), then; Markov smoothed spectrum is calculated (if desired), then the response; function is generated according to given sigma and deconvolution is; carried out. The order of peaks is arranged according to their heights in; the spectrum after background elimination. The highest peak is the first in; the list. On success it returns number of found peaks.; ; Function parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close po",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51166,Modifiability,variab,variable,51166," is removed (if desired), then; Markov smoothed spectrum is calculated (if desired), then the response; function is generated according to given sigma and deconvolution is; carried out. The order of peaks is arranged according to their heights in; the spectrum after background elimination. The highest peak is the first in; the list. On success it returns number of found peaks.; ; Function parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mar",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:11643,Performance,perform,performed,11643,"oothing9""; ""BackSmoothing11""; ""BackSmoothing13""; ""BackSmoothing15""; ""Compton"" if selected the estimation of Compton edge; will be included.; ""same"" : if this option is specified, the resulting background; histogram is superimposed on the picture in the current pad.; . NOTE that the background is only evaluated in the current range of h.; ie, if h has a bin range (set via h->GetXaxis()->SetRange(binmin,binmax),; the returned histogram will be created with the same number of bins; as the input histogram h, but only bins from binmin to binmax will be filled; with the estimated background.; ; . void Print(Option_t* option = """") const. Print the array of positions.; ; . Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05). One-dimensional peak search function. This function searches for peaks in source spectrum in hin; The number of found peaks and their positions are written into; the members fNpeaks and fPositionX.; The search is performed in the current histogram range.; ; Function parameters:; ; hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than; threshold*highest_peak are discarded. 0; By default, the background is removed before deconvolution.; Specify the option ""nobackground"" to not remove the background.; ; By default the ""Markov"" chain algorithm is used.; Specify the option ""noMarkov"" to disable this algorithm; Note that by default the source spectrum is replaced by a new spectrum; ; By default a polymarker object is created and added to the list of; functions of the histogram. The histogram is drawn with the specified; option and the polymarker object drawn on top of the histogram.; The polymarker coordinates correspond to the npeaks peaks found in; the histogram.; ; A pointer to the polymarker object can be retrieved later via:; ; TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm = (",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:52860,Performance,tune,tune,52860,"ges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""search2;1"");; for (i = 0; i < nbins; i++) source[i]=h->Ge",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51911,Safety,detect,detect,51911,"th; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - scrip",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:52759,Security,access,access,52759,"dentified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:14417,Testability,log,logical,14417,"rmation (peaks) from useless; information (background). method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; algorithm.; new value in the channel ""i"" is calculated. where p = 1, 2, ..., numberIterations. In fact it represents second order; difference filter (-1,2,-1).; One can also change the; direction of the change of the clipping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectru",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:14742,Testability,log,logical,14742,"ping window, the order of the clipping; filter, to include smoothing, to set width of smoothing window and to include; the estimation of Compton edges. On successful completion it returns 0. On; error it returns pointer to the string describing error.; Parameters:. spectrum: pointer to the vector of source spectrum; ssize: length of the spectrum vector; numberIterations: maximal width of clipping window,; direction: direction of change of clipping window.; Possible values: kBackIncreasingWindow, kBackDecreasingWindow; filterOrder: order of clipping filter.; Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; smoothing: logical variable whether the smoothing operation in the; estimation of background will be included.; Possible values: kFALSE, kTRUE; smoothWindow: width of smoothing window.; Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; compton: logical variable whether the estimation of Compton edge will be; included. Possible values: kFALSE, kTRUE. References:. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132.; D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; spectroscopy. NIM 214 (1983), 431-434. Example 1 script Background_incr.c:. Figure 1 Example of the estimation of background for number of iterations=6.; Original spectrum is shown in black color, estimated background in red color. Script:. // Example to illustrate the background estimator (class TSpectrum).; // To execute this example, do; // root > .x Background_incr.C; #include ; void Background_incr() {; Int_t i;; Double_t nbins = 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = ",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:50998,Testability,log,logical,50998,", Int_t averWindow). One-dimensional high-resolution peak search function. This function searches for peaks in source spectrum. It is based on; deconvolution method. First the background is removed (if desired), then; Markov smoothed spectrum is calculated (if desired), then the response; function is generated according to given sigma and deconvolution is; carried out. The order of peaks is arranged according to their heights in; the spectrum after background elimination. The highest peak is the first in; the list. On success it returns number of found peaks.; ; Function parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close po",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:51158,Testability,log,logical,51158," is removed (if desired), then; Markov smoothed spectrum is calculated (if desired), then the response; function is generated according to given sigma and deconvolution is; carried out. The order of peaks is arranged according to their heights in; the spectrum after background elimination. The highest peak is the first in; the list. On success it returns number of found peaks.; ; Function parameters:. source: pointer to the vector of source spectrum.; destVector: pointer to the vector of resulting deconvolved spectrum.; ssize: length of source spectrum.; sigma: sigma of searched peaks, for details we refer to manual.; threshold: threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual.; backgroundRemove: logical variable, set if the removal of; background before deconvolution is desired.; deconIterations-number of iterations in deconvolution operation.; markov: logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow: averanging window of searched peaks, for details; we refer to manual (applies only for Markov method).; . Peaks searching:. The goal of this function is to identify automatically the peaks in spectrum; with the presence of the continuous background and statistical; fluctuations - noise.; ; The common problems connected with correct peak identification are:; ; non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mar",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum.html:29612,Usability,simpl,simple,29612,",700);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; s->Background(source,nbins,10,kBackDecreasingWindow,kBackOrder8,kTRUE,; kBackSmoothing5,,kTRUE);; for (i = 0; i < nbins; i++) d1->SetBinContent(i + 1,source[i]);; d1->SetLineColor(kRed);; d1->Draw(""SAME L"");; }. . const char* SmoothMarkov(float* source, Int_t ssize, Int_t averWindow). One-dimensional markov spectrum smoothing function. This function calculates smoothed spectrum from source spectrum based on; Markov chain method. The result is placed in the array pointed by source; pointer. On successful completion it returns 0. On error it returns pointer; to the string describing error.; ; Function parameters:; ; source: pointer to the array of source spectrum; ssize: length of source array; averWindow: width of averaging smoothing window; ; The goal of this function is the suppression of the statistical fluctuations.; The algorithm is based on discrete Markov chain, which has very simple; invariant distribution:; . being defined; from the normalization condition; .; n is the length of the smoothed spectrum and; . Reference:; ; Z.K. Silagadze, A new algorithm for automatic photopeak searches.; NIM A 376 (1996), 451.; . Example 14 - script Smoothing.c; . Fig. 23 Original noisy spectrum; . Fig. 24 Smoothed spectrum m=3; . Fig. 25 Smoothed spectrum; . Fig.26 Smoothed spectrum m=10; ; Script:; ; // Example to illustrate smoothing using Markov algorithm (class TSpectrum).; // To execute this example, do; // root > .x Smoothing.C; void Smoothing() {; Int_t i;; Double_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; TH1F *h = new TH1F(""h"",""Smoothed spectrum for m=3"",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""smooth1;1"");; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; TCanvas *Smooth1 = gROOT->GetListOfCanvases()->FindObject(""Smooth1"")",MatchSource.WIKI,root/html528/TSpectrum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum.html
https://root.cern/root/html528/TSpectrum2.html:1617,Availability,avail,available,1617,"L PEAK SEARCH FUNCTIONS; TWO-DIMENSIONAL PEAK SEARCH FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:; [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-; 132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. ftp://root.cern.ch/root/SpectrumDec.ps.gz; ftp://root.cern.ch/root/SpectrumSrc.ps.gz; ftp://root.cern.ch/root/SpectrumBck.ps.gz. NEW FUNCTIONS January 2006. . All figures in this page were prepared using DaqProVis; system, Data Acquisition, Processing and Visualization system, which is being; developed at the Institute of Physics, Slovak Academy of Sciences, Bratislava,; Slovakia: �; http://www.fu.sav.sk/nph/projects/DaqProVis/; under construction; http://www.fu.sav.sk/nph/projects/ProcFunc/; . Function Members (Methods); public:. TSpectrum2(); TSpectrum2(const TSpectrum2&); TSpectrum2(Int_t maxpositions, Float_t resolution = 1); virtual~TSpectrum2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TH1*Background(const TH1* hist, int niter = 20, Option_t* option = """"); const char*Background(float** spectrum, Int_t ssizex, Int_t ssizey, Int_t numberIterationsX, Int_t numberIterationsY, ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:3611,Availability,error,error,3611,"tionsY, Int_t direction, Int_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(float** source, float** resp, Int_t ssizex, Int_t ssizey, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNPeaks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_t*GetPositionX() const; Float_t*GetPositionY() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNa",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:3695,Availability,error,error,3695,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(float** source, float** resp, Int_t ssizex, Int_t ssizey, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNPeaks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_t*GetPositionX() const; Float_t*GetPositionY() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:15069,Availability,error,error,15069,"ethod is based on Sensitive; Nonlinear Iterative Peak (SNIP) clipping algorithm [1]; �        ; there exist two algorithms for the; estimation of new value in the channel ��;  ; Algorithm; based on Successive Comparisons; It; is an extension of one-dimensional SNIP algorithm to another dimension. For; details we refer to [2].;  ; Algorithm; based on One Step Filtering; New; value in the estimated channel is calculated as.  ;  .  ; .;  ; where; p = 1, 2, �, number_of_iterations. ;  ; Function:; const; char*; TSpectrum2::Background; (float; **spectrum, int ssizex, int; ssizey, int numberIterationsX, int; numberIterationsY, int direction, int; filterType)� ;  ; This; function calculates background spectrum from the source spectrum.� The result; is placed in the matrix pointed by spectrum pointer.� One can also switch the; direction of the change of the clipping window and to select one of the two; above given algorithms. On successful completion it returns 0. On error it; returns pointer to the string describing error.;  ; Parameters:; ������� spectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey-lengths; of the spectrum matrix�������������������������������� ; ������� numberIterationsX, numberIterationsYmaximal; widths of clipping; ����� ��window,��������������������������������. ������� direction-; direction of change of clipping window����������������� ; �������������� - possible; values=kBackIncreasingWindow��������������������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� filterType-type; of the clipping algorithm,����������������������������� ; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]�; C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:15120,Availability,error,error,15120,"ethod is based on Sensitive; Nonlinear Iterative Peak (SNIP) clipping algorithm [1]; �        ; there exist two algorithms for the; estimation of new value in the channel ��;  ; Algorithm; based on Successive Comparisons; It; is an extension of one-dimensional SNIP algorithm to another dimension. For; details we refer to [2].;  ; Algorithm; based on One Step Filtering; New; value in the estimated channel is calculated as.  ;  .  ; .;  ; where; p = 1, 2, �, number_of_iterations. ;  ; Function:; const; char*; TSpectrum2::Background; (float; **spectrum, int ssizex, int; ssizey, int numberIterationsX, int; numberIterationsY, int direction, int; filterType)� ;  ; This; function calculates background spectrum from the source spectrum.� The result; is placed in the matrix pointed by spectrum pointer.� One can also switch the; direction of the change of the clipping window and to select one of the two; above given algorithms. On successful completion it returns 0. On error it; returns pointer to the string describing error.;  ; Parameters:; ������� spectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey-lengths; of the spectrum matrix�������������������������������� ; ������� numberIterationsX, numberIterationsYmaximal; widths of clipping; ����� ��window,��������������������������������. ������� direction-; direction of change of clipping window����������������� ; �������������� - possible; values=kBackIncreasingWindow��������������������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� filterType-type; of the clipping algorithm,����������������������������� ; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]�; C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:22983,Availability,error,error,22983,"m; ssizex-x length of source; ssizey-y length of source; averWindow-width of averaging smoothing window. . Smoothing;  ; Goal: Suppression of; statistical fluctuations; �        ; the algorithm is based on discrete; Markov chain, which has very simple invariant distribution;  ; ����������� �����; ������� ��being defined from the normalization condition ;  ; �������� n; is the length of the smoothed spectrum and .  ;  ;  . is the probability of the change of; the peak position from channel i to the channel i+1. �is the normalization constant so; that �and m is a width of smoothing window. We have extended this; algortihm to two dimensions. ;  ; Function:; const char*; TSpectrum2::SmoothMarkov(float; **fSpectrum, int ssizex, int; ssizey, �int averWindow)� ;  ; This; function calculates smoothed spectrum from the source spectrum based on Markov; chain method. The result is placed in the vector pointed by source pointer. On; successful completion it returns 0. On error it returns pointer to the string; describing error.;  ; Parameters:; ������� fSpectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey; -lengths of the spectrum matrix�������������������������������� ; ������� averWindow-width; of averaging smoothing window ;  ; Reference:; [1]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451.� . . Example 4 � script Smooth.c; :. Fig. 9 Original noisy; spectrum.��� Fig. 10 Smoothed spectrum m=3; Peaks can hardly be; observed.� ���Peaks become apparent. Fig. 11 Smoothed spectrum; m=5 Fig.12 Smoothed spectrum m=7;  ; Script:; // Example to illustrate the Markov smoothing (class; TSpectrum).; // To execute this example, do; // root > .x Smooth.C; #include <TSpectrum> ; void Smooth() {; �� Int_t i, j;; �� Double_t nbinsx = 256;; �� Double_t nbinsy = 256;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** so",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:23034,Availability,error,error,23034,"m; ssizex-x length of source; ssizey-y length of source; averWindow-width of averaging smoothing window. . Smoothing;  ; Goal: Suppression of; statistical fluctuations; �        ; the algorithm is based on discrete; Markov chain, which has very simple invariant distribution;  ; ����������� �����; ������� ��being defined from the normalization condition ;  ; �������� n; is the length of the smoothed spectrum and .  ;  ;  . is the probability of the change of; the peak position from channel i to the channel i+1. �is the normalization constant so; that �and m is a width of smoothing window. We have extended this; algortihm to two dimensions. ;  ; Function:; const char*; TSpectrum2::SmoothMarkov(float; **fSpectrum, int ssizex, int; ssizey, �int averWindow)� ;  ; This; function calculates smoothed spectrum from the source spectrum based on Markov; chain method. The result is placed in the vector pointed by source pointer. On; successful completion it returns 0. On error it returns pointer to the string; describing error.;  ; Parameters:; ������� fSpectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey; -lengths of the spectrum matrix�������������������������������� ; ������� averWindow-width; of averaging smoothing window ;  ; Reference:; [1]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451.� . . Example 4 � script Smooth.c; :. Fig. 9 Original noisy; spectrum.��� Fig. 10 Smoothed spectrum m=3; Peaks can hardly be; observed.� ���Peaks become apparent. Fig. 11 Smoothed spectrum; m=5 Fig.12 Smoothed spectrum m=7;  ; Script:; // Example to illustrate the Markov smoothing (class; TSpectrum).; // To execute this example, do; // root > .x Smooth.C; #include <TSpectrum> ; void Smooth() {; �� Int_t i, j;; �� Double_t nbinsx = 256;; �� Double_t nbinsy = 256;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** so",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:27040,Availability,error,error,27040,"verdetermined system of linear equations, i.e.,� the; calculation of the matrix x.; �        ; from numerical stability point of; view the operation of deconvolution is extremely critical (ill-posed� problem); as well as time consuming operation. ; �        ; the Gold deconvolution algorithm; proves to work very well even for 2-dimensional systems. Generalization of the; algorithm for 2-dimensional systems was presented in [1], [2].; �        ; for Gold deconvolution algorithm; as well as for boosted deconvolution algorithm we refer also to TSpectrum ;  ; Function:; const; char* TSpectrum2::Deconvolution(float **source,; const float; **resp, int ssizex,; int ssizey, int numberIterations,; int numberRepetitions,; double boost);  ; This; function calculates deconvolution from source spectrum according to response; spectrum using Gold deconvolution algorithm. The result is placed in the matrix; pointed by source pointer. On successful completion it returns 0. On error it; returns pointer to the string describing error. If desired after every; numberIterations one can apply boosting operation (exponential function with; exponent given by boost coefficient) and repeat it numberRepetitions times.;  ; Parameters:; ������� source-pointer; to the matrix of source spectrum����������������� ; ������� resp-pointer; to the matrix of response spectrum����������������� ; ������� ssizex, ssizey-lengths; of the spectrum matrix�������������������������������� ; ������� numberIterations-number of iterations ; ������� numberRepetitions-number of repetitions; for boosted deconvolution. It must be ; ������� greater or equal to one.; ������� boost-boosting coefficient, applies only; if numberRepetitions is greater than one.� ; ������� Recommended range <1,2>.;  ; References:; �[1]; M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Efficient one- and two-dimensional Gold deconvolution and its application to; gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; [2]; Morh�č ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:27091,Availability,error,error,27091,"verdetermined system of linear equations, i.e.,� the; calculation of the matrix x.; �        ; from numerical stability point of; view the operation of deconvolution is extremely critical (ill-posed� problem); as well as time consuming operation. ; �        ; the Gold deconvolution algorithm; proves to work very well even for 2-dimensional systems. Generalization of the; algorithm for 2-dimensional systems was presented in [1], [2].; �        ; for Gold deconvolution algorithm; as well as for boosted deconvolution algorithm we refer also to TSpectrum ;  ; Function:; const; char* TSpectrum2::Deconvolution(float **source,; const float; **resp, int ssizex,; int ssizey, int numberIterations,; int numberRepetitions,; double boost);  ; This; function calculates deconvolution from source spectrum according to response; spectrum using Gold deconvolution algorithm. The result is placed in the matrix; pointed by source pointer. On successful completion it returns 0. On error it; returns pointer to the string describing error. If desired after every; numberIterations one can apply boosting operation (exponential function with; exponent given by boost coefficient) and repeat it numberRepetitions times.;  ; Parameters:; ������� source-pointer; to the matrix of source spectrum����������������� ; ������� resp-pointer; to the matrix of response spectrum����������������� ; ������� ssizex, ssizey-lengths; of the spectrum matrix�������������������������������� ; ������� numberIterations-number of iterations ; ������� numberRepetitions-number of repetitions; for boosted deconvolution. It must be ; ������� greater or equal to one.; ������� boost-boosting coefficient, applies only; if numberRepetitions is greater than one.� ; ������� Recommended range <1,2>.;  ; References:; �[1]; M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Efficient one- and two-dimensional Gold deconvolution and its application to; gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; [2]; Morh�č ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:16562,Deployability,continuous,continuously,16562,"��������� ; �������������������������������������������; kBackDecreasingWindow��������������������� ; ������� filterType-type; of the clipping algorithm,����������������������������� ; ����������������� -possible values=kBack SuccessiveFiltering; ���������������������������������������������; kBackOneStepFiltering����������������������������� ;  ; References:; [1]�; C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; (1988), 396-402.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:; Background elimination methods for multidimensional gamma-ray spectra. NIM,; A401 (1997) 113-132. . Example 1� script Back_gamma64.c; :. Fig.; 1 Original two-dimensional gamma-gamma-ray spectrum. Fig.; 2 Background estimated from data from Fig. 1 using decreasing clipping window with; widths 4, 4 and algorithm based on successive comparisons. The estimate; includes not only continuously changing background but also one-dimensional; ridges. Fig.; 3 Resulting peaks after subtraction of the estimated background (Fig. 2) from original; two-dimensional gamma-gamma-ray spectrum (Fig. 1).;  ;  ; Script:; // Example to illustrate the background estimator (class; TSpectrum).; // To execute this example, do; // root > .x Back_gamma64.C;  ; #include <TSpectrum> ;  ; void Back_gamma64() {; �� Int_t i, j;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����� source[i]=new float[nbinsy];���� ; �� TH2F *back = new TH2F(""back"",""Background estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""spectra2\\TSpectrum2.root"");; �� back=(TH2F*) f->Get(""back1;1"");; �� TCanvas *Background = new; TCanvas(""Background"",""Estimation of background with increasing; window"",10",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:35725,Deployability,continuous,continuous,35725,"unction is generated; according to given sigma and deconvolution is carried out. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background in both dimensions) and their crossings; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks. ; ability to identify peaks with different sigma.  ; Function:; Int_t TSpectrum2::SearchHighRes (float **source,float **dest, int ssizex, int ssizey, float sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:36056,Deployability,continuous,continuous,36056," peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background in both dimensions) and their crossings; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks. ; ability to identify peaks with different sigma.  ; Function:; Int_t TSpectrum2::SearchHighRes (float **source,float **dest, int ssizex, int ssizey, float sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak i",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:48339,Integrability,interface,interface,48339,"w float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� dest[i]=new; float[nbinsy];; �� TH2F *search = new TH2F(""search"",""High; resolution peak searching"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""spectra2\\TSpectrum2.root"");; �� search=(TH2F*) f->Get(""search3;1"");; �� TCanvas *Searching = new; TCanvas(""Searching"",""High resolution peak; searching"",10,10,1000,700);; �� TSpectrum2 *s = new TSpectrum2();; �� for (i = 0; i < nbinsx; i++){; ���� for (j = 0; j < nbinsy; j++){; �� �������� ����source[i][j] = search->GetBinContent(i +; 1,j + 1); ; �� �������� �}; �� }�� ; �� nfound = s->SearchHighRes(source, dest, nbinsx,; nbinsy, 2, 5, kFALSE, 10, kFALSE, 1);�� ; �� printf(""Found %d candidate peaks\n"",nfound);; �� for(i=0;i<nfound;i++); ����������� �printf(""posx= %d, posy= %d, value=; %d\n"",(int)(fPositionX[i]+0.5), (int)(fPositionY[i]+0.5),; (int)source[(int)(fPositionX[i]+0.5)][(int)(fPositionY[i]+0.5)]);������� ; }. Int_t StaticSearch(const TH1* hist, Double_t sigma = 2, Option_t* option = ""goff"", Double_t threshold = 0.05); static function, interface to TSpectrum2::Search. TH1 * StaticBackground(const TH1* hist, Int_t niter = 20, Option_t* option = """"); static function, interface to TSpectrum2::Background. TSpectrum2(). TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNPeaks() const; {return fNPeaks;}. Float_t * GetPositionX() const; {return fPositionX;}. Float_t * GetPositionY() const; {return fPositionY;}. » Author: Miroslav Morhac 17/01/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:48471,Integrability,interface,interface,48471,"w float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� dest[i]=new; float[nbinsy];; �� TH2F *search = new TH2F(""search"",""High; resolution peak searching"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""spectra2\\TSpectrum2.root"");; �� search=(TH2F*) f->Get(""search3;1"");; �� TCanvas *Searching = new; TCanvas(""Searching"",""High resolution peak; searching"",10,10,1000,700);; �� TSpectrum2 *s = new TSpectrum2();; �� for (i = 0; i < nbinsx; i++){; ���� for (j = 0; j < nbinsy; j++){; �� �������� ����source[i][j] = search->GetBinContent(i +; 1,j + 1); ; �� �������� �}; �� }�� ; �� nfound = s->SearchHighRes(source, dest, nbinsx,; nbinsy, 2, 5, kFALSE, 10, kFALSE, 1);�� ; �� printf(""Found %d candidate peaks\n"",nfound);; �� for(i=0;i<nfound;i++); ����������� �printf(""posx= %d, posy= %d, value=; %d\n"",(int)(fPositionX[i]+0.5), (int)(fPositionY[i]+0.5),; (int)source[(int)(fPositionX[i]+0.5)][(int)(fPositionY[i]+0.5)]);������� ; }. Int_t StaticSearch(const TH1* hist, Double_t sigma = 2, Option_t* option = ""goff"", Double_t threshold = 0.05); static function, interface to TSpectrum2::Search. TH1 * StaticBackground(const TH1* hist, Int_t niter = 20, Option_t* option = """"); static function, interface to TSpectrum2::Background. TSpectrum2(). TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNPeaks() const; {return fNPeaks;}. Float_t * GetPositionX() const; {return fPositionX;}. Float_t * GetPositionY() const; {return fPositionY;}. » Author: Miroslav Morhac 17/01/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:22612,Modifiability,extend,extended,22612,"URF"");� ; �� }. const char* SmoothMarkov(float** source, Int_t ssizex, Int_t ssizey, Int_t averWindow). TWO-DIMENSIONAL MARKOV SPECTRUM SMOOTHING FUNCTION. This function calculates smoothed spectrum from source spectrum; based on Markov chain method.; The result is placed in the array pointed by source pointer. Function parameters:; source-pointer to the array of source spectrum; ssizex-x length of source; ssizey-y length of source; averWindow-width of averaging smoothing window. . Smoothing;  ; Goal: Suppression of; statistical fluctuations; �        ; the algorithm is based on discrete; Markov chain, which has very simple invariant distribution;  ; ����������� �����; ������� ��being defined from the normalization condition ;  ; �������� n; is the length of the smoothed spectrum and .  ;  ;  . is the probability of the change of; the peak position from channel i to the channel i+1. �is the normalization constant so; that �and m is a width of smoothing window. We have extended this; algortihm to two dimensions. ;  ; Function:; const char*; TSpectrum2::SmoothMarkov(float; **fSpectrum, int ssizex, int; ssizey, �int averWindow)� ;  ; This; function calculates smoothed spectrum from the source spectrum based on Markov; chain method. The result is placed in the vector pointed by source pointer. On; successful completion it returns 0. On error it returns pointer to the string; describing error.;  ; Parameters:; ������� fSpectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey; -lengths of the spectrum matrix�������������������������������� ; ������� averWindow-width; of averaging smoothing window ;  ; Reference:; [1]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451.� . . Example 4 � script Smooth.c; :. Fig. 9 Original noisy; spectrum.��� Fig. 10 Smoothed spectrum m=3; Peaks can hardly be; observed.� ���Peaks become apparent. Fig. 11 Smoothed spectrum; m=5 Fig.12 Smoothed spectrum m=7;  ; Script:;",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:35230,Modifiability,variab,variable,35230,"sy; j++); ������ decon->SetBinContent(i + 1,j + 1, source[i][j]);��. �� }; �� decon->Draw(""SURF"");� ; �� };  . Int_t SearchHighRes(float** source, float** dest, Int_t ssizex, Int_t ssizey, Double_t sigma, Double_t threshold, Bool_t backgroundRemove, Int_t deconIterations, Bool_t markov, Int_t averWindow). TWO-DIMENSIONAL HIGH-RESOLUTION PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum; It is based on deconvolution method. First the background is; removed (if desired), then Markov spectrum is calculated; (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:35387,Modifiability,variab,variable,35387,"sy; j++); ������ decon->SetBinContent(i + 1,j + 1, source[i][j]);��. �� }; �� decon->Draw(""SURF"");� ; �� };  . Int_t SearchHighRes(float** source, float** dest, Int_t ssizex, Int_t ssizey, Double_t sigma, Double_t threshold, Bool_t backgroundRemove, Int_t deconIterations, Bool_t markov, Int_t averWindow). TWO-DIMENSIONAL HIGH-RESOLUTION PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum; It is based on deconvolution method. First the background is; removed (if desired), then Markov spectrum is calculated; (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:37625,Modifiability,variab,variable,37625,"at sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.;  ; Parameters:; ������� source-pointer to the matrix of source; spectrum����������������� ; ������� dest-resulting spectrum after deconvolution; ������� ssizex, ssizey-lengths of the source and; destination spectra��������������� ; ������� sigma-sigma of searched peaks; threshold- threshold; value in % for selected peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:37786,Modifiability,variab,variable,37786,"at sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.;  ; Parameters:; ������� source-pointer to the matrix of source; spectrum����������������� ; ������� dest-resulting spectrum after deconvolution; ������� ssizex, ssizey-lengths of the source and; destination spectra��������������� ; ������� sigma-sigma of searched peaks; threshold- threshold; value in % for selected peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:11673,Performance,perform,performed,11673,"; ""BackSmoothing9""; ""BackSmoothing11""; ""BackSmoothing13""; ""BackSmoothing15""; - ""Compton"" if selected the estimation of Compton edge; will be included.; - ""same"" : if this option is specified, the resulting background; histogram is superimposed on the picture in the current pad. NOTE that the background is only evaluated in the current range of h.; ie, if h has a bin range (set via h->GetXaxis()->SetRange(binmin,binmax),; the returned histogram will be created with the same number of bins; as the input histogram h, but only bins from binmin to binmax will be filled; with the estimated background. void Print(Option_t* option = """") const; Print the array of positions. Int_t Search(const TH1* hist, Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05). TWO-DIMENSIONAL PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum in hin; The number of found peaks and their positions are written into; the members fNpeaks and fPositionX.; The search is performed in the current histogram range. Function parameters:; hin: pointer to the histogram of source spectrum; sigma: sigma of searched peaks, for details we refer to manual; threshold: (default=0.05) peaks with amplitude less than; threshold*highest_peak are discarded. 0<threshold<1. By default, the background is removed before deconvolution.; Specify the option ""nobackground"" to not remove the background. //. By default the ""Markov"" chain algorithm is used.; Specify the option ""noMarkov"" to disable this algorithm; Note that by default the source spectrum is replaced by a new spectrum//. By default a polymarker object is created and added to the list of; functions of the histogram. The histogram is drawn with the specified; option and the polymarker object drawn on top of the histogram.; The polymarker coordinates correspond to the npeaks peaks found in; the histogram.; A pointer to the polymarker object can be retrieved later via:; TList *functions = hin->GetListOfFunctions();; TPolyMarker *pm",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:38638,Performance,tune,tune,38638,"le, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� dest[i]=new; float[nbinsy];; �� TH2F *search = new TH2F(""search"",""High; resolution pe",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:36294,Safety,detect,detect,36294,"Iterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background in both dimensions) and their crossings; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks. ; ability to identify peaks with different sigma.  ; Function:; Int_t TSpectrum2::SearchHighRes (float **source,float **dest, int ssizex, int ssizey, float sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.;  ; Parameters:; ������� source-pointer to the matrix of source; spectrum����������������� ; ������� dest-resulting spectrum aft",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:38537,Security,access,access,38537,"ed peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nb",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:35222,Testability,log,logical,35222,"sy; j++); ������ decon->SetBinContent(i + 1,j + 1, source[i][j]);��. �� }; �� decon->Draw(""SURF"");� ; �� };  . Int_t SearchHighRes(float** source, float** dest, Int_t ssizex, Int_t ssizey, Double_t sigma, Double_t threshold, Bool_t backgroundRemove, Int_t deconIterations, Bool_t markov, Int_t averWindow). TWO-DIMENSIONAL HIGH-RESOLUTION PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum; It is based on deconvolution method. First the background is; removed (if desired), then Markov spectrum is calculated; (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:35379,Testability,log,logical,35379,"sy; j++); ������ decon->SetBinContent(i + 1,j + 1, source[i][j]);��. �� }; �� decon->Draw(""SURF"");� ; �� };  . Int_t SearchHighRes(float** source, float** dest, Int_t ssizex, Int_t ssizey, Double_t sigma, Double_t threshold, Bool_t backgroundRemove, Int_t deconIterations, Bool_t markov, Int_t averWindow). TWO-DIMENSIONAL HIGH-RESOLUTION PEAK SEARCH FUNCTION; This function searches for peaks in source spectrum; It is based on deconvolution method. First the background is; removed (if desired), then Markov spectrum is calculated; (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. Function parameters:; source-pointer to the matrix of source spectrum; dest-pointer to the matrix of resulting deconvolved spectrum; ssizex-x length of source spectrum; ssizey-y length of source spectrum; sigma-sigma of searched peaks, for details we refer to manual; threshold-threshold value in % for selected peaks, peaks with; amplitude less than threshold*highest_peak/100; are ignored, see manual; backgroundRemove-logical variable, set if the removal of; background before deconvolution is desired; deconIterations-number of iterations in deconvolution operation; markov-logical variable, if it is true, first the source spectrum; is replaced by new spectrum calculated using Markov; chains method.; averWindow-averanging window of searched peaks, for details; we refer to manual (applies only for Markov method). . Peaks searching;  ; Goal:; to identify automatically the peaks in spectrum with the presence of the; continuous background, one-fold coincidences (ridges) and statistical; fluctuations - noise. ;  ; The common problems connected with correct peak; identification in two-dimensional coincidence spectra are. non-sensitivity to noise, i.e., only statistically; relevant peaks should be identified; non-sensitivity of the algorithm to continuous; background; non-sensitivity to one-fold coincidences (coincidences; peak � background",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:37617,Testability,log,logical,37617,"at sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.;  ; Parameters:; ������� source-pointer to the matrix of source; spectrum����������������� ; ������� dest-resulting spectrum after deconvolution; ������� ssizex, ssizey-lengths of the source and; destination spectra��������������� ; ������� sigma-sigma of searched peaks; threshold- threshold; value in % for selected peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:37778,Testability,log,logical,37778,"at sigma, double threshold,; bool backgroundRemove,int deconIterations,; bool markov,; int averWindow); ��;  ; This; function searches for peaks in source spectrum. It is based on deconvolution; method. First the background is removed (if desired), then Markov smoothed; spectrum is calculated (if desired), then the response function is generated; according to given sigma and deconvolution is carried out. The order of peaks; is arranged according to their heights in the spectrum after background; elimination. The highest peak is the first in the list. On success it returns; number of found peaks.;  ; Parameters:; ������� source-pointer to the matrix of source; spectrum����������������� ; ������� dest-resulting spectrum after deconvolution; ������� ssizex, ssizey-lengths of the source and; destination spectra��������������� ; ������� sigma-sigma of searched peaks; threshold- threshold; value in % for selected peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2.html:22254,Usability,simpl,simple,22254," �� �������� ����source[i][j] = back->GetBinContent(i +; 1,j + 1); ; �� �������� �}; �� }� ���; �s->Background(source,nbinsx,nbinsy,8,8,kBackIncreasingWindow,kBackSuccessiveFiltering);//kBackOneStepFiltering; �� for (i = 0; i < nbinsx; i++){; ���� for (j = 0; j < nbinsy; j++); ������ back->SetBinContent(i + 1,j + 1, source[i][j]);�� ; �� }; �� back->Draw(""SURF"");� ; �� }. const char* SmoothMarkov(float** source, Int_t ssizex, Int_t ssizey, Int_t averWindow). TWO-DIMENSIONAL MARKOV SPECTRUM SMOOTHING FUNCTION. This function calculates smoothed spectrum from source spectrum; based on Markov chain method.; The result is placed in the array pointed by source pointer. Function parameters:; source-pointer to the array of source spectrum; ssizex-x length of source; ssizey-y length of source; averWindow-width of averaging smoothing window. . Smoothing;  ; Goal: Suppression of; statistical fluctuations; �        ; the algorithm is based on discrete; Markov chain, which has very simple invariant distribution;  ; ����������� �����; ������� ��being defined from the normalization condition ;  ; �������� n; is the length of the smoothed spectrum and .  ;  ;  . is the probability of the change of; the peak position from channel i to the channel i+1. �is the normalization constant so; that �and m is a width of smoothing window. We have extended this; algortihm to two dimensions. ;  ; Function:; const char*; TSpectrum2::SmoothMarkov(float; **fSpectrum, int ssizex, int; ssizey, �int averWindow)� ;  ; This; function calculates smoothed spectrum from the source spectrum based on Markov; chain method. The result is placed in the vector pointed by source pointer. On; successful completion it returns 0. On error it returns pointer to the string; describing error.;  ; Parameters:; ������� fSpectrum-pointer; to the matrix of source spectrum����������������� ; ������� ssizex, ssizey; -lengths of the spectrum matrix�������������������������������� ; ������� averWindow-width; of averaging smoo",MatchSource.WIKI,root/html528/TSpectrum2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2.html
https://root.cern/root/html528/TSpectrum2Fit.html:2141,Availability,error,error,2141,"(Int_t numberPeaks); TSpectrum2Fit(const TSpectrum2Fit&); virtual~TSpectrum2Fit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitAwmi(Float_t** source); voidFitStiefel(Float_t** source); voidGetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1); voidGetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1); voidGetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr); Double_tGetChi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:2225,Availability,error,error,2225,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitAwmi(Float_t** source); voidFitStiefel(Float_t** source); voidGetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1); voidGetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1); voidGetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr); Double_tGetChi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:13075,Availability,error,errors,13075,,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:13162,Availability,error,errors,13162,,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:13265,Availability,error,errors,13265,"calculated value of background a0 parameter; Double_tfA0Errerror value of background a0 parameter; Double_tfA0Initinitial value of background a0 parameter(backgroud is estimated as a0+ax*x+ay*y); Double_tfAlphaconvergence coefficient, input parameter, it should be positive number and <=1, for details see references; Int_tfAlphaOptimoptimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; Double_t*fAmpCalc[fNPeaks] array of calculated values of amplitudes of 2D peaks, output parameters; Double_t*fAmpCalcX1[fNPeaks] array of calculated values of amplitudes of 1D ridges in x direction, output parameters; Double_t*fAmpCalcY1[fNPeaks] array of calculated values of amplitudes of 1D ridges in y direction, output parameters; Double_t*fAmpErr[fNPeaks] array of amplitudes errors of 2D peaks, output parameters; Double_t*fAmpErrX1[fNPeaks] array of amplitudes errors of 1D ridges in x direction, output parameters; Double_t*fAmpErrY1[fNPeaks] array of amplitudes errors of 1D ridges in y direction, output parameters; Double_t*fAmpInit[fNPeaks] array of initial values of amplitudes of 2D peaks, input parameters; Double_t*fAmpInitX1[fNPeaks] array of initial values of amplitudes of 1D ridges in x direction, input parameters; Double_t*fAmpInitY1[fNPeaks] array of initial values of amplitudes of 1D ridges in y direction, input parameters; Double_tfAxCalccalculated value of background ax parameter; Double_tfAxErrerror value of background ax parameter; Double_tfAxInitinitial value of background ax parameter(backgroud is estimated as a0+ax*x+ay*y); Double_tfAyCalccalculated value of background ay parameter; Double_tfAyErrerror value of background ay parameter ; Double_tfAyInitinitial value of background ay parameter(backgroud is estimated as a0+ax*x+ay*y); Double_tfBxCalccalculated value of b parameter for 1D ridges in x direction; Double_tfBxErrerror value of b parameter for 1D ridges in x direction; Double_tfBxInitinitial value of b parameter for 1D rid",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:18250,Availability,error,error,18250,"the parameter (not to fit).; Bool_tfFixTxylogical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixTylogical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Int_tfNPeaksnumber of peaks present in fit, input parameter, it should be > 0; TStringTNamed::fNameobject identifier; Int_tfNumberIterationsnumber of iterations in fitting procedure, input parameter, it should be > 0; Double_t*fPositionCalcX[fNPeaks] array of calculated values of x positions of 2D peaks, output parameters; Double_t*fPositionCalcX1[fNPeaks] array of calculated x positions of 1D ridges, output parameters; Double_t*fPositionCalcY[fNPeaks] array of calculated values of y positions of 2D peaks, output parameters; Double_t*fPositionCalcY1[fNPeaks] array of calculated y positions of 1D ridges, output parameters; Double_t*fPositionErrX[fNPeaks] array of error values of x positions of 2D peaks, output parameters; Double_t*fPositionErrX1[fNPeaks] array of x positions errors of 1D ridges, output parameters; Double_t*fPositionErrY[fNPeaks] array of error values of y positions of 2D peaks, output parameters; Double_t*fPositionErrY1[fNPeaks] array of y positions errors of 1D ridges, output parameters; Double_t*fPositionInitX[fNPeaks] array of initial values of x positions of 2D peaks, input parameters; Double_t*fPositionInitX1[fNPeaks] array of initial x positions of 1D ridges, input parameters; Double_t*fPositionInitY[fNPeaks] array of initial values of y positions of 2D peaks, input parameters; Double_t*fPositionInitY1[fNPeaks] array of initial y positions of 1D ridges, input parameters; Int_tfPowerpossible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; Double_tfRoCalccalculated value of correlation coefficient; Double_tfRoErrerror value of correlation coefficient; Double_tfRoInitinitial value of correlation coefficient; Double_tfSigmaCalcXcalculated value ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:18364,Availability,error,errors,18364,"the parameter (not to fit).; Bool_tfFixTxylogical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixTylogical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Int_tfNPeaksnumber of peaks present in fit, input parameter, it should be > 0; TStringTNamed::fNameobject identifier; Int_tfNumberIterationsnumber of iterations in fitting procedure, input parameter, it should be > 0; Double_t*fPositionCalcX[fNPeaks] array of calculated values of x positions of 2D peaks, output parameters; Double_t*fPositionCalcX1[fNPeaks] array of calculated x positions of 1D ridges, output parameters; Double_t*fPositionCalcY[fNPeaks] array of calculated values of y positions of 2D peaks, output parameters; Double_t*fPositionCalcY1[fNPeaks] array of calculated y positions of 1D ridges, output parameters; Double_t*fPositionErrX[fNPeaks] array of error values of x positions of 2D peaks, output parameters; Double_t*fPositionErrX1[fNPeaks] array of x positions errors of 1D ridges, output parameters; Double_t*fPositionErrY[fNPeaks] array of error values of y positions of 2D peaks, output parameters; Double_t*fPositionErrY1[fNPeaks] array of y positions errors of 1D ridges, output parameters; Double_t*fPositionInitX[fNPeaks] array of initial values of x positions of 2D peaks, input parameters; Double_t*fPositionInitX1[fNPeaks] array of initial x positions of 1D ridges, input parameters; Double_t*fPositionInitY[fNPeaks] array of initial values of y positions of 2D peaks, input parameters; Double_t*fPositionInitY1[fNPeaks] array of initial y positions of 1D ridges, input parameters; Int_tfPowerpossible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; Double_tfRoCalccalculated value of correlation coefficient; Double_tfRoErrerror value of correlation coefficient; Double_tfRoInitinitial value of correlation coefficient; Double_tfSigmaCalcXcalculated value ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:18445,Availability,error,error,18445,"the parameter (not to fit).; Bool_tfFixTxylogical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixTylogical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Int_tfNPeaksnumber of peaks present in fit, input parameter, it should be > 0; TStringTNamed::fNameobject identifier; Int_tfNumberIterationsnumber of iterations in fitting procedure, input parameter, it should be > 0; Double_t*fPositionCalcX[fNPeaks] array of calculated values of x positions of 2D peaks, output parameters; Double_t*fPositionCalcX1[fNPeaks] array of calculated x positions of 1D ridges, output parameters; Double_t*fPositionCalcY[fNPeaks] array of calculated values of y positions of 2D peaks, output parameters; Double_t*fPositionCalcY1[fNPeaks] array of calculated y positions of 1D ridges, output parameters; Double_t*fPositionErrX[fNPeaks] array of error values of x positions of 2D peaks, output parameters; Double_t*fPositionErrX1[fNPeaks] array of x positions errors of 1D ridges, output parameters; Double_t*fPositionErrY[fNPeaks] array of error values of y positions of 2D peaks, output parameters; Double_t*fPositionErrY1[fNPeaks] array of y positions errors of 1D ridges, output parameters; Double_t*fPositionInitX[fNPeaks] array of initial values of x positions of 2D peaks, input parameters; Double_t*fPositionInitX1[fNPeaks] array of initial x positions of 1D ridges, input parameters; Double_t*fPositionInitY[fNPeaks] array of initial values of y positions of 2D peaks, input parameters; Double_t*fPositionInitY1[fNPeaks] array of initial y positions of 1D ridges, input parameters; Int_tfPowerpossible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; Double_tfRoCalccalculated value of correlation coefficient; Double_tfRoErrerror value of correlation coefficient; Double_tfRoInitinitial value of correlation coefficient; Double_tfSigmaCalcXcalculated value ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:18559,Availability,error,errors,18559,"the parameter (not to fit).; Bool_tfFixTxylogical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixTylogical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Int_tfNPeaksnumber of peaks present in fit, input parameter, it should be > 0; TStringTNamed::fNameobject identifier; Int_tfNumberIterationsnumber of iterations in fitting procedure, input parameter, it should be > 0; Double_t*fPositionCalcX[fNPeaks] array of calculated values of x positions of 2D peaks, output parameters; Double_t*fPositionCalcX1[fNPeaks] array of calculated x positions of 1D ridges, output parameters; Double_t*fPositionCalcY[fNPeaks] array of calculated values of y positions of 2D peaks, output parameters; Double_t*fPositionCalcY1[fNPeaks] array of calculated y positions of 1D ridges, output parameters; Double_t*fPositionErrX[fNPeaks] array of error values of x positions of 2D peaks, output parameters; Double_t*fPositionErrX1[fNPeaks] array of x positions errors of 1D ridges, output parameters; Double_t*fPositionErrY[fNPeaks] array of error values of y positions of 2D peaks, output parameters; Double_t*fPositionErrY1[fNPeaks] array of y positions errors of 1D ridges, output parameters; Double_t*fPositionInitX[fNPeaks] array of initial values of x positions of 2D peaks, input parameters; Double_t*fPositionInitX1[fNPeaks] array of initial x positions of 1D ridges, input parameters; Double_t*fPositionInitY[fNPeaks] array of initial values of y positions of 2D peaks, input parameters; Double_t*fPositionInitY1[fNPeaks] array of initial y positions of 1D ridges, input parameters; Int_tfPowerpossible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; Double_tfRoCalccalculated value of correlation coefficient; Double_tfRoErrerror value of correlation coefficient; Double_tfRoInitinitial value of correlation coefficient; Double_tfSigmaCalcXcalculated value ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:21721,Availability,error,errors,21721,"ction; Double_tfSxErrerror value of s parameter for 1D ridges in x direction; Double_tfSxInitinitial value of s parameter for 1D ridges in x direction (relative amplitude of step), for details see html manual and references; Double_tfSxyCalccalculated value of s parameter for 2D peaks; Double_tfSxyErrerror value of s parameter for 2D peaks; Double_tfSxyInitinitial value of s parameter for 2D peaks (relative amplitude of step), for details see html manual and references; Double_tfSyCalccalculated value of s parameter for 1D ridges in y direction; Double_tfSyErrerror value of s parameter for 1D ridges in y direction; Double_tfSyInitinitial value of s parameter for 1D ridges in y direction (relative amplitude of step), for details see html manual and references; TStringTNamed::fTitleobject title; Double_tfTxCalccalculated value of t parameter for 1D ridges in x direction; Double_tfTxErrerror value of t parameter for 1D ridges in x direction; Double_tfTxInitinitial value of t parameter for 1D ridges in x direction (relative amplitude of tail), for details see html manual and references; Double_tfTxyCalccalculated value of t parameter for 2D peaks; Double_tfTxyErrerror value of t parameter for 2D peaks; Double_tfTxyInitinitial value of t parameter for 2D peaks (relative amplitude of tail), for details see html manual and references; Double_tfTyCalccalculated value of t parameter for 1D ridges in y direction; Double_tfTyErrerror value of t parameter for 1D ridges in y direction; Double_tfTyInitinitial value of t parameter for 1D ridges in y direction (relative amplitude of tail), for details see html manual and references; Double_t*fVolume[fNPeaks] array of calculated volumes of 2D peaks, output parameters; Double_t*fVolumeErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction.",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22693,Availability,error,error,22693,"eErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number of rows of the matrix. Double_t Shape2(Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t* parameter, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t a0, Double_t ax, Double_t ay, Double_t txy, Double_t sxy, Double_t tx, Double_t ty, Double_t sx, Double_t sy, Double_t bx, Double_t by). AUXILIARY FUNCTION.",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22801,Availability,error,error,22801,"n x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number of rows of the matrix. Double_t Shape2(Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t* parameter, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t a0, Double_t ax, Double_t ay, Double_t txy, Double_t sxy, Double_t tx, Double_t ty, Double_t sx, Double_t sy, Double_t bx, Double_t by). AUXILIARY FUNCTION. This function calculates 2D peaks shape function (see manual); Function parameters:; -numOfFittedPea",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:39895,Availability,error,error,39895,,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:40285,Availability,error,error,40285,,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:40669,Availability,error,errors,40669,"aks, input parameters; �� Double_t; *fPositionCalcX;���������������� //[fNPeaks] array of calculated values of x; positions of 2D peaks, output parameters; �� Double_t; *fPositionErrX;����������������� //[fNPeaks] array of error values of x; positions of 2D peaks, output parameters; �� Double_t; *fPositionInitY;���������������� //[fNPeaks] array of initial values of y; positions of 2D peaks, input parameters; �� Double_t; *fPositionCalcY;���������������� //[fNPeaks] array of calculated values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionErrY;����������������� //[fNPeaks] array of error values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionInitX1;��������������� //[fNPeaks] array of initial x positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcX1;��������������� //[fNPeaks] array of calculated x positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrX1;���������������� //[fNPeaks] array of x positions errors of 1D; ridges, output parameters; �� Double_t; *fPositionInitY1;��������������� //[fNPeaks] array of initial y positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcY1;��������������� //[fNPeaks] array of calculated y positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrY1;���������������� //[fNPeaks] array of y positions errors of 1D; ridges, output parameters; �� Double_t; *fAmpInit;���������������������� //[fNPeaks] array of initial values of; amplitudes of 2D peaks, input parameters; �� Double_t; *fAmpCalc;���������������������� //[fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:41033,Availability,error,errors,41033,"s of y; positions of 2D peaks, input parameters; �� Double_t; *fPositionCalcY;���������������� //[fNPeaks] array of calculated values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionErrY;����������������� //[fNPeaks] array of error values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionInitX1;��������������� //[fNPeaks] array of initial x positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcX1;��������������� //[fNPeaks] array of calculated x positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrX1;���������������� //[fNPeaks] array of x positions errors of 1D; ridges, output parameters; �� Double_t; *fPositionInitY1;��������������� //[fNPeaks] array of initial y positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcY1;��������������� //[fNPeaks] array of calculated y positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrY1;���������������� //[fNPeaks] array of y positions errors of 1D; ridges, output parameters; �� Double_t; *fAmpInit;���������������������� //[fNPeaks] array of initial values of; amplitudes of 2D peaks, input parameters; �� Double_t; *fAmpCalc;���������������������� //[fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in x direction, output parameters; �� Double_t; *fAmpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *f",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:41412,Availability,error,errors,41412,"itial x positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcX1;��������������� //[fNPeaks] array of calculated x positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrX1;���������������� //[fNPeaks] array of x positions errors of 1D; ridges, output parameters; �� Double_t; *fPositionInitY1;��������������� //[fNPeaks] array of initial y positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcY1;��������������� //[fNPeaks] array of calculated y positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrY1;���������������� //[fNPeaks] array of y positions errors of 1D; ridges, output parameters; �� Double_t; *fAmpInit;���������������������� //[fNPeaks] array of initial values of; amplitudes of 2D peaks, input parameters; �� Double_t; *fAmpCalc;���������������������� //[fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in x direction, output parameters; �� Double_t; *fAmpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output param",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:41822,Availability,error,errors,41822,"ers; �� Double_t; *fPositionCalcY1;��������������� //[fNPeaks] array of calculated y positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrY1;���������������� //[fNPeaks] array of y positions errors of 1D; ridges, output parameters; �� Double_t; *fAmpInit;���������������������� //[fNPeaks] array of initial values of; amplitudes of 2D peaks, input parameters; �� Double_t; *fAmpCalc;���������������������� //[fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in x direction, output parameters; �� Double_t; *fAmpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;���������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:42248,Availability,error,errors,42248,"fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in x direction, output parameters; �� Double_t; *fAmpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;����",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:42498,Availability,error,errors,42498,"fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in x direction, output parameters; �� Double_t; *fAmpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:42757,Availability,error,error,42757,"mpErrX1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in x direction, output parameters; �� Double_t; *fAmpInitY1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in y direction, input parameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relat",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:43010,Availability,error,error,43010,"ameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; ��",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:43275,Availability,error,error,43275,"ction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; �� Double_t�; fTxInit;����������������������� //initial value of t parameter for 1D ridges in; x direction (relative amplitude of tail), for details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:43622,Availability,error,error,43622,"Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; �� Double_t�; fTxInit;����������������������� //initial value of t parameter for 1D ridges in; x direction (relative amplitude of tail), for details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1D ridges; in x direction; �� Double_t�; fTxErr;���������������� ��������//error value of t parameter for 1D ridges in x; direction; �� Double_t�; fTyInit;����������������������� //initial value of t parameter for 1D ridges in; y direction (relative amplitude of tail), for details see html manual and; references; �� Double_t �fTyCalc;������������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:43970,Availability,error,error,43970,"�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; �� Double_t�; fTxInit;����������������������� //initial value of t parameter for 1D ridges in; x direction (relative amplitude of tail), for details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1D ridges; in x direction; �� Double_t�; fTxErr;���������������� ��������//error value of t parameter for 1D ridges in x; direction; �� Double_t�; fTyInit;����������������������� //initial value of t parameter for 1D ridges in; y direction (relative amplitude of tail), for details see html manual and; references; �� Double_t �fTyCalc;�����������������������; calculated value of t parameter for 1D ridges in y direction; �� Double_t�; fTyErr;������������������������ //error value of t parameter for 1D ridges in y; direction; �� Double_t�; fSxInit;����������������������� //initial value of s parameter for 1D ridges in; x direction (relative amplitude of step), for details see html manual an",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:44352,Availability,error,error,44352,"����� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; �� Double_t�; fTxInit;����������������������� //initial value of t parameter for 1D ridges in; x direction (relative amplitude of tail), for details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1D ridges; in x direction; �� Double_t�; fTxErr;���������������� ��������//error value of t parameter for 1D ridges in x; direction; �� Double_t�; fTyInit;����������������������� //initial value of t parameter for 1D ridges in; y direction (relative amplitude of tail), for details see html manual and; references; �� Double_t �fTyCalc;�����������������������; calculated value of t parameter for 1D ridges in y direction; �� Double_t�; fTyErr;������������������������ //error value of t parameter for 1D ridges in y; direction; �� Double_t�; fSxInit;����������������������� //initial value of s parameter for 1D ridges in; x direction (relative amplitude of step), for details see html manual and; references; �� Double_t�; fSxCalc;����������������������� //calculated value of s parameter for 1D ridges; in x direction; �� Double_t� fSxErr;������ ������������������//error; value of s parameter for 1D ridges in x direction; �� Double_t�; fSyInit;����������������������� //initial value of s parameter for 1D ridges in; y direction (relative amplitude of step), for details se",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:44748,Availability,error,error,44748,"s; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; �� Double_t�; fTxInit;����������������������� //initial value of t parameter for 1D ridges in; x direction (relative amplitude of tail), for details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1D ridges; in x direction; �� Double_t�; fTxErr;���������������� ��������//error value of t parameter for 1D ridges in x; direction; �� Double_t�; fTyInit;����������������������� //initial value of t parameter for 1D ridges in; y direction (relative amplitude of tail), for details see html manual and; references; �� Double_t �fTyCalc;�����������������������; calculated value of t parameter for 1D ridges in y direction; �� Double_t�; fTyErr;������������������������ //error value of t parameter for 1D ridges in y; direction; �� Double_t�; fSxInit;����������������������� //initial value of s parameter for 1D ridges in; x direction (relative amplitude of step), for details see html manual and; references; �� Double_t�; fSxCalc;����������������������� //calculated value of s parameter for 1D ridges; in x direction; �� Double_t� fSxErr;������ ������������������//error; value of s parameter for 1D ridges in x direction; �� Double_t�; fSyInit;����������������������� //initial value of s parameter for 1D ridges in; y direction (relative amplitude of step), for details see html manual and; references; � �Double_t�; fSyCalc;����������������������� //calculated value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:45146,Availability,error,error,45146,"or details see html manual and; references; �� Double_t�; fTxCalc;����������������������� //calculated value of t parameter for 1D ridges; in x direction; �� Double_t�; fTxErr;���������������� ��������//error value of t parameter for 1D ridges in x; direction; �� Double_t�; fTyInit;����������������������� //initial value of t parameter for 1D ridges in; y direction (relative amplitude of tail), for details see html manual and; references; �� Double_t �fTyCalc;�����������������������; calculated value of t parameter for 1D ridges in y direction; �� Double_t�; fTyErr;������������������������ //error value of t parameter for 1D ridges in y; direction; �� Double_t�; fSxInit;����������������������� //initial value of s parameter for 1D ridges in; x direction (relative amplitude of step), for details see html manual and; references; �� Double_t�; fSxCalc;����������������������� //calculated value of s parameter for 1D ridges; in x direction; �� Double_t� fSxErr;������ ������������������//error; value of s parameter for 1D ridges in x direction; �� Double_t�; fSyInit;����������������������� //initial value of s parameter for 1D ridges in; y direction (relative amplitude of step), for details see html manual and; references; � �Double_t�; fSyCalc;����������������������� //calculated value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:45545,Availability,error,error,45545,"or details see html manual and; references; �� Double_t �fTyCalc;�����������������������; calculated value of t parameter for 1D ridges in y direction; �� Double_t�; fTyErr;������������������������ //error value of t parameter for 1D ridges in y; direction; �� Double_t�; fSxInit;����������������������� //initial value of s parameter for 1D ridges in; x direction (relative amplitude of step), for details see html manual and; references; �� Double_t�; fSxCalc;����������������������� //calculated value of s parameter for 1D ridges; in x direction; �� Double_t� fSxErr;������ ������������������//error; value of s parameter for 1D ridges in x direction; �� Double_t�; fSyInit;����������������������� //initial value of s parameter for 1D ridges in; y direction (relative amplitude of step), for details see html manual and; references; � �Double_t�; fSyCalc;����������������������� //calculated value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated v",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:45922,Availability,error,error,45922,"plitude of step), for details see html manual and; references; �� Double_t�; fSxCalc;����������������������� //calculated value of s parameter for 1D ridges; in x direction; �� Double_t� fSxErr;������ ������������������//error; value of s parameter for 1D ridges in x direction; �� Double_t�; fSyInit;����������������������� //initial value of s parameter for 1D ridges in; y direction (relative amplitude of step), for details see html manual and; references; � �Double_t�; fSyCalc;����������������������� //calculated value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;�����������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:46299,Availability,error,error,46299,"irection (relative amplitude of step), for details see html manual and; references; � �Double_t�; fSyCalc;����������������������� //calculated value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:46629,Availability,error,error,46629,"ted value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:46941,Availability,error,error,46941,"ted value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:47251,Availability,error,error,47251,"ted value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:68724,Availability,error,errors,68724,"not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positionErrorsX, Float_t* positionErrorsY, Float_t* positionErrorsX1, Float_t* positionErrorsY1). GETTER FUNCTION. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volume",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:68812,Availability,error,errors,68812,"not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positionErrorsX, Float_t* positionErrorsY, Float_t* positionErrorsX1, Float_t* positionErrorsY1). GETTER FUNCTION. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volume",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:68881,Availability,error,errors,68881,"not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positionErrorsX, Float_t* positionErrorsY, Float_t* positionErrorsX1, Float_t* positionErrorsY1). GETTER FUNCTION. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volume",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:68951,Availability,error,errors,68951,"not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positionErrorsX, Float_t* positionErrorsY, Float_t* positionErrorsX1, Float_t* positionErrorsY1). GETTER FUNCTION. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volume",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:69022,Availability,error,errors,69022,"not to fit); -sInitX - initial value of sx parameter; -fixSx - logical value of sx parameter, which allows to fix the parameter (not to fit); -sInitY - initial value of sy parameter; -fixSy - logical value of sy parameter, which allows to fix the parameter (not to fit). void GetPositions(Float_t* positionsX, Float_t* positionsY, Float_t* positionsX1, Float_t* positionsY1). GETTER FUNCTION. This function gets the positions of fitted 2D peaks and 1D ridges; -positionX - gets vector of x positions of 2D peaks; -positionY - gets vector of y positions of 2D peaks; -positionX1 - gets vector of x positions of 1D ridges; -positionY1 - gets vector of y positions of 1D ridges. void GetPositionErrors(Float_t* positionErrorsX, Float_t* positionErrorsY, Float_t* positionErrorsX1, Float_t* positionErrorsY1). GETTER FUNCTION. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volume",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:69662,Availability,error,errors,69662,"ON. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:69729,Availability,error,errors,69729,"ON. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:69812,Availability,error,errors,69812,"ON. This function gets the errors of positions of fitted 2D peaks and 1D ridges; -positionErrorsX - gets vector of errors of x positions of 2D peaks; -positionErrorsY - gets vector of errors of y positions of 2D peaks; -positionErrorsX1 - gets vector of errors of x positions of 1D ridges; -positionErrorsY1 - gets vector of errors of y positions of 1D ridges. void GetAmplitudes(Float_t* amplitudes, Float_t* amplitudesX1, Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70079,Availability,error,errors,70079,", Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error valu",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70160,Availability,error,errors,70160,", Float_t* amplitudesY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudes - gets vector of amplitudes of 2D peaks; -amplitudesX1 - gets vector of amplitudes of 1D ridges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error valu",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70301,Availability,error,error,70301,"idges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70380,Availability,error,error,70380,"idges in x direction; -amplitudesY1 - gets vector of amplitudes of 1D ridges in y direction. void GetAmplitudeErrors(Float_t* amplitudeErrors, Float_t* amplitudeErrorsX1, Float_t* amplitudeErrorsY1). GETTER FUNCTION. This function gets the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70535,Availability,error,error,70535,"s the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70614,Availability,error,error,70614,"s the amplitudes of fitted 2D peaks and 1D ridges; -amplitudeErrors - gets vector of amplitudes errors of 2D peaks; -amplitudeErrorsX1 - gets vector of amplitudes errors of 1D ridges in x direction; -amplitudesErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70752,Availability,error,error,70752,"ErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:70818,Availability,error,error,70818,"ErrorY1 - gets vector of amplitudes errors of 1D ridges in y direction. void GetVolumes(Float_t* volumes). GETTER FUNCTION. This function gets the volumes of fitted 2D peaks; -volumes - gets vector of volumes of 2D peaks. void GetVolumeErrors(Float_t* volumeErrors). GETTER FUNCTION. This function gets errors of the volumes of fitted 2D peaks; -volumeErrors - gets vector of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71042,Availability,error,errors,71042,"of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71109,Availability,error,error,71109,"of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71197,Availability,error,error,71197,"of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71285,Availability,error,error,71285,"of volumes errors of 2D peaks. void GetSigmaX(Double_t& sigmaX, Double_t& sigmaErrX). GETTER FUNCTION. This function gets the sigma x parameter and its error; -sigmaX - gets the fitted value of sigma x parameter; -sigmaErrX - gets error value of sigma x parameter. void GetSigmaY(Double_t& sigmaY, Double_t& sigmaErrY). GETTER FUNCTION. This function gets the sigma y parameter and its error; -sigmaY - gets the fitted value of sigma y parameter; -sigmaErrY - gets error value of sigma y parameter. void GetRo(Double_t& ro, Double_t& roErr). GETTER FUNCTION. This function gets the ro parameter and its error; -ro - gets the fitted value of ro parameter; -roErr - gets error value of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parame",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71656,Availability,error,errors,71656,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71726,Availability,error,error,71726,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71815,Availability,error,error,71815,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71903,Availability,error,error,71903,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:71991,Availability,error,error,71991,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:72079,Availability,error,error,72079,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:72170,Availability,error,error,72170,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:72259,Availability,error,error,72259,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:72347,Availability,error,error,72347,"lue of ro parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& ax, Double_t& axErr, Double_t& ay, Double_t& ayErr). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -ax - gets the fitted value of ax parameter; -axErr - gets error value of ax parameter; -ay - gets the fitted value of ay parameter; -ayErr - gets error value of ay parameter. void GetTailParameters(Double_t& txy, Double_t& txyErr, Double_t& tx, Double_t& txErr, Double_t& ty, Double_t& tyErr, Double_t& bx, Double_t& bxErr, Double_t& by, Double_t& byErr, Double_t& sxy, Double_t& sxyErr, Double_t& sx, Double_t& sxErr, Double_t& sy, Double_t& syErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -txy - gets the fitted value of txy parameter; -txyErr - gets error value of txy parameter; -tx - gets the fitted value of tx parameter; -txErr - gets error value of tx parameter; -ty - gets the fitted value of ty parameter; -tyErr - gets error value of ty parameter; -bx - gets the fitted value of bx parameter; -bxErr - gets error value of bx parameter; -by - gets the fitted value of by parameter; -byErr - gets error value of by parameter; -sxy - gets the fitted value of sxy parameter; -sxyErr - gets error value of sxy parameter; -sx - gets the fitted value of sx parameter; -sxErr - gets error value of sx parameter; -sy - gets the fitted value of sy parameter; -syErr - gets error value of sy parameter. TSpectrum2Fit(const TSpectrum2Fit& ). Double_t GetChi() const; {return fChi;}. » Author: Miroslav Morhac 25/09/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/spectrum:$Id: TSpectrum2Fit.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:6201,Energy Efficiency,power,power,6201,"tor new[](size_t sz, void* vp); TSpectrum2Fit&operator=(const TSpectrum2Fit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1); voidSetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy); virtual voidTNamed::SetTitle(c",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22190,Energy Efficiency,allocate,allocates,22190,"parameter for 2D peaks (relative amplitude of tail), for details see html manual and references; Double_tfTyCalccalculated value of t parameter for 1D ridges in y direction; Double_tfTyErrerror value of t parameter for 1D ridges in y direction; Double_tfTyInitinitial value of t parameter for 1D ridges in y direction (relative amplitude of tail), for details see html manual and references; Double_t*fVolume[fNPeaks] array of calculated volumes of 2D peaks, output parameters; Double_t*fVolumeErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22862,Energy Efficiency,power,power,22862,"on; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number of rows of the matrix. Double_t Shape2(Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t* parameter, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t a0, Double_t ax, Double_t ay, Double_t txy, Double_t sxy, Double_t tx, Double_t ty, Double_t sx, Double_t sy, Double_t bx, Double_t by). AUXILIARY FUNCTION. This function calculates 2D peaks shape function (see manual); Function parameters:; -numOfFittedPeaks-number of fitted peaks; -x-channel in x-dimension; -y-c",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:63042,Energy Efficiency,power,power,63042,"aks; amplitudes, input parameters��������� ; ����� AmpXY[i] = 0;; �� }; �� //filling in the initial; estimates of the input parameters; �� TSpectrumFit2 *pfit=new; TSpectrumFit2(nfound);; ��; pfit->SetFitParameters(xmin, xmax-1, ymin, ymax-1, 1000, 0.1,; pfit->kFitOptimChiCounts, pfit->kFitAlphaHalving, pfit->kFitPower2,; pfit->kFitTaylorOrderFirst);�� ; ��; pfit->SetPeakParameters(2, kFALSE, 2, kFALSE, 0, kTRUE, PosX, (Bool_t *); FixPosX, PosY, (Bool_t *) FixPosY, PosX, (Bool_t *) FixPosX, PosY, (Bool_t *); FixPosY, Amp, (Bool_t *) FixAmp, AmpXY, (Bool_t *) FixAmp, AmpXY, (Bool_t *); FixAmp);����� ; ��; pfit->SetBackgroundParameters(0, kFALSE, 0, kTRUE, 0, kTRUE);�� ; ��; pfit->FitStiefel(source);; ��� for (i = 0; i <; nbinsx; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��search->SetBinContent(i; + 1, j + 1,source[i][j]);; �� ������������ �}; �� }�� ; ��; search->Draw(""SURF"");; }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax, ymin, ymax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParam",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:63695,Energy Efficiency,power,power,63695,"(Bool_t *) FixPosY, PosX, (Bool_t *) FixPosX, PosY, (Bool_t *); FixPosY, Amp, (Bool_t *) FixAmp, AmpXY, (Bool_t *) FixAmp, AmpXY, (Bool_t *); FixAmp);����� ; ��; pfit->SetBackgroundParameters(0, kFALSE, 0, kTRUE, 0, kTRUE);�� ; ��; pfit->FitStiefel(source);; ��� for (i = 0; i <; nbinsx; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��search->SetBinContent(i; + 1, j + 1,source[i][j]);; �� ������������ �}; �� }�� ; ��; search->Draw(""SURF"");; }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax, ymin, ymax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* a",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22287,Modifiability,variab,variables,22287,"parameter for 2D peaks (relative amplitude of tail), for details see html manual and references; Double_tfTyCalccalculated value of t parameter for 1D ridges in y direction; Double_tfTyErrerror value of t parameter for 1D ridges in y direction; Double_tfTyInitinitial value of t parameter for 1D ridges in y direction (relative amplitude of tail), for details see html manual and references; Double_t*fVolume[fNPeaks] array of calculated volumes of 2D peaks, output parameters; Double_t*fVolumeErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:22343,Modifiability,variab,variables,22343,"ection; Double_tfTyErrerror value of t parameter for 1D ridges in y direction; Double_tfTyInitinitial value of t parameter for 1D ridges in y direction (relative amplitude of tail), for details see html manual and references; Double_t*fVolume[fNPeaks] array of calculated volumes of 2D peaks, output parameters; Double_t*fVolumeErr[fNPeaks] array of volumes errors of 2D peaks, output parameters; Int_tfXmaxlast fitted channel in x direction; Int_tfXminfirst fitted channel in x direction; Int_tfYmaxlast fitted channel in y direction; Int_tfYminfirst fitted channel in y direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpectrum2Fit(); default constructor. TSpectrum2Fit(Int_t numberPeaks); numberPeaks: number of fitted peaks (must be greater than zero); the constructor allocates arrays for all fitted parameters (peak positions, amplitudes etc) and sets the member; variables to their default values. One can change these variables by member functions (setters) of TSpectrumFit class. . Shape function of the fitted; peaks contains the two-dimensional symmetrical Gaussian two one-dimensional; symmetrical Gaussian ridges as well as nonsymmetrical terms and background. ~TSpectrum2Fit(); destructor. Double_t Erfc(Double_t x). AUXILIARY FUNCTION. This function calculates error function of x. Double_t Derfc(Double_t x). AUXILIARY FUNCTION. This function calculates derivative of error function of x. Double_t Ourpowl(Double_t a, Int_t pw); power function. void StiefelInversion(Double_t** a, Int_t size). AUXILIARY FUNCTION. This function calculates solution of the system of linear equations.; The matrix a should have a dimension size*(size+4); The calling function should fill in the matrix, the column size should; contain vector y (right side of the system of equations). The result is; placed into size+1 column of the matrix.; according to sigma of peaks.; Function parameters:; -a-matrix with dimension size*(size+4) //; -size-number",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:37915,Modifiability,variab,variables,37915,"eters [2],; [5]. ;  ;  ; Function:; void TSpectrumFit2::FitAwmi(float **fSource); �; This function fits the source; spectrum using AWMI algorithm. The calling program should fill in input; parameters of the TSpectrumFit2 class using a set of TSpectrumFit2 setters. The; fitted parameters are written into the class and fitted data are written into; source spectrum. ;  ;  ; Parameter:; ������� fSource-pointer to; the matrix of source spectrum����������������� ;  ;  ; Member variables; of� TSpectrumFit2 class:; �� Int_t����; fNPeaks;����������������������� //number of peaks present in fit, input; parameter, it should be > 0; �� Int_t����; fNumberIterations;������������� //number of iterations in fitting procedure,; input parameter, it should be > 0; �� Int_t����; fXmin;������������������������� //first fitted channel in x direction; �� Int_t����; fXmax;�������������������� �����//last fitted channel in x direction; �� Int_t����; fYmin;������������������������� //first fitted channel in y direction; �� Int_t����; fYmax;������������������������� //last fitted channel in y direction; �� Int_t����; fStatisticType;���������������� //type of statistics, possible values; kFitOptimChiCounts (chi square statistics with counts as weighting; coefficients), kFitOptimChiFuncValues (chi square statistics with function; values as weighting coefficients),kFitOptimMaxLikelihood; �� Int_t���� fAlphaOptim;�������������������; optimization of convergence algorithm, possible values kFitAlphaHalving,; kFitAlphaOptimal; �� Int_t����; fPower;������������������������ //possible values kFitPower2,4,6,8,10,12, for; details see references. It applies only for Awmi fitting function.; �� Int_t����; fFitTaylor;�������������������� //order of Taylor expansion, possible values; kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting; function.; �� Double_t�; fAlpha;������������������������ //convergence coefficient, input parameter, it; should be positive number and <=1, for detai",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:38866,Performance,optimiz,optimization,38866,"eters [2],; [5]. ;  ;  ; Function:; void TSpectrumFit2::FitAwmi(float **fSource); �; This function fits the source; spectrum using AWMI algorithm. The calling program should fill in input; parameters of the TSpectrumFit2 class using a set of TSpectrumFit2 setters. The; fitted parameters are written into the class and fitted data are written into; source spectrum. ;  ;  ; Parameter:; ������� fSource-pointer to; the matrix of source spectrum����������������� ;  ;  ; Member variables; of� TSpectrumFit2 class:; �� Int_t����; fNPeaks;����������������������� //number of peaks present in fit, input; parameter, it should be > 0; �� Int_t����; fNumberIterations;������������� //number of iterations in fitting procedure,; input parameter, it should be > 0; �� Int_t����; fXmin;������������������������� //first fitted channel in x direction; �� Int_t����; fXmax;�������������������� �����//last fitted channel in x direction; �� Int_t����; fYmin;������������������������� //first fitted channel in y direction; �� Int_t����; fYmax;������������������������� //last fitted channel in y direction; �� Int_t����; fStatisticType;���������������� //type of statistics, possible values; kFitOptimChiCounts (chi square statistics with counts as weighting; coefficients), kFitOptimChiFuncValues (chi square statistics with function; values as weighting coefficients),kFitOptimMaxLikelihood; �� Int_t���� fAlphaOptim;�������������������; optimization of convergence algorithm, possible values kFitAlphaHalving,; kFitAlphaOptimal; �� Int_t����; fPower;������������������������ //possible values kFitPower2,4,6,8,10,12, for; details see references. It applies only for Awmi fitting function.; �� Int_t����; fFitTaylor;�������������������� //order of Taylor expansion, possible values; kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting; function.; �� Double_t�; fAlpha;������������������������ //convergence coefficient, input parameter, it; should be positive number and <=1, for detai",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:63603,Performance,optimiz,optimization,63603,"(Bool_t *) FixPosY, PosX, (Bool_t *) FixPosX, PosY, (Bool_t *); FixPosY, Amp, (Bool_t *) FixAmp, AmpXY, (Bool_t *) FixAmp, AmpXY, (Bool_t *); FixAmp);����� ; ��; pfit->SetBackgroundParameters(0, kFALSE, 0, kTRUE, 0, kTRUE);�� ; ��; pfit->FitStiefel(source);; ��� for (i = 0; i <; nbinsx; i++){; ���� for (j = 0; j <; nbinsy; j++){; ���� ���������� ��search->SetBinContent(i; + 1, j + 1,source[i][j]);; �� ������������ �}; �� }�� ; ��; search->Draw(""SURF"");; }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax, ymin, ymax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* a",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:14956,Testability,log,logical,14956,"fAyInitinitial value of background ay parameter(backgroud is estimated as a0+ax*x+ay*y); Double_tfBxCalccalculated value of b parameter for 1D ridges in x direction; Double_tfBxErrerror value of b parameter for 1D ridges in x direction; Double_tfBxInitinitial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references; Double_tfByCalccalculated value of b parameter for 1D ridges in y direction; Double_tfByErrerror value of b parameter for 1D ridges in y direction; Double_tfByInitinitial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references; Double_tfChihere the fitting functions return resulting chi square ; Int_tfFitTaylororder of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.; Bool_tfFixA0logical value of a0 parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixAmp[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positio",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:15125,Testability,log,logical,15125," in x direction; Double_tfBxErrerror value of b parameter for 1D ridges in x direction; Double_tfBxInitinitial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references; Double_tfByCalccalculated value of b parameter for 1D ridges in y direction; Double_tfByErrerror value of b parameter for 1D ridges in y direction; Double_tfByInitinitial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references; Double_tfChihere the fitting functions return resulting chi square ; Int_tfFitTaylororder of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.; Bool_tfFixA0logical value of a0 parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixAmp[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:15310,Testability,log,logical,15310," html manual and references; Double_tfByCalccalculated value of b parameter for 1D ridges in y direction; Double_tfByErrerror value of b parameter for 1D ridges in y direction; Double_tfByInitinitial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references; Double_tfChihere the fitting functions return resulting chi square ; Int_tfFitTaylororder of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.; Bool_tfFixA0logical value of a0 parameter, which allows to fix the parameter (not to fit).; Bool_t*fFixAmp[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix approp",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:15923,Testability,log,logical,15923,"aks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY1[fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_tfFixRological value of correlation coefficient, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaXlogical value of sigma x parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaYlogical value of sigma y parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSxlogical value of s parameter for 1D ridges",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:16098,Testability,log,logical,16098,"ool_t*fFixAmpX1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY1[fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_tfFixRological value of correlation coefficient, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaXlogical value of sigma x parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaYlogical value of sigma y parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSxlogical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixSxylogical value of s parameter for 2D peaks, which allows to fix the pa",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:16273,Testability,log,logical,16273,"ctional; Bool_t*fFixAmpY1[fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY1[fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_tfFixRological value of correlation coefficient, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaXlogical value of sigma x parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaYlogical value of sigma y parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSxlogical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixSxylogical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixSylogical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_tfFixTxlogical value of t p",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:16448,Testability,log,logical,16448,"imated functional; Bool_tfFixAxlogical value of ax parameter, which allows to fix the parameter (not to fit).; Bool_tfFixAylogical value of ay parameter, which allows to fix the parameter (not to fit).; Bool_tfFixBxlogical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixBylogical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_t*fFixPositionX[fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionX1[fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY[fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional; Bool_t*fFixPositionY1[fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional; Bool_tfFixRological value of correlation coefficient, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaXlogical value of sigma x parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSigmaYlogical value of sigma y parameter, which allows to fix the parameter (not to fit).; Bool_tfFixSxlogical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixSxylogical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit).; Bool_tfFixSylogical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).; Bool_tfFixTxlogical value of t parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).; Bool_tfFixTxylogical value of t parameter for 2D peaks, which allows to fix the paramet",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:47361,Testability,log,logical,47361,"ted value of s parameter for 1D ridges; in y direction; �� Double_t�; fSyErr;������������������������ //error value of s parameter for 1D ridges in y; direction; �� Double_t�; fBxInit;����������������������� //initial value of b parameter for 1D ridges in; x direction (slope), for details see html manual and references; �� Double_t�; fBxCalc;����������������������� //calculated value of b parameter for 1D ridges; in x direction; �� Double_t�; fBxErr;����������������� �������//error value of b parameter for 1D ridges in x; direction; �� Double_t�; fByInit;����������������������� //initial value of b parameter for 1D ridges in; y direction (slope), for details see html manual and references; �� Double_t�; fByCalc;������������ �����������//calculated value of b parameter for 1D ridges; in y direction; �� Double_t�; fByErr;������������������������ //error value of b parameter for 1D ridges in y; direction; �� Double_t�; fA0Init;����������������������� //initial value of background a0 parameter(backgroud; is estimated as a0+ax*x+ay*y); �� Double_t�; fA0Calc;����������������������� //calculated value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit).",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:47565,Testability,log,logical,47565,ed value of background a0 parameter; �� Double_t�; fA0Err;������������������������ //error value of background a0 parameter; �� Double_t� fAxInit;��������; ���������������//initial value of background ax parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t�,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:47769,Testability,log,logical,47769,parameter(backgroud is; estimated as a0+ax*x+ay*y); �� Double_t�; fAxCalc;����������������������� //calculated value of background ax parameter; �� Double_t�; fAxErr;������������������������ //error value of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated function,MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:47974,Testability,log,logical,47974,"of background ax parameter; �� Double_t�; fAyInit;����������������������� //initial value of background ay; parameter(backgroud is estimated as a0+ax*x+ay*y); �� Double_t�; fAyCalc;����������������������� //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of si",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:48179,Testability,log,logical,48179," //calculated value of background ay parameter; �� Double_t� fAyErr;������������������������; error value of background ay parameter�� ; �� Bool_t��; *fFixPositionX;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit)",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:48382,Testability,log,logical,48382," values which; allow to fix appropriate x positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY;����������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:48601,Testability,log,logical,48601,"allow to fix appropriate y positions of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionX1;������������ ����//[fNPeaks] array of logical values which; allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (no",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:48801,Testability,log,logical,48801,"allow to fix appropriate x positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixPositionY1;���������������� //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;�������������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:48935,Testability,log,logical,48935," //[fNPeaks] array of logical values which; allow to fix appropriate y positions of 1D ridges (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;�����������������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49068,Testability,log,logical,49068," estimated functional; �� Bool_t��; *fFixAmp;����������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixB",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49209,Testability,log,logical,49209,"litudes of 2D peaks (not fit). However they are; present in the estimated functional; �� Bool_t��; *fFixAmpX1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; ��",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49350,Testability,log,logical,49350,"s] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in x direction (not fit).; However they are present in the estimated functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49491,Testability,log,logical,49491,"ed functional; �� Bool_t��; *fFixAmpY1;��������������������� //[fNPeaks] array of logical values which; allow to fix appropriate amplitudes of 1D ridges in y direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Boo",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49648,Testability,log,logical,49648," direction (not fit).; However they are present in the estimated functional; �� Bool_t���; fFixSigmaX;��������� �����������//logical value of sigma x parameter, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;�������������",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49805,Testability,log,logical,49805,"er, which; allows to fix the parameter (not to fit).; �� Bool_t���; fFixSigmaY;�������������������� //logical value of sigma y parameter, which; allows to fix the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976)",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:49962,Testability,log,logical,49962,"x the parameter (not to fit).; �� Bool_t��� fFixRo;������� �����������������//logical; value of correlation coefficient, which allows to fix the parameter (not to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:50118,Testability,log,logical,50118,"ot to; fit).; �� Bool_t���; fFixTxy;����������������������� //logical value of t parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jents",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:50276,Testability,log,logical,50276," Bool_t���; fFixSxy;����������������������� //logical value of s parameter for 2D peaks,; which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:50433,Testability,log,logical,50433,"ool_t���; fFixTx;������������������������ //logical value of t parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J.; Kliman,� M. Jandel,� Ľ. Krupa, V. Matou�ek: Study of fitting algorithms; applied to simultaneous analysis of large number of peaks in -ray s",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:50562,Testability,log,logical,50562,"arameter (not to fit).; �� Bool_t���; fFixTy;������������������������ //logical value of t parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J.; Kliman,� M. Jandel,� Ľ. Krupa, V. Matou�ek: Study of fitting algorithms; applied to simultaneous analysis of large number of peaks in -ray spectra. Applied Spectroscopy, Vol. 57, No. 7, pp. 753-760, 2003; �; Example �� script FitAwmi2.c:. Fig. 1 Original two-dimensiona",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:50691,Testability,log,logical,50691,"n, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSx;������������������������ //logical value of s parameter for 1D ridges in; x direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixSy;������������������������ //logical value of s parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t��� fFixBx;�� ����������������������//logical; value of b parameter for 1D ridges in x direction, which allows to fix the; parameter (not to fit).; �� Bool_t���; fFixBy;������������������������ //logical value of b parameter for 1D ridges in; y direction, which allows to fix the parameter (not to fit).; �� Bool_t���; fFixA0;������������������������ //logical value of a0 parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAx;������������������������ //logical value of ax parameter, which allows; to fix the parameter (not to fit).; �� Bool_t���; fFixAy;������������������������ //logical value of ay parameter, which allows; to fix the parameter (not to fit).; �; References:; [1] Phillps G.W., Marlow K.W.,; NIM 137 (1976) 525.; [2] I. A. Slavic: Nonlinear; least-squares fitting without matrix inversion applied to complex Gaussian; spectra analysis. NIM 134 (1976) 285-289.; [3] T. Awaya: A new method for; curve fitting to the data with low statistics not using chi-square method. NIM; 165 (1979) 317-323.; [4] T. Hauschild, M. Jentschel:; Comparison of maximum likelihood estimation and chi-square statistics applied; to counting experiments. NIM A 457 (2001) 384-401.; �[5]� M. Morh�č,� J.; Kliman,� M. Jandel,� Ľ. Krupa, V. Matou�ek: Study of fitting algorithms; applied to simultaneous analysis of large number of peaks in -ray spectra. Applied Spectroscopy, Vol. 57, No. 7, pp. 753-760, 2003; �; Example �� script FitAwmi2.c:. Fig. 1 Original two-dimensional; spectrum with found peaks (using TSpectrum2 peak searching function). The; positions of peaks were used as initial estimates i",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:64601,Testability,log,logical,64601,"nction.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:64744,Testability,log,logical,64744,"nction.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:64900,Testability,log,logical,64900,"nction.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:65066,Testability,log,logical,65066,"nction.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). ",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
https://root.cern/root/html528/TSpectrum2Fit.html:65277,Testability,log,logical,65277,"_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigmaX - initial value of sigma x parameter; -fixSigmaX - logical value of sigma x parameter, which allows to fix the parameter (not to fit); -sigmaY - initial value of sigma y parameter; -fixSigmaY - logical value of sigma y parameter, which allows to fix the parameter (not to fit); -ro - initial value of ro parameter (correlation coefficient); -fixRo - logical value of ro parameter, which allows to fix the parameter (not to fit); -positionInitX - aray of initial values of peaks x positions; -fixPositionX - array of logical values which allow to fix appropriate x positions (not fit). However they are present in the estimated functional.; -positionInitY - aray of initial values of peaks y positions; -fixPositionY - array of logical values which allow to fix appropriate y positions (not fit). However they are present in the estimated functional.; -ampInit - aray of initial values of 2D peaks amplitudes; -fixAmp - aray of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional; -ampInitX1 - aray of initial values of amplitudes of 1D ridges in x direction; -fixAmpX1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional; -ampInitY1 - aray of initial values of amplitudes of 1D ridges in y direction; -fixAmpY1 - aray of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional. void SetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy). SETTER FUNCTION. This function sets",MatchSource.WIKI,root/html528/TSpectrum2Fit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html
