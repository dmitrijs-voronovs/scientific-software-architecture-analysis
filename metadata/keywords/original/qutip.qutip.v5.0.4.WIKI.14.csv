id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.3/apidoc/functions.html:195261,Availability,error,error,195261,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:195328,Availability,error,error,195328,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still gi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:197012,Availability,error,error,197012,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict;",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:200394,Availability,error,error,200394,"med to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:35680,Deployability,configurat,configuration,35680,"cision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N : int; Square root of the dimension of the superoperator to be returned. enforce_tp : bool; If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None; Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix represent",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:35769,Deployability,configurat,configurations,35769,"ion of the superoperator to be returned. enforce_tp : bool; If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None; Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian sup",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:48955,Deployability,continuous,continuous,48955,"stance between two density matrices A & B. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; dist : float; Hilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A : Qobj; Quantum object representing a superoperator. target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis : list; List of operators that defines the basis for the correlation matrix. rho : Qobj; Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:; corr_mat : ndarray; A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\ra",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:53269,Deployability,integrat,integrating,53269,"rix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns:; cov_mat : ndarray; A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictiona",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:55380,Deployability,integrat,integrating,55380,"s; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:57664,Deployability,integrat,integration,57664,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:58303,Deployability,integrat,integrator,58303,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-d",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:58640,Deployability,integrat,integrator,58640,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.e",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111742,Deployability,configurat,configuration,111742,"nsity matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:114266,Deployability,integrat,integrated,114266,"nt; Number of photon emissions to calculate. c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlist : array_like; List of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest. system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; \(\psi(t_0)\). construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; \(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\); Default: True. Returns:; phi_n : :class: qutip.Qobj; The scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters:; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0 : :class: qutip.Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides). c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlist : array_like; List of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state : :class: qutip.Qobj; State representi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156474,Deployability,configurat,configuration,156474,"r Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : array_like; list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:176402,Deployability,configurat,configuration,176402,"ributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:216953,Deployability,update,updated,216953,"ument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18090,Energy Efficiency,charge,charge,18090,"; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18154,Energy Efficiency,charge,charge,18154,"; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18175,Energy Efficiency,charge,charge,18175,"; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18242,Energy Efficiency,charge,charge,18242," = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.7320508",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18305,Energy Efficiency,charge,charge,18305,". ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destru",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:18378,Energy Efficiency,charge,charge,18378,". 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters:; N : int; Dimension of Hi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:69477,Energy Efficiency,power,power,69477,"ip.Qdeoptions; Options for the ODE solver. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectatio",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:69933,Energy Efficiency,energy,energy,69933,"e)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:97614,Energy Efficiency,power,power,97614,"\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list of qutip.qobj; list of collapse operators. a_op : qutip.qobj; operator A. b_op : qutip.qobj; operator B. use_pinv : bool; If True use numpy’s pinv method, otherwise use a generic solver. Returns:; spectrum : array; An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist : array_like; list/array of times \(t\) which the correlation function is given. y : array_like; list/array of correlations corresponding to time delays \(t\). inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns:; w, S : tuple; Returns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:98088,Energy Efficiency,power,power,98088,"is spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list of qutip.qobj; list of collapse operators. a_op : qutip.qobj; operator A. b_op : qutip.qobj; operator B. use_pinv : bool; If True use numpy’s pinv method, otherwise use a generic solver. Returns:; spectrum : array; An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist : array_like; list/array of times \(t\) which the correlation function is given. y : array_like; list/array of correlations corresponding to time delays \(t\). inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns:; w, S : tuple; Returns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102006,Energy Efficiency,power,power,102006,"nnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102016,Energy Efficiency,power,power-gmres,102016,"nnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102031,Energy Efficiency,power,power-lgmres,102031,"nnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102047,Energy Efficiency,power,power-bicgstab,102047,"nnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102356,Energy Efficiency,power,power,102356,"ors. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a prec",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102370,Energy Efficiency,power,power,102370,"ors. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a prec",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102393,Energy Efficiency,power,power,102393,"and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102408,Energy Efficiency,power,power-gmres,102408,"and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102423,Energy Efficiency,power,power-lgmres,102423,"and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:102439,Energy Efficiency,power,power-bicgstab,102439,"and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:104070,Energy Efficiency,power,power,104070," Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:105518,Energy Efficiency,reduce,reduced,105518,"lt = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns:; dm : qobj; Steady state density matrix. info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters:; A : qobj; A Hamiltonian or ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:107568,Energy Efficiency,power,power,107568,"llian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’; Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:107597,Energy Efficiency,power,power,107597,"llian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’; Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:108225,Energy Efficiency,reduce,reduced,108225," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’; Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm v",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:121058,Energy Efficiency,energy,energy,121058,"many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters:; N: int; The number of two-level systems. Returns:; Nj: int; The number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters:; nds: int; The number of Dicke states. Returns:; N: int; The number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters:; mat: ndarray/Qobj; A 2D numpy array. Returns:; diag: bool; True/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters:; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns:; degeneracy: int; The state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters:; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns:; degeneracy: int; The m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters:; j, m: float; The value for j and m in the dicke basis |j,m>. Returns:; a_plus: float; The value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters:; j: float; The value for j. m: float; The value for m. Returns:; a_minus: float; The value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:121198,Energy Efficiency,energy,energy,121198,"int; The number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters:; nds: int; The number of Dicke states. Returns:; N: int; The number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters:; mat: ndarray/Qobj; A 2D numpy array. Returns:; diag: bool; True/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters:; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns:; degeneracy: int; The state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters:; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns:; degeneracy: int; The m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters:; j, m: float; The value for j and m in the dicke basis |j,m>. Returns:; a_plus: float; The value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters:; j: float; The value for j. m: float; The value for m. Returns:; a_minus: float; The value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),; is placed in a \(2^N",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:126813,Energy Efficiency,efficient,efficient,126813,". Notes; Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:; state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float; Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}; Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are cal",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:130795,Energy Efficiency,energy,energy,130795,"gram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:; M : Matrix of Qobj; The matrix to visualize. xlabels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=Non",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:130862,Energy Efficiency,energy,energy,130862,"the given x and y labels; and title. Parameters:; M : Matrix of Qobj; The matrix to visualize. xlabels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:130909,Energy Efficiency,energy,energy,130909,"abels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; T",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:131230,Energy Efficiency,energy,energy,131230,"numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title fo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:131296,Energy Efficiency,energy,energy,131296,"tlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (i",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157628,Energy Efficiency,reduce,reduces,157628,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:207862,Energy Efficiency,energy,energy,207862,"rray with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Forma",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:207936,Energy Efficiency,energy,energy,207936," sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:208155,Energy Efficiency,energy,energy,208155,"s to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_lik",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:213513,Energy Efficiency,schedul,scheduling,213513,"th IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwar",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:213860,Energy Efficiency,schedul,scheduled,213860,"ask(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array /",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:215252,Energy Efficiency,schedul,scheduling,215252,"e, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:215599,Energy Efficiency,schedul,scheduled,215599," the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:829,Integrability,depend,dependent,829,". . Functions — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:; N : int; Number of Fock states in Hilbert space. n : int; Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the state. Returns:; state : qobj; Qobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43104,Integrability,contract,contracted,43104,"ed operator; acts. Parameters:; args : array_like; list or array of quantum objects with type=""super"". Returns:; obj : qobj; A composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43185,Integrability,contract,contracted,43185," obj : qobj; A composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the con",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:53269,Integrability,integrat,integrating,53269,"rix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns:; cov_mat : ndarray; A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictiona",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:53916,Integrability,depend,dependent,53916,"Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictionary of parameters for time-dependent Hamiltonians. options : qutip.Qdeoptions; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation value",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:54301,Integrability,depend,dependent,54301,"set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictionary of parameters for time-dependent Hamiltonians. options : qutip.Qdeoptions; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:55380,Integrability,integrat,integrating,55380,"s; with options for the ODE solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:56177,Integrability,depend,dependent,56177,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:56207,Integrability,depend,dependent,56207,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:56734,Integrability,depend,dependent,56734,"t is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:57355,Integrability,depend,dependent,57355,"allback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:57664,Integrability,integrat,integration,57664,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:58303,Integrability,integrat,integrator,58303,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-d",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:58640,Integrability,integrat,integrator,58640,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.e",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:58788,Integrability,depend,dependent,58788,"though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the time",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:59279,Integrability,depend,dependent,59279," handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calcu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60397,Integrability,depend,dependent,60397," or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60503,Integrability,depend,dependent,60503," or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60626,Integrability,depend,dependent,60626,"t.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of co",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60712,Integrability,depend,dependent,60712,"t.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of co",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60802,Integrability,depend,dependent,60802,"t.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of co",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:60930,Integrability,depend,dependent,60930,"lo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of collapse; operators. e_ops : array_like; single operator or list or array of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:61873,Integrability,depend,dependent,61873," values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of collapse; operators. e_ops : array_like; single operator or list or array of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. .. note::; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; t",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:63481,Integrability,depend,dependent,63481,"rom a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:; H : qobj/function_type; System Hamiltonian. rho0 : qutip.qobj; Initial state density matrix. tlist : list/array; list of times for \(t\). c_op_list : list of qutip.qobj; list of qutip.qobj collapse operators. e_ops : list of qutip.qobj; list of qutip.qobj operators for which to evaluate; expectation values. Returns:; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in tlist. .. note:: This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64643,Integrability,depend,dependent,64643," : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian giv",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64776,Integrability,depend,dependent,64776," : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian giv",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64947,Integrability,depend,dependence,64947,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:65099,Integrability,depend,dependence,65099,"one, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to eva",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:65312,Integrability,depend,dependence,65312,"d; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secula",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:65599,Integrability,depend,dependence,65599," by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:69591,Integrability,depend,dependence,69591,"olver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:69766,Integrability,depend,dependent,69766,"_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding qu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:70998,Integrability,depend,dependent,70998,"he Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dic",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:71126,Integrability,depend,dependence,71126,"5e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:71292,Integrability,depend,dependent,71292,": int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:71948,Integrability,depend,dependent,71948,"Parameters:; H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[sour",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:72076,Integrability,depend,dependence,72076,"red to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence.",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:72641,Integrability,depend,dependent,72641,"loquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the init",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:72700,Integrability,depend,dependence,72700," initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:73063,Integrability,depend,dependence,73063,"ionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the h",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:73329,Integrability,depend,dependence,73329,"oquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet mod",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:73906,Integrability,depend,dependent,73906,"_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:73965,Integrability,depend,dependence,73965,"floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; De",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:74669,Integrability,depend,dependent,74669,"rs:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:74728,Integrability,depend,dependence,74728,"l Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:75581,Integrability,depend,dependent,75581,"The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be consider",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:75956,Integrability,depend,dependence,75956,"urce]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:76846,Integrability,depend,depending,76846,"h time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:; output: :class:`qutip.solver.SolverResult`; An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:77949,Integrability,depend,depending,77949,"ip.Qobj; Initial density matrix or state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:; output: :class:`qutip.solver.SolverResult`; An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj; Single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:; output: :class:`qutip.solver.SolverResult`; An instance of the class qutip.solver.SolverResult. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matri",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:81039,Integrability,depend,dependent,81039,"ip.Qobj; Initial state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:; output: :class:`qutip.solver.SolverResult`; An instance of the class qutip.solver.SolverResult. Correlation Functions¶. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for expo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:81738,Integrability,depend,dependent,81738,"ns=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options objec",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:84309,Integrability,depend,dependent,84309,"o \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; t",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:84746,Integrability,depend,dependent,84746,"rr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : ndarray; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:85916,Integrability,depend,dependent,85916,"\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : ndarray; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:86609,Integrability,depend,dependent,86609," options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.s",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:88012,Integrability,depend,dependent,88012,"nt list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the time",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:88447,Integrability,depend,dependent,88447,"ead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:89603,Integrability,depend,dependent,89603,"(me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element lis",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:90294,Integrability,depend,dependent,90294,"\(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:91610,Integrability,depend,dependent,91610,"use; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:92045,Integrability,depend,dependent,92045,"s; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two tim",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:93305,Integrability,depend,dependent,93305,"ptions : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is t",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:93996,Integrability,depend,dependent,93996,"(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:98601,Integrability,depend,dependent,98601,"rce]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist : array_like; list/array of times \(t\) which the correlation function is given. y : array_like; list/array of correlations corresponding to time delays \(t\). inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns:; w, S : tuple; Returns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:99038,Integrability,depend,dependent,99038,"angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamilto",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:100049,Integrability,depend,dependent,100049,"endent for solver choice of; me or mc. a_op : Qobj; operator A. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. args : dict; Dictionary of arguments to be passed to solver. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherenc",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:100486,Integrability,depend,dependent,100486," The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. args : dict; Dictionary of arguments to be passed to solver. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:109502,Integrability,depend,dependent,109502,"h diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’); Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:109769,Integrability,depend,dependent,109769,"d by advanced users. Returns:; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’); Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:110667,Integrability,depend,dependent,110667,"bj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’); Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically compu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111042,Integrability,depend,dependent,111042,"lel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶;",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111421,Integrability,depend,dependent,111421,"). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index c",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:114266,Integrability,integrat,integrated,114266,"nt; Number of photon emissions to calculate. c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlist : array_like; List of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest. system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; \(\psi(t_0)\). construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; \(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\); Default: True. Returns:; phi_n : :class: qutip.Qobj; The scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters:; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0 : :class: qutip.Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides). c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlist : array_like; List of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state : :class: qutip.Qobj; State representi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:120512,Integrability,depend,depending,120512,"ber of two-level systems. basis: str; The basis to use. Either “dicke” or “uncoupled”. Returns:; state: :class: qutip.Qobj; The ground state density matrix in the requested basis. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters:; N: int; The number of two-level systems. Returns:; nds: int; The number of Dicke states. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters:; N: int; The number of two-level systems. Returns:; Nj: int; The number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters:; nds: int; The number of Dicke states. Returns:; N: int; The number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters:; mat: ndarray/Qobj; A 2D numpy array. Returns:; diag: bool; True/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters:; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns:; degeneracy: int; The state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters:; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns:; degeneracy: int; The m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters:; j, m: float; The value for j and m in the dicke basis |j,m>. Returns:; a_plus: float; The value of \",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:160037,Integrability,depend,dependent,160037,"params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:160261,Integrability,depend,dependent,160261,"s=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:162589,Integrability,depend,dependent,162589,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and p",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:168042,Integrability,wrap,wrapper,168042,"rror, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time depen",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:168938,Integrability,depend,dependent,168938,"source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the con",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:169153,Integrability,depend,dependent,169153," dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:171477,Integrability,depend,dependent,171477,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:176741,Integrability,depend,dependent,176741,"PE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:176965,Integrability,depend,dependent,176965,"phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:179293,Integrability,depend,dependent,179293,"teger; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtor",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:185380,Integrability,depend,dependent,185380,"ne, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:185604,Integrability,depend,dependent,185604,"imise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:193102,Integrability,wrap,wrapper,193102,"ination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:194028,Integrability,depend,dependent,194028,"ulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the con",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:194243,Integrability,depend,dependent,194243,"arameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:201772,Integrability,rout,routines,201772,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format. start : int; Staring node for BFS traversal. Returns:; order : array; Order in which nodes are traversed from starting node. levels : array; Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:202936,Integrability,rout,routine,202936,"rmat starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format. start : int; Staring node for BFS traversal. Returns:; order : array; Order in which nodes are traversed from starting node. levels : array; Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format. sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns:; perm : array; Array of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that rem",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:203564,Integrability,rout,routine,203564,"x; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format. sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns:; perm : array; Array of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A : sparse matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Uc",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:203670,Integrability,rout,routines,203670,"x; Input quantum object or csr_matrix. Returns:; degree : array; Array of integers giving the degree for each node (row). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format. sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns:; perm : array; Array of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A : sparse matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Uc",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:216006,Integrability,depend,dependencies,216006,"e task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updat",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:216327,Integrability,depend,dependencies,216327,"ument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:35680,Modifiability,config,configuration,35680,"cision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters:; N : int; Square root of the dimension of the superoperator to be returned. enforce_tp : bool; If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None; Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix represent",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:35769,Modifiability,config,configurations,35769,"ion of the superoperator to be returned. enforce_tp : bool; If True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rank : int or None; Rank of the sampled superoperator. If None, a full-rank; superoperator is generated. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns:; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian sup",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:48966,Modifiability,variab,variable,48966,"stance between two density matrices A & B. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; dist : float; Hilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A : Qobj; Quantum object representing a superoperator. target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis : list; List of operators that defines the basis for the correlation matrix. rho : Qobj; Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:; corr_mat : ndarray; A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\ra",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:53363,Modifiability,evolve,evolve,53363,"sional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters:; H : qutip.qobj; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : qutip.qobj; initial state vector (ket); or initial unitary operator psi0 = U. tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be empty list operator evolution. args : dictionary; dictionary of parameters for time-dependent Hamiltonians. options : qutip.Qdeoptions; with options for the ODE solver. progr",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:55512,Modifiability,evolve,evolved,55512,"lation. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a l",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64234,Modifiability,coupling,coupling,64234,"p.qobj; list of qutip.qobj collapse operators. e_ops : list of qutip.qobj; list of qutip.qobj operators for which to evaluate; expectation values. Returns:; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in tlist. .. note:: This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64430,Modifiability,coupling,coupling,64430,"does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64570,Modifiability,variab,variable,64570,"does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64831,Modifiability,variab,variable,64831,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64892,Modifiability,variab,variables,64892,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:64975,Modifiability,variab,variable,64975,"ter Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Ne",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:66333,Modifiability,coupling,coupling,66333,"and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : qutip.solver.Options; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters:; H : qutip.qobj. System Hamiltonian. a_ops : list; Nested list of system operators that cou",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:67172,Modifiability,coupling,couplingto,67172," List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : qutip.solver.Options; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters:; H : qutip.qobj. System Hamiltonian. a_ops : list; Nested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cb : list; Depreciated. c_ops : list; List of system collapse operators. use_secular : bool {True, False}; Flag that indicates if the secular approximation should; be used. sec_cutoff : float {0.1}; Threshold for secular approximation. atol : float {qutip.settings.atol}; Threshold for removing small parameters. Returns:; R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`; R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_ten",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:71058,Modifiability,variab,variables,71058,"re is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:; H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:72008,Modifiability,variab,variables,72008,"t with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj; The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:; output : list of kets, list of quasi energies; Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:72766,Modifiability,variab,variables,72766,"of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_en",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:74031,Modifiability,variab,variables,74031,"s in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:74794,Modifiability,variab,variables,74794," energies. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : list; A list of Floquet states for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qobj (kets); A list of initial Floquet modes (for time \(t=0\)). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : qutip.qobj; System Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns:; output : qutip.qobj; The wavefunction for the time \(t\). floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expec",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:76022,Modifiability,variab,variables,76022," in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states : list of qutip.qobj (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : qutip.qobj; The wavefunction to decompose in the Floquet state basis. Returns:; output : array; The coefficients \(c_\alpha\) in the Floquet state decomposition. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H : qutip.qobj.Qobj; System Hamiltonian, time-dependent with period T. psi0 : qutip.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111505,Modifiability,config,config,111505," applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vecto",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111742,Modifiability,config,configuration,111742,"nsity matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156474,Modifiability,config,configuration,156474,"r Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : array_like; list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157092,Modifiability,variab,variables,157092,"we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157663,Modifiability,variab,variables,157663,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157750,Modifiability,variab,variables,157750,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157830,Modifiability,variab,variables,157830,"ntly two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metri",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:176402,Modifiability,config,configuration,176402,"ributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:184896,Modifiability,variab,variables,184896,"ization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:187798,Modifiability,variab,variable,187798,"e for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each times",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:188319,Modifiability,variab,variable,188319,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:193534,Modifiability,variab,variables,193534,"all_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or Non",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196433,Modifiability,variab,variable,196433,"e for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be a",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196954,Modifiability,variab,variable,196954,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict;",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:207419,Modifiability,coupling,coupling,207419,": float or array; Frequency of the oscillator. w_th : float; The temperature in units of frequency (or the same units as w). Returns:; n_avg : float or array; Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. linspace_with(start, stop, num=50, elems=[])[source]¶; Return an array of numbers sampled over specified interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to sto",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:209622,Modifiability,variab,variable,209622,"m. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:210042,Modifiability,variab,variables,210042," named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:210102,Modifiability,variab,variables,210102," array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns:; result : list; A list with length equal to number of input parameters; containing the output from func. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters:; task : a Python function; The function that is to be called for each value in task_vec. values : array / list; The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary; The optional additional argument ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:44115,Performance,concurren,concurrence,44115," all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:44156,Performance,concurren,concurrence,44156," all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:76636,Performance,optimiz,optimizing,76636,"p.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Option",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:76663,Performance,perform,performance,76663,"p.qobj; Initial state vector (ket). tlist : list / array; list of times for \(t\). e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns:; output : qutip.solver.Result; An instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H : qutip.Qobj; System Hamiltonian. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary; Option",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:103554,Performance,perform,perform,103554,"ault = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specifie",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:103919,Performance,perform,perform,103919,"lse; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; app",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:127315,Performance,perform,performance,127315," = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}; Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters:; rho : qobj; Input density matrix or su",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157024,Performance,optimiz,optimize,157024,"we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:158480,Performance,optimiz,optimization,158480," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:162272,Performance,optimiz,optimize,162272,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:162457,Performance,optimiz,optimize,162457,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : stri",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:162963,Performance,optimiz,optimize,162963,"optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:171160,Performance,optimiz,optimize,171160,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ onl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:171345,Performance,optimiz,optimize,171345,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:171851,Performance,optimiz,optimize,171851,"optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:178976,Performance,optimiz,optimize,178976,"delity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:179161,Performance,optimiz,optimize,179161,"s; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:179674,Performance,optimiz,optimize,179674,"arams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:183785,Performance,optimiz,optimizer,183785,"or object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:183858,Performance,optimiz,optimizer,183858,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:187603,Performance,perform,performane,187603,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:187938,Performance,optimiz,optimize,187938,"he algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the spe",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:188242,Performance,optimiz,optimize,188242,"scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) comp",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196238,Performance,perform,performane,196238,"optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The ke",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196573,Performance,optimiz,optimize,196573,"he algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Pa",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196877,Performance,optimiz,optimize,196877,"scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:205566,Performance,perform,performing,205566,"Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular.; This function looks at both the structure and ABS values of the; underlying matrix. Parameters:; A : csc_matrix; Input matrix. perm_type : str {‘row’, ‘column’}; Type of permutation to generate. Returns:; perm : array; Array of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices”, SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters:; w : float or array; Frequency of the oscillator. w_th : float; The temperature in units of frequency (or the same units as w). Returns:; n_avg : float or array; Return the number of average photons in thermal equilibriu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:209095,Performance,load,loaded,209095,"it (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_like; Object retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters:; data : instance/array_like; Input Python object to be stored. filename : str; Name of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters:; func : function_type; A function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the funct",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:212887,Performance,load,load-balanced,212887,"alled for each value in task_vec. values : array / list; The list or array of values for which the task function is to be; evaluated. task_args : list / dictionary; The optional additional argument to the task function. task_kwargs : list / dictionary; The optional additional keyword argument to the task function. progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns:; result : list; The result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:213572,Performance,load,load-balanced,213572,"show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced vi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:214577,Performance,load,load-balanced,214577," is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) wa",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:215311,Performance,load,load-balanced,215311,"False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP depen",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:36982,Safety,avoid,avoids,36982,"------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . [R0be8dcf25d86-1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:; states : array; array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:; ops : array; array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:; H : qobj; System Hamiltonian. c_ops : array_like; A list or array of collapse operators. Returns:; L : qobj; Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:; A : qobj; Quantum operator for post multiplication. Returns:; super : qobj; Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:; A : qobj; Quantum operator for pre-multiplication. Returns:; super :qobj; Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns:; super : Qobj; Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, d",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:137569,Security,access,access,137569,"gure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest.; More information:. J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:; ket : Qobj; Pure state for plotting. theme : ‘light’ (default) or ‘dark’; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’; Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’; Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis cont",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156942,Security,access,accessible,156942," operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:166970,Security,access,accessible,166970,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:175227,Security,access,accessible,175227,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:183436,Security,access,accessible,183436,"dded; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:183630,Security,access,accessed,183630," modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:183733,Security,access,accessed,183733,"e. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:192055,Security,access,accessible,192055,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:200208,Security,access,accessible,200208,"mplemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each tim",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:44726,Testability,log,logarithm,44726,"; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho : qobj; Density matrix for composite quantum systems. selA : int/list; int or list of first selected density matrix components. selB : int/list; int or list of second selected density matrix components. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_mut : float; Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Vo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:45521,Testability,log,logarithm,45521,"tropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_cond : float; Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho : qobj; Density matrix for composite quantum systems. selA : int/list; int or list of first selected density matrix components. selB : int/list; int or list of second selected density matrix components. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_mut : float; Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:; rho : qobj; Density matrix. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; entropy : float; Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; fid : float; Fidelity pseudo-metric between A and B. Ex",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:45820,Testability,log,logarithm,45820,"alue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:; rho : qobj; sensity matrix or ket/bra vector. Returns:; entropy : float; Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:; rho : qobj; Density matrix for composite quantum systems. selA : int/list; int or list of first selected density matrix components. selB : int/list; int or list of second selected density matrix components. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; ent_mut : float; Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters:; rho : qobj; Density matrix. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigensolver. Returns:; entropy : float; Von-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; fid : float; Fidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters:; A : qobj; D",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:52476,Testability,log,logarithmic,52476,"if rho=0, a matrix of operators. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:; a1 : Qobj; Field operator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns:; cov_mat : ndarray; A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary mat",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:52773,Testability,log,logarithmic,52773,"q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters:; a1 : Qobj; Field operator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns:; cov_mat : ndarray; A 2-dimensional array of covariance values. logarithmic_negativity(V)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:; V : 2d array; The covariance matrix. Returns:; N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:166253,Testability,log,logger,166253,"t_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:174510,Testability,log,logger,174510,"t_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:182964,Testability,log,logger,182964,"t_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tsl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:187837,Testability,test,tested,187837,"e for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each times",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:191338,Testability,log,logger,191338,"hey applied after the object is created. guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:196472,Testability,test,tested,196472,"e for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be a",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:199491,Testability,log,logger,199491,"hey applied after the object is created. guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generato",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:62140,Usability,progress bar,progress bar,62140,"; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of collapse; operators. e_ops : array_like; single operator or list or array of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. .. note::; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters:; H : qobj/function_type; System Hamiltonian. rho0 : qutip.qobj; Initial state density matrix. tlist : list/array; list of t",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:110273,Usability,progress bar,progress bar,110273,"r representation of the; density matrix. Parameters:; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’); Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with an",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111479,Usability,clear,clears,111479," applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index can vary. Returns:; temporal_basis_vector : :class: qutip.Qobj; A basis vecto",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:155391,Usability,learn,learningtimes,155391,"perator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters:; N: int; Number of qubits. swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns:; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. qft_gate_sequence(N=1, swapping=True)[source]¶; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters:; N: int; Number of qubits. swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns:; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT. non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : array_like; list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156014,Usability,learn,learningtimes,156014,"te sequence of Hadamard and controlled rotation gates implementing; QFT. non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : array_like; list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity err",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:168033,Usability,simpl,simply,168033,"rror, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time depen",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:193093,Usability,simpl,simply,193093,"ination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:213976,Usability,progress bar,progress bar,213976,"ne, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task f",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:215715,Usability,progress bar,progress bar,215715,"ask: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays r",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1214,Availability,avail,available,1214,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:12486,Availability,error,error,12486, x / np.sqrt(2); ,MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1061,Deployability,install,installation,1061,"cumentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dyn",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:24368,Deployability,update,updated,24368,"2]: (basis(4, 2) + basis(4, 1)).unit(); ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:4323,Energy Efficiency,charge,charge,4323,"fying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. and operators:. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:9922,Integrability,message,message,9922,"rieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1948,Modifiability,variab,variables,1948,"olbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [5]: Qobj([[1],[2],[3],[4],[5]]); Out[5]: ; Quantum object: dims = [[5], ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1088,Performance,load,load,1088,"lation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsula",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1193,Performance,load,load,1193,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:1599,Performance,load,loaded,1599,"Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hin",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:8692,Security,access,accessed,8692,,MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:10046,Security,access,access,10046,"erty; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [14]: q.type; Out[14]: 'oper'. In [15]: q.isherm; ",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:12945,Testability,log,logic,12945,,MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-basics.html:3131,Usability,clear,clear,3131,"apable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [4]: Qobj(); Out[4]: ; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [5]: Qobj([[1],[2],[3],[4],[5]]); Out[5]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha)",MatchSource.WIKI,docs/4.3/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:6986,Availability,down,down,6986,"or and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [40]: yp = [sin(th) for th in np.linspace(0, 2*pi, 20)]. In [41]: zp = np.zeros(20). In [42]: pnts = [xp, yp, zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz = np.zeros(20). In [46]: yz = [np.sin(th) for th in np.linspace(0, pi ,20)]. In [47]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [48]: b.add_points([xz, yz, zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In t",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:15470,Deployability,install,installing,15470," # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:15634,Deployability,install,install,15634,"0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:16475,Deployability,update,updated,16475,"0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:14247,Modifiability,evolve,evolve,14247,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is f",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:1764,Performance,load,load,1764,"Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple ",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:1844,Performance,load,loads,1844,"ng Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps cust",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:12130,Security,access,accessed,12130,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:1934,Usability,simpl,simply,1934,"um Toolbox in Python. Docs »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:2790,Usability,clear,clear,2790,"ng:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc (default=cwd); output directory; Saves Bloch sphere to a file. show();  ; Generates Bloch sphere with given data. As an example, we can add a single data point:; In [3]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [4]: b.add_points(pnt). In [5]: b.show(). and then a single vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.a",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:4191,Usability,clear,clear,4191,"le vector:; In [6]: vec = [0,1,0]. In [7]: b.add_vectors(vec). In [8]: b.show(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). No",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:4304,Usability,clear,clear,4304,"nd then add another vector corresponding to the \(\left|\rm up \right>\) state:; In [9]: up = basis(2,0). In [10]: b.add_states(up). In [11]: b.show(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4). In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:4698,Usability,clear,clear,4698,"ta point is:; In [12]: pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)]. In [13]: b.add_points(pnt). In [14]: b.add_vectors(vec). In [15]: b.add_states(up). In [16]: b.show(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points fu",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:4982,Usability,clear,clear,4982,"d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; In [17]: b.clear(). In [18]: b.show(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; In [19]: x = (basis(2,0)+(1+0j)*basis(2,1)).unit(). In [20]: y = (basis(2,0)+(0+1j)*basis(2,1)).unit(). In [21]: z = (basis(2,0)+(0+0j)*basis(2,1)).unit(). In [22]: b.add_states([x,y,z]). In [23]: b.show(). a similar method works for adding vectors:; In [24]: b.clear(). In [25]: vec = [[1,0,0],[0,1,0],[0,0,1]]. In [26]: b.add_vectors(vec). In [27]: b.show(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; In [28]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [29]: yp = [np.sin(th) for th in np.linspace(0, 2*pi, 20)]. In [30]: zp = np.zeros(20). In [31]: pnts = [xp, yp, zp]. In [32]: b.add_points(pnts). In [33]: b.show(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [34]: xz = np.zeros(20). In [35]: yz = [np.sin(th) for th in np.linspace(0, pi, 20)]. In [36]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [37]: b.add_points([xz, yz, zz]). In [38]: b.show(). The color and shape of the data points is",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:6442,Usability,clear,clear,6442,"single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; In [34]: xz = np.zeros(20). In [35]: yz = [np.sin(th) for th in np.linspace(0, pi, 20)]. In [36]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [37]: b.add_points([xz, yz, zz]). In [38]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [40]: yp = [sin(th) for th in np.linspace(0, 2*pi, 20)]. In [41]: zp = np.zeros(20). In [42]: pnts = [xp, yp, zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz = np.zeros(20). In [46]: yz = [np.sin(th) for th in np.linspace(0, pi ,20)]. In [47]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [48]: b.add_points([xz, yz, zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:13058,Usability,clear,clear,13058,"1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:15064,Usability,clear,clear,15064,"op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); retur",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:15309,Usability,simpl,simple,15309,"olve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resul",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-bloch.html:15932,Usability,clear,clear,15932,"0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta),0,np.cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-bloch.html
https://qutip.org/docs/4.3/guide/guide-control.html:6254,Availability,error,error,6254,"(and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11926,Availability,down,down,11926,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11997,Availability,avail,available,11997,"a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integrat",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13054,Availability,error,errors,13054,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11808,Deployability,integrat,integration,11808,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:12864,Deployability,integrat,integration,12864,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13006,Deployability,integrat,integration,13006,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13481,Deployability,integrat,integrated,13481,"espect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and method",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14580,Deployability,configurat,configuration,14580,"ptimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14804,Deployability,configurat,configuration,14804," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:17541,Deployability,configurat,configuration,17541,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:18375,Deployability,update,updated,18375,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:8256,Energy Efficiency,efficient,efficient,8256,"dency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bou",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:8544,Energy Efficiency,reduce,reduces,8544,"rom here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather t",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9312,Energy Efficiency,reduce,reduces,9312,"ith respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performi",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9509,Energy Efficiency,efficient,efficient,9509,"s typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-p",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9859,Energy Efficiency,efficient,efficient,9859,"s of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algo",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11325,Energy Efficiency,efficient,efficiently,11325,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:18182,Energy Efficiency,efficient,efficient,18182,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:4399,Integrability,depend,dependent,4399,"ht\rangle} \ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_0}\) to \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9171,Integrability,wrap,wrapper,9171,"h the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goa",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11808,Integrability,integrat,integration,11808,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:12864,Integrability,integrat,integration,12864,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13006,Integrability,integrat,integration,13006,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13481,Integrability,integrat,integrated,13481,"espect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and method",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14324,Integrability,interface,interface,14324,"cribed here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The com",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14851,Integrability,wrap,wrapper,14851,"d for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal canno",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:4582,Modifiability,evolve,evolve,4582,"or equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_0}\) to \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} \ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [2]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate s",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:6450,Modifiability,variab,variables,6450,"target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:6564,Modifiability,variab,variable,6564,"target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimis",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:6817,Modifiability,variab,variables,6817,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:6885,Modifiability,variab,variable,6885,". The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossib",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:7191,Modifiability,variab,variable,7191," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:8361,Modifiability,variab,variables,8361,"ocal peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9382,Modifiability,variab,variable,9382,"ith respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performi",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13564,Modifiability,variab,variable,13564,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13840,Modifiability,extend,extended,13840,"ws for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14077,Modifiability,config,configurability,14077,"ing errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14239,Modifiability,flexible,flexible,14239,"te implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14580,Modifiability,config,configuration,14580,"ptimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14804,Modifiability,config,configuration,14804," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:17541,Modifiability,config,configuration,17541,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:18073,Modifiability,config,configure,18073,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:10335,Performance,perform,performing,10335,"o store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:11337,Performance,optimiz,optimize,11337,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:12957,Performance,optimiz,optimization,12957,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13524,Performance,optimiz,optimize,13524,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:13546,Performance,perform,perform,13546,"-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hol",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14745,Performance,load,loadparams,14745," described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14872,Performance,optimiz,optimize,14872,"his section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14896,Performance,perform,perform,14896,"his section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:15976,Performance,perform,performed,15976,"s. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised.; TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradie",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:17316,Performance,perform,performance,17316,"onvenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:6691,Usability,simpl,simplest,6691,"e of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches ze",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:7135,Usability,clear,clearly,7135," phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:9593,Usability,simpl,simple,9593,"The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14296,Usability,simpl,simple,14296,"cribed here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The com",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:14565,Usability,simpl,simply,14565,"ptimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplect",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:16249,Usability,simpl,simply,16249,"erators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised.; TerminationConditions; This is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity,",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:17404,Usability,simpl,simplest,17404,"rget infidelity.; Stats; Performance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme pro",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-control.html:17912,Usability,simpl,simply,17912,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:2611,Availability,avail,available,2611,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a ",MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:13637,Deployability,update,updated,13637,"(bunched photons, they tend to appear together), and for a Fock state with \(n\) photons \(g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1\) and it increases with time (anti-bunched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_4op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(\tau)D(0)\right>\) (four operators, one delay-time vector).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and fock state.; import numpy as np; import pylab as plt; from qutip import *. N = 25; taus = np.linspace(0, 25.0, 200); a = destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [{'state': coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': thermal_dm(N, 2), 'label': ""thermal state""},; {'state': fock_dm(N, 2), 'label': ""Fock state""}]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). (Source code, png, hires.png, pdf). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:5655,Energy Efficiency,power,power,5655,,MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:6246,Energy Efficiency,power,power,6246,,MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:7351,Energy Efficiency,power,power,7351,"d atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the",MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:1163,Modifiability,evolve,evolved,1163,"tors; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:6440,Modifiability,coupling,coupling,6440,,MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-correlation.html:5945,Performance,perform,performs,5945,,MatchSource.WIKI,docs/4.3/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-correlation.html
https://qutip.org/docs/4.3/guide/guide-dynamics.html:2272,Deployability,update,updated,2272,"ts; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html
https://qutip.org/docs/4.3/guide/guide-dynamics.html:444,Integrability,depend,dependent,444,. . Time Evolution and Quantum System Dynamics — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theor,MatchSource.WIKI,docs/4.3/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html
https://qutip.org/docs/4.3/guide/guide-dynamics.html:1433,Integrability,depend,dependent,1433,"ts; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html
https://qutip.org/docs/4.3/guide/guide-dynamics.html:1882,Integrability,depend,dependent,1882,"ts; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:8254,Deployability,update,updated,8254,"2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[-1. 0.]; [ 0. 1.]]; Exponent #1 = 0j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. or by evaluating it and arbitrary points in time (here at 0.0 and 1.0):; In [19]: es.value([0.0, 1.0]); Out[19]: ; array([Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 1.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.63212056 0. ]; [0. 0.36787944]]], dtype=object). and the expectation value of the exponential series can be calculated using the qutip.expect function:; In [20]: es_expect = expect(sigmaz(), es). The result es_expect is now an exponential series with c-numbers as amplitudes, which easily can be evaluated at arbitrary times:; In [21]: es_expect.value([0.0, 1.0, 2.0, 3.0]); Out[21]: array([-1. , 0.26424112, 0.72932943, 0.90042586]). In [22]: times = linspace(0.0, 10.0, 100). In [23]: sz_expect = es_expect.value(times). In [24]: from pylab import *. In [25]: plot(times, sz_expect, lw=2);. In [26]: xlabel(""Time"", fontsize=16); ....: ylabel(""Expectation value of sigma-z"", fontsize=16);; ....: . In [28]: title(""The expectation value of the $\sigma_{z}$ operator"", fontsize=16);. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:437,Integrability,depend,dependent,437,". . An Overview of the Eseries Class — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:998,Integrability,depend,dependent,998,"tum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:1117,Integrability,depend,dependent,1117,"tum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:2048,Integrability,depend,dependent,2048,"t in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum objec",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:3975,Integrability,depend,dependent,3975,"ue; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [6]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[6]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [7]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [8]: esval(es2, times) # equivalent to es2.value(times); Out[8]: ; array([Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 1.]; [1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [9]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ...: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ...: . In [10]: rho = fock_dm(2, 1). In [11]: es3_expect = expect(rho, es3). In [12]: es3_expect; Out[12]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = (-0-1j); (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:1223,Modifiability,parameteriz,parameterized,1223,"es; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:5627,Modifiability,evolve,evolve,5627,"nt #1 = 1j; (-0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); ",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:5756,Modifiability,evolve,evolved,5756,,MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:5842,Performance,perform,performed,5842,,MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-eseries.html:2138,Usability,simpl,simply,2138,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.5]; [0.5 0. ]]. and we can e",MatchSource.WIKI,docs/4.3/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html
https://qutip.org/docs/4.3/guide/guide-overview.html:1651,Availability,avail,available,1651," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:1965,Deployability,update,updated,1965," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:1737,Security,access,accessible,1737," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:829,Usability,guid,guide,829,"﻿. . Guide Overview — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built wit",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:918,Usability,guid,guide,918,"﻿. . Guide Overview — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built wit",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:1127,Usability,guid,guide,1127," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-overview.html:1265,Usability,guid,guide,1265," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:6809,Deployability,configurat,configurations,6809,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:7376,Deployability,update,updated,7376,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:7122,Energy Efficiency,power,powerful,7122,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:1488,Modifiability,variab,variables,1488,"tum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:1537,Modifiability,variab,variables,1537,"tum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:6809,Modifiability,config,configurations,6809,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:1222,Performance,perform,performing,1222,"ects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:1300,Performance,perform,performed,1300,"um System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:5365,Performance,perform,performance,5365,".parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; In [20]: def sum_diff(x, y, z=0): return x + y, x - y, z. In [21]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); Out[21]: [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. In [22]: parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-parfor.html:2536,Safety,avoid,avoid,2536," example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); ",MatchSource.WIKI,docs/4.3/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html
https://qutip.org/docs/4.3/guide/guide-random.html:2577,Availability,down,down,2577,"08160606+0.47629143j 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.1919832 -0.22178051j 0.28831061-0.27313483j]; [-0.07903194-0.04842048j 0. +0.j 0. +0.j; 0.42183113+0.00672673j 0.81327946-0.46667892j]; [-0.08160606-0.47629143j -0.1919832 +0.22178051j 0.42183113-0.00672673j; 0. +0.j 0.32721563-0.41352091j]; [ 0. +0.j 0.28831061+0.27313483j 0.81327946+0.46667892j; 0.32721563+0.41352091j 0.8523009 +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print rand_super_bcsz(7).dims; File ""<ipython-input-2-ab0324dc4f28>"", line 1; print rand_super_bcsz(7).dims; ^; SyntaxError: invalid syntax. In [3]: print rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; ",MatchSource.WIKI,docs/4.3/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-random.html
https://qutip.org/docs/4.3/guide/guide-random.html:9597,Deployability,update,updated,9597,,MatchSource.WIKI,docs/4.3/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-random.html
https://qutip.org/docs/4.3/guide/guide-random.html:1103,Testability,test,testing,1103,"ting Random Quantum States & Operators — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; In [1]: rand_herm(5); Out[1]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0. +0.j 0. +0.j -0.07903194+0.04842048j; -0.08160606+0.47629143j 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.1919832 -0.22178051j 0.28831061-0.27313483j]; [-0.07903194-0.04842048j 0. +0.j 0. +0.j; 0.42183113+0.00672673j 0.81327946-0.46667892j]; [-0.08160606-0.47629143j -0.1919832 +0.22178051j 0.42183113-0.00672673j; 0. +0.j 0.32721563-0.41352091j]; [ 0. +0.j 0.28831061+0.27313483j 0.81327946+0.46667892j; 0.32721563+0.41352091j 0.8523009 +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); ran",MatchSource.WIKI,docs/4.3/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-random.html
https://qutip.org/docs/4.3/guide/guide-saving.html:8894,Deployability,update,updated,8894," this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.6870391934,1.1374497054,-0.2951078367; 1.0101010101,2.9640773506,0.1508687185,-0.7403170813; 2.0202020202,2.4767636492,-0.4453067188,-0.3988135953; 3.0303030303,2.1208678804,-0.4752005651,0.1465727136. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.6870391934e+00,1.1374497054e+00,-2.9510783673e-01; 1.0101010101e+00,2.9640773506e+00,1.5086871853e-01,-7.4031708128e-01; 2.0202020202e+00,2.4767636492e+00,-4.4530671880e-01,-3.9881359529e-01; 3.0303030303e+00,2.1208678804e+00,-4.7520056508e-01,1.4657271365e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:601,Performance,load,loading,601,". . Saving QuTiP Objects and Data Sets — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:636,Performance,load,loading,636,". . Saving QuTiP Objects and Data Sets — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:1409,Performance,perform,performed,1409,"l Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file ",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:1583,Performance,load,loading,1583,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further c",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:1620,Performance,load,load,1620,"jects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further c",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:2043,Performance,load,loads,2043,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for exampl",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:2582,Performance,load,loaded,2582,"qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: ex",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:2999,Performance,load,load,2999,"p.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only unde",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:3394,Performance,load,loaded,3394,"3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:3866,Performance,load,loading,3866,"61. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [9]: psi0 = rand_ket(10). In [10]: times = np.linspace(0, 10, 10). In [11]: dm_list = mesolve(H, psi0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the v",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:4250,Performance,load,load,4250,"si0, times, c_ops, []). In [12]: qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program:; In [13]: dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0. In [14]: a = destroy(10). In [15]: expect(a.dag() * a, dm_list_loaded.states); Out[15]: ; array([4.40942767, 3.44132235, 2.80622054, 2.3433275 , 2.00107858,; 1.74653819, 1.55662702, 1.41466358, 1.30841238, 1.22882551]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="",""). where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does:; In [16]: a =",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:8339,Performance,load,loaded,8339," this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.6870391934,1.1374497054,-0.2951078367; 1.0101010101,2.9640773506,0.1508687185,-0.7403170813; 2.0202020202,2.4767636492,-0.4453067188,-0.3988135953; 3.0303030303,2.1208678804,-0.4752005651,0.1465727136. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.6870391934e+00,1.1374497054e+00,-2.9510783673e-01; 1.0101010101e+00,2.9640773506e+00,1.5086871853e-01,-7.4031708128e-01; 2.0202020202e+00,2.4767636492e+00,-4.4530671880e-01,-3.9881359529e-01; 3.0303030303e+00,2.1208678804e+00,-4.7520056508e-01,1.4657271365e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-saving.html:2145,Usability,simpl,simple,2145,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345061. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0",MatchSource.WIKI,docs/4.3/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-saving.html
https://qutip.org/docs/4.3/guide/guide-settings.html:1376,Availability,toler,tolerance,1376,"ries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a f",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:1818,Availability,toler,tolerance,1818,"Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possib",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:3310,Deployability,update,updated,3310,"alue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:3023,Integrability,depend,dependent,3023,"alue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:2485,Performance,load,loaded,2485,"alue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:1880,Usability,simpl,simple,1880,"ifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-settings.html:2657,Usability,simpl,simple,2657,"alue > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-settings.html
https://qutip.org/docs/4.3/guide/guide-states.html:14000,Availability,down,downarrow,14000,"ed, let us use the qutip.operators.sigmaz operator:; In [51]: sigmaz(); Out[51]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [52]: sigmaz() * spin; ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:14697,Availability,down,downarrow,14697," answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:14963,Availability,down,downarrow,14963,"esponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:16896,Availability,down,down,16896," arrays of state vectors or density matrices for the second input:; In [67]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:16987,Availability,down,down,16987,"**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:37579,Deployability,update,updated,37579," be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; In [139]: J = rho_out. In [140]: J.dims = [[[2], [2]], [[2], [2]]]; .....: J.superrep = 'choi'; .....: . In [142]: print(J.iscp); False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; In [143]: print(J.ishp); True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; In [144]: print(J.ishp); True. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true.; In [145]: print(J.iscptp); False. In [146]: print(to_super(qeye(2)).iscptp); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:11451,Energy Efficiency,energy,energy,11451,"0000053282376. In [39]: tracedist(y, y); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:3753,Integrability,depend,dependence,3753," [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 * vac).unit(); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:20367,Modifiability,extend,extended,20367,"s matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:1297,Performance,perform,performing,1297,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5]: ; Quant",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:34804,Performance,perform,perform,34804," 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; In [134]: print(average_gate_fidelity(S)); 0.9499999999999998. In [135]: print(chi[0, 0] / 4); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:20205,Security,expose,exposed,20205,"s = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. In [103]: S = (12 * L).expm(). For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:1119,Usability,guid,guide,1119," Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:1274,Usability,guid,guide,1274,"s; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5]: ; Quant",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:7564,Usability,simpl,simplest,7564,"c; Out[26]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. In [27]: d * s * vac; Out[27]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is not longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; In [28]: ket = basis(5, 2). In [29]: ket * ket.dag(); Out[29]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; In [30]: fock_dm(5, 2); Out[30]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. In [31]: ket2dm(ket); Out[31]: ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number states we can do the",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:23723,Usability,simpl,simply,23723,"repost(X, X). In [106]: J = to_choi(S). In [107]: print(J); Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. In [108]: print(to_choi(spre(qeye(2)))); ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-states.html:35967,Usability,simpl,simply,35967," \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; In [136]: rho = ket2dm(bell_state()). In [137]: rho_out = partial_transpose(rho, [0, 1]); .....: print(rho_out.eigenenergies()); .....: ; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; In [139]: J = rho_out. In [140]: J.dims = [[[2], [2]], [[2], [2]]]; .....: J.superrep = 'choi'; .....: . In [142]: print(J.iscp); False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; In [143]: print(J.ishp); True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can ",MatchSource.WIKI,docs/4.3/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html
https://qutip.org/docs/4.3/guide/guide-steady.html:5488,Availability,down,downside,5488,"n be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:6835,Availability,error,error,6835,"ate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:7431,Availability,avail,available,7431,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted ",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:11714,Deployability,update,updated,11714,"upled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equation', 'Steady State')); plt.title('Decay of Fock state $\left|10\\rangle\\right.$' +; ' in a thermal environment with $\langle n\\rangle=2$'); plt.show(). (Source code, png, hires.png, pdf). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:2466,Energy Efficiency,power,power,2466,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:2498,Energy Efficiency,power,power,2498,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:3339,Energy Efficiency,power,power,3339,"teratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory nee",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:4604,Energy Efficiency,reduce,reduced,4604,"essary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these it",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:4906,Energy Efficiency,power,power,4906,"m with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditi",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:4943,Energy Efficiency,power,power,4943,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:4990,Energy Efficiency,power,power,4990,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:5128,Energy Efficiency,power,power,5128,"e solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:7553,Energy Efficiency,power,power,7553,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a i",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:5064,Integrability,rout,routine,5064,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:10388,Modifiability,coupling,coupling,10388,"the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equatio",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:3540,Performance,perform,performance,3540,"MRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) ",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:8776,Performance,perform,perform,8776,"ng factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:10060,Performance,perform,perform,10060,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:1754,Usability,simpl,simple,1754," Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Important; Updated in QuTiP 3.2. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution v",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-steady.html:9583,Usability,simpl,simple,9583,"less explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = ka",MatchSource.WIKI,docs/4.3/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:3077,Availability,down,down,3077,"und states is formed by taking the tensor product of the two single-qubit ground state vectors:; In [1]: tensor(basis(2, 0), basis(2, 0)); Out[1]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tenso",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:12260,Deployability,update,updated,12260,"3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:4560,Energy Efficiency,energy,energy,4560," 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:4714,Energy Efficiency,energy,energy,4714,"ly on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:6182,Energy Efficiency,energy,energy,6182,"(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:6792,Energy Efficiency,reduce,reduces,6792,"25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [18]: psi = tensor(basis(2, 0), basis(2, 1)). In [19]: psi.ptrace(0); Out[19]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. In [20]: psi.ptrace(1); ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:11702,Integrability,contract,contracting,11702,"3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:11772,Integrability,contract,contraction,11772,"3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:3175,Modifiability,extend,extended,3175,"ct: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0.",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:6078,Modifiability,coupling,coupling,6078,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:10620,Performance,perform,performs,10620,"{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; In [27]: A = qeye([2]). In [28]: B = qeye([3]). In [29]: to_super(tensor(A, B)).dims; Out[29]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:4435,Usability,simpl,simple,4435," qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tens",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-tensor.html:5934,Usability,simpl,simplest,5934,"; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of",MatchSource.WIKI,docs/4.3/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html
https://qutip.org/docs/4.3/guide/guide-visualization.html:11370,Availability,error,errors,11370,"]; ....: for k in range(len(lbls_list))])); ....: . In [71]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: fig, ax = hinton(rho_ss) # xlabels=xlabels, ylabels=xlabels). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,docs/4.3/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-visualization.html
https://qutip.org/docs/4.3/guide/guide-visualization.html:15860,Deployability,update,updated,15860,"Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [77]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [78]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [79]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [80]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [81]: chi = qpt(U_rho, op_basis). In [82]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [83]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-visualization.html
https://qutip.org/docs/4.3/guide/guide-visualization.html:15632,Integrability,depend,dependent,15632,"Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [77]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [78]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [79]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [80]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [81]: chi = qpt(U_rho, op_basis). In [82]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [83]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-visualization.html
https://qutip.org/docs/4.3/guide/guide-visualization.html:1600,Performance,perform,perform,1600,"er function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/4.3/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-visualization.html
https://qutip.org/docs/4.3/guide/guide-visualization.html:12713,Security,access,access,12713,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/4.3/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-visualization.html
https://qutip.org/docs/4.3/guide/guide.html:3112,Deployability,update,updated,3112,"r Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html
https://qutip.org/docs/4.3/guide/guide.html:1503,Integrability,depend,dependent,1503,"processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-proba",MatchSource.WIKI,docs/4.3/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html
https://qutip.org/docs/4.3/guide/guide.html:1908,Integrability,depend,dependent,1908,"ating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Set",MatchSource.WIKI,docs/4.3/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html
https://qutip.org/docs/4.3/guide/guide.html:2704,Performance,load,loading,2704,"r Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html
https://qutip.org/docs/4.3/guide/guide.html:2739,Performance,load,loading,2739,"r Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/guide.html
https://qutip.org/docs/4.3/modules/index.html:292,Availability,avail,available,292,". . Overview: module code — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/index.html
https://qutip.org/docs/4.3/modules/index.html:1665,Deployability,update,updated,1665,". . Overview: module code — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/index.html
https://qutip.org/docs/4.3/modules/index.html:460,Performance,optimiz,optimizer,460,". . Overview: module code — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/index.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:2791,Availability,down,downside,2791,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:3161,Availability,robust,robust,3161,"ten desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hb",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:5371,Deployability,integrat,integration,5371,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:19973,Deployability,update,updated,19973,"this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:2025,Energy Efficiency,energy,energy,2025,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:2325,Energy Efficiency,power,power,2325,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:8084,Energy Efficiency,power,power,8084,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:8366,Energy Efficiency,energy,energy,8366," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\bet",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:9265,Energy Efficiency,power,power,9265,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nest",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:14869,Energy Efficiency,efficient,efficient,14869,"e; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15016,Energy Efficiency,efficient,efficient,15016,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any oth",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15174,Energy Efficiency,power,power,15174,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling ter",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15576,Energy Efficiency,power,power,15576,"s greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:18417,Energy Efficiency,power,power,18417,,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:432,Integrability,depend,dependent,432,". . Bloch-Redfield master equation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for examp",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:582,Integrability,depend,dependent,582,". . Bloch-Redfield master equation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for examp",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:4780,Integrability,depend,depends,4780," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath deca",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:5321,Integrability,depend,dependence,5321,"; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:5371,Integrability,integrat,integration,5371,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:13807,Integrability,depend,dependent,13807,"7]: tlist = np.linspace(0, 15.0, 1000). In [8]: psi0 = rand_ket(2). In [9]: e_ops = [sigmax(), sigmay(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as oppos",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:13945,Integrability,depend,dependent,13945,"(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:14211,Integrability,depend,dependent,14211,"rray([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:14462,Integrability,depend,dependent,14462,".mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:14961,Integrability,depend,dependent,14961,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any oth",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15083,Integrability,depend,dependent,15083,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any oth",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15147,Integrability,depend,dependent,15147,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling ter",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15305,Integrability,depend,dependent,15305," equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate dec",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15624,Integrability,depend,dependent,15624,"s greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15898,Integrability,depend,dependent,15898,"he super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15948,Integrability,depend,dependent,15948,"ient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16149,Integrability,depend,dependent,16149,"-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16433,Integrability,depend,dependent,16433,"rmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:17928,Integrability,depend,dependence,17928,"[22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:18442,Integrability,depend,dependence,18442,,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:19771,Integrability,depend,dependent,19771,"this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:2637,Modifiability,coupling,coupling,2637,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:5357,Modifiability,extend,extending,5357,"ho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:10347,Modifiability,coupling,coupling,10347,"ectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument.; To illustrate how to calculate the Bloch-Redfield tensor, let’s consider a two-level atom. (8)¶\[ H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z\]; that couples to an Ohmic bath through the \(\sigma_x\) operator. The corresponding Bloch-Redfield tensor can be calculated in QuTiP using the following code; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. In [2]: H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: def ohmic_spectrum(w):; ...: if w == 0.0: # dephasing inducing noise; ...: return gamma1; ...: else: # relaxation inducing noise; ...: return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0); ...: . In [4]: R, ekets = bloch_redfield_tensor(H, [[sigmax(), ohmic_spectrum]]). In [5]: R; Out[5]: ; Quantum object: dims = [[[2],",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16164,Modifiability,coupling,coupling,16164,"-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16543,Modifiability,coupling,coupling,16543,"nt, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16607,Modifiability,coupling,coupling,16607,"nto time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:16987,Modifiability,coupling,coupling,16987,"an be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:17714,Modifiability,coupling,coupling,17714,"efinition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:18304,Modifiability,coupling,coupling,18304,"]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:14716,Performance,scalab,scalability,14716,"gmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python fu",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:15743,Safety,avoid,avoid,15743,"he super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:1815,Usability,clear,clear,1815,"h Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:9370,Usability,simpl,simplify,9370," =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single ar",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:6475,Deployability,update,updated,6475,"s = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:512,Integrability,depend,dependent,512,". . Dynamics Simulation Results — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation.",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:3199,Security,access,access,3199,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:4245,Security,access,access,4245,"o not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qut",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:4754,Security,access,accessed,4754,"solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:1349,Usability,simpl,simplified,1349,"sing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating w",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:3262,Usability,guid,guide,3262,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:3438,Usability,simpl,simply,3438," used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-styl",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:5182,Usability,simpl,simplicity,5182,"lo solver.; Now we have all the information needed to analyze the simulation results. To access the data for the two expectation values one can do:; >>> expt0 = result.expect[0]; >>> expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; >>> times = result.times. we can plot the resulting expectation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_r",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1338,Deployability,integrat,integration,1338,"d Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:19493,Deployability,update,updated,19493,"omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, but using:; output = fmmesolve(H, psi0, tlist, [sigmax()], [num(2)], [noise_spectrum], T, args); p_ex = output.expect[0]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1569,Energy Efficiency,efficient,efficiently,1569,"ve evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:13318,Energy Efficiency,efficient,efficiently,13318,"floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_mo",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:13471,Energy Efficiency,efficient,efficiently,13471,"ulate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:17828,Energy Efficiency,power,power,17828,". Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:420,Integrability,depend,dependent,420,"﻿. . Floquet Formalism — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in parti",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1224,Integrability,depend,dependent,1224,"nsor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1338,Integrability,integrat,integration,1338,"d Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1404,Integrability,depend,dependent,1404,"d Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1936,Integrability,depend,dependent,1936," Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:2098,Integrability,depend,dependent,2098,"ers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordi",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:2204,Integrability,depend,dependent,2204,"lism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:2510,Integrability,depend,dependent,2510,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but o",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:2738,Integrability,depend,dependent,2738," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:2942,Integrability,depend,dependence,2942,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:4802,Integrability,depend,dependent,4802,"\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)¶\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:6381,Integrability,depend,dependent,6381,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi. In [2]: H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: H1 = A/2.0 * sigmaz(). In [4]: args = {'w': omega}. In [5]: H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; In [6]: T = 2*pi / omega. In [7]: f_modes_0, f_energies = floquet_modes(H, T, args). In [8]: f_energies; Out[8]: array([-2.83131211, 2.83131211]). In [9]: f_modes_0; ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:12012,Integrability,depend,dependent,12012,"ition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; In [30]: t = 10 * np.random.rand(). In [31]: psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). In [32]: psi_t; Out[32]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.0286042 +0.65485059j]; [-0.62145609+0.42912101j]]. The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; from qutip import *; from scipy import *. delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.5 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:13918,Integrability,depend,dependent,13918,"e period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Note th",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:15672,Integrability,depend,dependent,15672,"gs).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using:; output = fsesolve(H, psi0, times, [num(2)], args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:16281,Integrability,depend,dependent,16281,"results as in the examples above using:; output = fsesolve(H, psi0, times, [num(2)], args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solve",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:17960,Integrability,depend,dependent,17960,"e spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lind",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:16637,Modifiability,coupling,coupling,16637,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:16920,Modifiability,coupling,coupling,16920,"he Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi).",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:17368,Modifiability,extend,extends,17368," list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=comple",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:15910,Deployability,update,updated,15910,"anta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code; In [30]: times = np.linspace(0.0, 10.0, 200). In [31]: psi0 = tensor(fock(2,0), fock(10, 5)). In [32]: a = tensor(qeye(2), destroy(10)). In [33]: sm = tensor(destroy(2), qeye(10)). In [34]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [35]: result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]). In [36]: figure(); Out[36]: <Figure size 640x480 with 0 Axes>. In [37]: plot(times, result.expect[0]); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:2701,Energy Efficiency,efficient,efficient,2701,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:6754,Energy Efficiency,energy,energy,6754,"esult.times, result.expect[0]);. In [13]: ax.plot(result.times, result.expect[1]);. In [14]: ax.set_xlabel('Time');. In [15]: ax.set_ylabel('Expectation values');. In [16]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [17]: show(). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; In [18]: times = [0.0, 1.0]. In [19]: result = mesolve(H, psi0, times, [], []). In [20]: result.states; Out[20]: ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:8526,Energy Efficiency,reduce,reduced,8526,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that th",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:10561,Energy Efficiency,energy,energy,10561," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:11143,Energy Efficiency,energy,energy,11143,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems)",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:11356,Energy Efficiency,energy,energy,11356,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation a",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:13140,Energy Efficiency,energy,energy,13140,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; In [21]: times = np.linspace(0.0, 10.0, 100). In [22]: result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]). In [23]: fig, ax = subplots(). In [24]: ax.plot(times, result.expect[0]);. In [25]: ax.plot(times, result.expect[1]);. In [26]: ax.set_xlabel('Time');. In [27]: ax.set_ylabel('Expectation values');. In [28]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [29]: show(fig). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-phot",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:505,Integrability,depend,dependent,505,". . Lindblad Master Equation Solver — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This mat",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:3206,Modifiability,evolve,evolves,3206,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; In [1]: H = 2 * np.pi * 0.1 * sigmax(). In [2]: psi0 = basis(2, 0). In [3]: times = np.linspace(0.0, 10.0, 20.0). In [4]: result = mesolve(H, psi0, times, [], [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:2131,Performance,perform,perform,2131,"ter Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:8236,Performance,perform,perform,8236,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:9200,Performance,perform,perform,9200,"ics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:2715,Security,access,accessible,2715,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:12871,Availability,error,errors,12871," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.78s. Est. time left: 00:00:00:25; 20.0%. Run time: 5.59s. Est. time left: 00:00:00:22; 30.0%. Run time: 8.32s. Est. time left: 00:00:00:19; 40.0%. Run time: 11.10s. Est. time left: 00:00:00:16; 50.0%. Run time: 13.85s. Est. time left: 00:00:00:13; 60.0%. Run time: 16.62s. Est. time left: 00:00:00:11; 70.0%. Run time: 19.38s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.11s. Est. time left: 00:00:00:05; 90.0%. Run time: 24.81s. Est. time left: 00:00:00:02; 100.0%. Run time: 27.67s. Est. time left: 00:00:00:00; Total run time: 27.72s. where we have ad",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:15818,Availability,avail,available,15818,"mes, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.88s. Est. time left: 00:00:00:23; 30.0%. Run time: 8.77s. Est. time left: 00:00:00:20; 40.0%. Run time: 11.55s. Est. time left: 00:00:00:17; 50.0%. Run time: 14.41s. Est. time left: 00:00:00:14; 60.0%. Run time: 17.20s. Est. time left: 00:00:00:11; 70.0%. Run time: 20.03s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.99s. Est. time left: 00:00:00:05; 90.0%. Run time: 26.27s. Est. time left: 00:00:00:02; 100.0%. Run time: 29.58s. Est. time left: 00:00:00:00; Total run time: 29.68s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Option",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16189,Availability,down,down,16189,"0:00:00:14; 60.0%. Run time: 17.20s. Est. time left: 00:00:00:11; 70.0%. Run time: 20.03s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.99s. Est. time left: 00:00:00:05; 90.0%. Run time: 26.27s. Est. time left: 00:00:00:02; 100.0%. Run time: 29.58s. Est. time left: 00:00:00:00; Total run time: 29.68s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:1453,Deployability,continuous,continuously,1453,"l Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16540,Deployability,configurat,configuration,16540,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.78s. Est. time left: 00:00:00:15; 20.0%. Run time: 3.93s",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:25388,Deployability,update,updated,25388,,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:1466,Energy Efficiency,monitor,monitored,1466,"l Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:11871,Energy Efficiency,efficient,efficient,11871,"how(). The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:456,Integrability,depend,dependent,456,". . Monte Carlo Solver — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negati",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:25162,Integrability,depend,dependent,25162,,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:25217,Integrability,depend,dependent,25217,,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16540,Modifiability,config,configuration,16540,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.78s. Est. time left: 00:00:00:15; 20.0%. Run time: 3.93s",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:4820,Performance,perform,performed,4820," system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.31s. Est. time left: 00:00:00:11; 20.0%. Run time: 2.60s. Est. time left: 00:00:00:10; 30.0%. Run time: 3.91s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.26s. Est. time left: 00:00:00:07; 50.0%. Run time: 6.64s. Est. time left: 00:00:00:06; 60.0%. Run ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:13183,Usability,simpl,simply,13183,"r state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.78s. Est. time left: 00:00:00:25; 20.0%. Run time: 5.59s. Est. time left: 00:00:00:22; 30.0%. Run time: 8.32s. Est. time left: 00:00:00:19; 40.0%. Run time: 11.10s. Est. time left: 00:00:00:16; 50.0%. Run time: 13.85s. Est. time left: 00:00:00:13; 60.0%. Run time: 16.62s. Est. time left: 00:00:00:11; 70.0%. Run time: 19.38s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.11s. Est. time left: 00:00:00:05; 90.0%. Run time: 24.81s. Est. time left: 00:00:00:02; 100.0%. Run time: 27.67s. Est. time left: 00:00:00:00; Total run time: 27.72s. where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converg",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16199,Usability,simpl,simpler,16199,"0:00:00:14; 60.0%. Run time: 17.20s. Est. time left: 00:00:00:11; 70.0%. Run time: 20.03s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.99s. Est. time left: 00:00:00:05; 90.0%. Run time: 26.27s. Est. time left: 00:00:00:02; 100.0%. Run time: 29.58s. Est. time left: 00:00:00:00; Total run time: 29.68s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:2083,Availability,toler,tolerance,2083,ynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average ,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:2123,Availability,toler,tolerance,2123,ics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:3250,Availability,toler,tolerance,3250,"iff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, opti",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:2716,Deployability,install,installed,2716,"eps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: Fa",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:4514,Deployability,update,updated,4514," by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:442,Integrability,depend,dependent,442,. . Setting Options for the Dynamics Solvers — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options =,MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:2853,Integrability,depend,dependent,2853,"pect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:3484,Modifiability,variab,variable,3484,"p size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:6243,Deployability,update,updated,6243,"cs” section in the tutorials section of the website, http://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective spin \(J_+\); jspin(N, ""+""); The collective spin operator \(J_+\). Collective spin \(J_-\); jspin(N, ""-""); The collective spin operator \(J_-\). Collective spin \(J_z\) in uncoupled basis; jspin(N, ""z"", basis='uncoupled'); The collective spin operator \(J_z\) in the uncoupled basis of dimension \(2^N\). Dicke state \(|j,m\rangle\) density matrix; dicke(N, j, m); The density matrix for the Dicke state given by \(|j,m\rangle\). Excited-state density matrix in Dicke basis; excited(N); The excited state in the Dicke basis. Excited-state density matrix in uncoupled basis; excited(N, basis=""uncoupled""); The excited state in the uncoupled basis. Ground-state density matrix in Dicke basis; ground(N); The ground state in the Dicke basis. GHZ-state density matrix in the Dicke basis; ghz(N); The GHZ-state density matrix in the Dicke (default) basis for N number of TLS. Collapse operators of the ensemble; Dicke.c_ops(); The collapse operators for the ensemble can be called by the c_ops method of the Dicke class. More functions relative to the qutip.piqs module can be found at API documentation. Attributes to the qutip.piqs.Dicke and qutip.piqs.Pim class can also be found there. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:427,Integrability,depend,dependent,427,"﻿. . Permutational Invariance — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\frac{i}{\hbar}\lbrack H,\rho \rbrack; +\frac{\gamma_\text{CE}}{2}\mathc",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:3077,Usability,simpl,simply,3077,"{2}\mathcal{L}_{J_{+}}[\rho]\\+\sum_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; fr",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:3224,Usability,simpl,simply,3224,"\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html:3949,Usability,simpl,simply,3949,"gonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the “Permutational Invariant Lindblad Dynamics” section in the tutorials section of the website, http://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective spi",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13372,Availability,error,errors,13372,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 A",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:11712,Deployability,install,installed,11712,".exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:11796,Deployability,install,installing,11796,"ef H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:22991,Deployability,update,updated,22991,"[77]: H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']. In [78]: H_td = [H0, H1]. In [79]: Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; In [80]: opts = Options(rhs_reuse=True). In [81]: rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; In [82]: def task(args):; ....: m, eps = args; ....: p_mat_m = np.zeros(len(A_list)); ....: for n, A in enumerate(A_list):; ....: # change args sent to solver, w is really a constant though.; ....: Hargs = {'w': w, 'eps': eps,'A': A}; ....: U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; ....: rho_ss = propagator_steadystate(U); ....: p_mat_m[n] = expect(sn, rho_ss); ....: return [m, p_mat_m]; ....: . Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:3154,Energy Efficiency,efficient,efficient,3154,"uTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the f",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4532,Energy Efficiency,efficient,efficient,4532,"ollowing functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:32,Integrability,depend,dependent,32,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of h",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:452,Integrability,depend,dependent,452,"﻿. . Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of h",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1424,Integrability,depend,dependent,1424," Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamilt",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1475,Integrability,depend,dependent,1475,"s; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1732,Integrability,depend,dependence,1732,"d master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1872,Integrability,depend,depend,1872,"d master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:2014,Integrability,depend,dependent,2014,"ontrol; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed v",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:2119,Integrability,depend,dependent,2119,"llel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:2249,Integrability,depend,dependent,2249,"tion; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmes",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:2483,Integrability,depend,dependent,2483,"ians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, i",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:2704,Integrability,depend,dependence,2704,"independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:3396,Integrability,depend,dependent,3396,"as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python functi",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:3524,Integrability,depend,dependent,3524,"tion with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this me",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4469,Integrability,depend,dependence,4469,"an think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pa",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4609,Integrability,depend,dependent,4609,"ollowing functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4727,Integrability,depend,dependent,4727,"j',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4821,Integrability,depend,dependent,4821,"j',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:4908,Integrability,depend,dependent,4908,"ed interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:5035,Integrability,depend,dependent,5035,"matical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of t",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:5119,Integrability,depend,dependent,5119,"matical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of t",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:5220,Integrability,depend,dependent,5220,". before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any ord",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:5799,Integrability,depend,dependent,5799,"ressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue =",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:5972,Integrability,depend,dependent,5972,"ion Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Ca",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:6088,Integrability,depend,dependent,6088,"ollapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic de",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:6145,Integrability,depend,dependent,6145,"e a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:6317,Integrability,depend,dependent,6317," To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:6400,Integrability,depend,dependent,6400," To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7758,Integrability,depend,dependent,7758," [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7807,Integrability,depend,dependent,7807,"(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:8084,Integrability,depend,dependents,8084," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:9844,Integrability,depend,dependent,9844,". Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:11837,Integrability,depend,dependent,11837,"* np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the abov",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:12069,Integrability,depend,dependent,12069," the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to re",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:12384,Integrability,depend,dependent,12384,", psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:12577,Integrability,depend,dependent,12577,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Depen",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13652,Integrability,depend,dependent,13652,")'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 Axes>. In [52]: plt.plot(t, func(t)); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13888,Integrability,depend,dependent,13888,"mat as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 Axes>. In [52]: plt.plot(t, func(t)); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:15843,Integrability,depend,dependent,15843," class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; In [55]: S = Cubic_Spline(t[0], t[-1], noisy_data). In [56]: plt.figure(); Out[56]: <Figure size 640x480 with 0 Axes>. In [57]: plt.plot(t, func(t)); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16275,Integrability,depend,dependent,16275,"<matplotlib.lines.Line2D at 0x1a27ede080>]. In [59]: plt.plot(t, S(t), lw=2); ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16558,Integrability,depend,dependent,16558,"]: [<matplotlib.lines.Line2D at 0x1a27ede048>]. In [60]: plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Es",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16775,Integrability,depend,dependent,16775," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:19177,Integrability,depend,dependent,19177,"time left: 00:00:00:01; 30.0%. Run time: 0.61s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 50.0%. Run time: 0.98s. Est. time left: 00:00:00:00; 60.0%. Run time: 1.15s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.33s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.51s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.67s. Est. time left: 00:00:00:00; 100.0%. Run time: 1.84s. Est. time left: 00:00:00:00; Total run time: 1.85s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:19310,Integrability,depend,dependent,19310,"0.98s. Est. time left: 00:00:00:00; 60.0%. Run time: 1.15s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.33s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.51s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.67s. Est. time left: 00:00:00:00; 100.0%. Run time: 1.84s. Est. time left: 00:00:00:00; Total run time: 1.85s. The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated. As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in th",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:20331,Integrability,depend,dependent,20331,"ms inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated. As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in the notebook “Time-dependent master equation: Landau-Zener-Stuckelberg inteferometry” in the tutorials section of the QuTiP web site.; To set up the problem, we run the following code:; In [67]: delta = 0.1 * 2 * np.pi # qubit sigma_x coefficient. In [68]: w = 2.0 * 2 * np.pi # driving frequency. In [69]: T = 2 * np.pi / w # driving period. In [70]: gamma1 = 0.00001 # relaxation rate. In [71]: gamma2 = 0.005 # dephasing rate. In [72]: eps_list = np.linspace(-10.0, 10.0, 51) * 2 * np.pi # epsilon. In [73]: A_list = np.linspace(0.0, 20.0, 51) * 2 * np.pi # Amplitude. In [74]: sx = sigmax(); sz = sigmaz(); sm = destroy(2); sn = num(2). In [75]: c_ops = [np.sqrt(gamma1) * sm, np.sqrt(gamma2) * sz] # relaxation and dephasing. In [76]: H0 = -delta / 2.0 * sx. In [77]: H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']. In [78]: H_td = [H0, H1]. In [79]: Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionar",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:22844,Integrability,rout,routine,22844,"[77]: H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']. In [78]: H_td = [H0, H1]. In [79]: Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; In [80]: opts = Options(rhs_reuse=True). In [81]: rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; In [82]: def task(args):; ....: m, eps = args; ....: p_mat_m = np.zeros(len(A_list)); ....: for n, A in enumerate(A_list):; ....: # change args sent to solver, w is really a constant though.; ....: Hargs = {'w': w, 'eps': eps,'A': A}; ....: U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; ....: rho_ss = propagator_steadystate(U); ....: p_mat_m[n] = expect(sn, rho_ss); ....: return [m, p_mat_m]; ....: . Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1807,Modifiability,coupling,coupling,1807,"d master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7604,Modifiability,coupling,coupling,7604,"d = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsol",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:8214,Modifiability,variab,variables,8214,"_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:9991,Modifiability,variab,variable,9991,"ime left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:10050,Modifiability,variab,variables,10050,"ime left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:10651,Modifiability,variab,variable,10651," ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Mon",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:11213,Modifiability,variab,variables,11213,"for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....: sig = args['sigma']; ....: return A * np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewrit",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13033,Modifiability,variab,variable,13033,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13088,Modifiability,rewrite,rewrite,13088,"Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = ",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13340,Modifiability,variab,variables,13340,"time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 A",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16785,Modifiability,variab,variables,16785," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16895,Safety,avoid,avoid,16895," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:3783,Testability,log,log,3783,"tion with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this me",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7960,Usability,simpl,simply,7960,"avity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02;",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:9467,Usability,simpl,simple,9467,"ma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword arg",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:9747,Usability,simpl,simple,9747," 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**",MatchSource.WIKI,docs/4.3/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.3/modules/qutip/about.html:4024,Deployability,update,updated,4024,"; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info; import qutip.settings; from qutip.hardware_info import hardware_info. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""Copyright (c) 2011 and later.""); print((""A. J. Pitchford, P. D. Nation, ""; ""R. J. Johansson, A. Grimsmo, ""; ""and C. Granade"")); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % hardware_info()['cpus']); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""==============================================================""; longbar += ""================""; cite_msg = ""For your convenience a bibtex file can be easily generated""; cite_msg += "" using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/about.html
https://qutip.org/docs/4.3/modules/qutip/about.html:2099,Integrability,depend,dependencies,2099,"f its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info; import qutip.settings; from qutip.hardware_info import hardware_info. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""Copyright (c) 2011 and later.""); print((""A. J. Pitchford, P. D. Nation, ""; ""R. J. Johansson, A. Grimsmo, ""; ""and C. Granade"")); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except:; matplotlib_ver = 'None'; print(""Mat",MatchSource.WIKI,docs/4.3/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/about.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:2407,Deployability,patch,patches,2407,"O EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange). from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, renderer.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer); except:; pass. [docs]class Bloch():; """"""Class for plotting data on the Bloch sphere. Valid data can be; either points, vectors, or qobj objects. Attributes; ----------. axes : instance {None}; User supplied Matplotlib axes for Bloch sphere animation.; fig : instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere.; font_color : str {'black'}; Color of font used for Bloch sphere labels.; font_size : int {20}; Size of font used for Bloch sphere labels.; frame_alpha : float {0.1}; Sets transparency of Bloch sphere frame.; frame_c",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:19850,Deployability,update,update,19850," 'm':; pnt_colors = array(self.point_color *; int(ceil(num / float(len(self.point_color))))). pnt_colors = pnt_colors[0:num]; pnt_colors = list(pnt_colors[indperm]); marker = self.point_marker[mod(k, len(self.point_marker))]; s = self.point_size[mod(k, len(self.point_size))]; self.axes.scatter(real(self.points[k][1][indperm]),; -real(self.points[k][0][indperm]),; real(self.points[k][2][indperm]),; s=s, alpha=1, edgecolor='none',; zdir='z', color=pnt_colors,; marker=marker). elif self.point_style[k] == 'l':; color = self.point_color[mod(k, len(self.point_color))]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=0.75, zdir='z',; color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets.; """"""; self.render(self.fig, self.axes); if self.fig:; plt.show(self.fig). [docs] def save(self, name=None, format='png', dirc=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(self.fig, self.axes); if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; self.fig.savefig(os.getcwd() + ""/"" + str(dirc) + '/bloch_' +; str(self.savenum) + '.' + format); el",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:21344,Deployability,update,updated,21344,")]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=0.75, zdir='z',; color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets.; """"""; self.render(self.fig, self.axes); if self.fig:; plt.show(self.fig). [docs] def save(self, name=None, format='png', dirc=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(self.fig, self.axes); if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; self.fig.savefig(os.getcwd() + ""/"" + str(dirc) + '/bloch_' +; str(self.savenum) + '.' + format); else:; self.fig.savefig(os.getcwd() + '/bloch_' + str(self.savenum) +; '.' + format); else:; self.fig.savefig(name); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:4362,Usability,simpl,simple,4362,"s transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_width : int {1}; Width of wireframe.; point_color : list {[""b"",""r"",""g"",""#CC6600""]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('b').; point_marker : list {[""o"",""s"",""d"",""^""]}; List of point marker shapes to cycle through.; point_size : list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!; sphere_alpha : float {0.2}; Transparency of Bloch sphere itself.; sphere_color : str {'#FFDDDD'}; Color of Bloch sphere.; figsize : list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {[""g"",""#CC6600"",""b"",""r""]}; List of vector colors to cycle through.; vector_width : int {5}; Width of displayed vectors.; vector_style : str {'-|>', 'simple', 'fancy', ''}; Vector arrowhead style (from matplotlib's arrow style).; vector_mutation : int {20}; Width of vectors arrowhead.; view : list {[-60,30]}; Azimuthal and Elevation viewing angles.; xlabel : list {[""$x$"",""""]}; List of strings corresponding to +x and -x axes labels, respectively.; xlpos : list {[1.1,-1.1]}; Positions of +x and -x labels respectively.; ylabel : list {[""$y$"",""""]}; List of strings corresponding to +y and -y axes labels, respectively.; ylpos : list {[1.2,-1.2]}; Positions of +y and -y labels respectively.; zlabel : list {[r'$\\left|0\\right>$',r'$\\left|1\\right>$']}; List of strings corresponding to +z and -z axes labels, respectively.; zlpos : list {[1.2,-1.2]}; Positions of +z and -z labels respectively. """"""; def __init__(self, fig=None, axes=None, view=None, figsize=None,; background=False):. # Figure and axes; self.fig = fig; self.axes = axes; # Background axes, default = False; self.background = background; # The size of the figure in inches, default = [5,5].; self.figsiz",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:6795,Usability,simpl,simple,6795,"= 1; self.frame_width = 1; # Transparency of wireframe, default = 0.2; self.frame_alpha = 0.2; # Labels for x-axis (in LaTex), default = ['$x$', '']; self.xlabel = ['$x$', '']; # Position of x-axis labels, default = [1.2, -1.2]; self.xlpos = [1.2, -1.2]; # Labels for y-axis (in LaTex), default = ['$y$', '']; self.ylabel = ['$y$', '']; # Position of y-axis labels, default = [1.1, -1.1]; self.ylpos = [1.2, -1.2]; # Labels for z-axis (in LaTex),; # default = [r'$\left|0\right>$', r'$\left|1\right>$']; self.zlabel = [r'$\left|0\right>$', r'$\left|1\right>$']; # Position of z-axis labels, default = [1.2, -1.2]; self.zlpos = [1.2, -1.2]; # ---font options---; # Color of fonts, default = 'black'; self.font_color = 'black'; # Size of fonts, default = 20; self.font_size = 20. # ---vector options---; # List of colors for Bloch vectors, default = ['b','g','r','y']; self.vector_color = ['g', '#CC6600', 'b', 'r']; #: Width of Bloch vectors, default = 5; self.vector_width = 3; #: Style of Bloch vectors, default = '-|>' (or 'simple'); self.vector_style = '-|>'; #: Sets the width of the vectors arrowhead; self.vector_mutation = 20. # ---point options---; # List of colors for Bloch point markers, default = ['b','g','r','y']; self.point_color = ['b', 'r', 'g', '#CC6600']; # Size of point markers, default = 25; self.point_size = [25, 32, 35, 45]; # Shape of point markers, default = ['o','^','d','s']; self.point_marker = ['o', 's', 'd', '^']. # ---data lists---; # Data for point markers; self.points = []; # Data for Bloch vectors; self.vectors = []; # Data for annotations; self.annotations = []; # Number of times sphere has been saved; self.savenum = 0; # Style of points, 'm' for multiple colors, 's' for single color; self.point_style = []. # status of rendering; self._rendered = False. [docs] def set_label_convention(self, convention):; """"""Set x, y and z labels according to one of conventions. Parameters; ----------; convention : string; One of the following:; ; - ""original""; - ""xyz""; ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:11109,Usability,clear,clear,11109,"_color: "" + str(self.sphere_color) + ""\n""; s += ""figsize: "" + str(self.figsize) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_style: "" + str(self.vector_style) + ""\n""; s += ""vector_mutation: "" + str(self.vector_mutation) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. def _repr_png_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'png'); plt.close(self.fig); return fig_data. def _repr_svg_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'svg').decode('utf-8'); plt.close(self.fig); return fig_data. [docs] def clear(self):; """"""Resets Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []; self.annotations = []. [docs] def add_points(self, points, meth='s'):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array/list; Collection of data points. meth : str {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line. """"""; if not isinstance(points[0], (list, ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = array(points); if meth == 's':; if len(points[0]) == 1:; pnts = array([[points[0][0]], [points[1][0]], [points[2][0]]]); pnts = append(pnts, points, axis=1); else:; pnts = points; self.points.append(pnts); self.point_style.append('s'); elif meth == 'l':; self.points.append(points); self.point_style.append('l'); else:; self.points.append(points); self.point_style.append('m'). [docs] def add_states(self, state, kind='vector'):; """"""Add a state vector Qobj to Bloch sphere. Paramet",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:14092,Usability,clear,clear,14092,"e; Annotation text.; You can use LaTeX, but remember to use raw string; e.g. r""$\\langle x \\rangle$""; or escape backslashes; e.g. ""$\\\\langle x \\\\rangle$"". **kwargs :; Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment.; ; """"""; if isinstance(state_or_vector, Qobj):; vec = [expect(sigmax(), state_or_vector),; expect(sigmay(), state_or_vector),; expect(sigmaz(), state_or_vector)]; elif isinstance(state_or_vector, (list, ndarray, tuple)) \; and len(state_or_vector) == 3:; vec = state_or_vector; else:; raise Exception(""Position needs to be specified by a qubit "" +; ""state or a 3D vector.""); self.annotations.append({'position': vec,; 'text': text,; 'opts': kwargs}). [docs] def make_sphere(self):; """"""; Plots Bloch sphere and data sets.; """"""; self.render(self.fig, self.axes). [docs] def render(self, fig=None, axes=None):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if self._rendered:; self.axes.clear(). self._rendered = True. # Figure instance for Bloch sphere plot; if not fig:; self.fig = plt.figure(figsize=self.figsize). if not axes:; self.axes = Axes3D(self.fig, azim=self.view[0], elev=self.view[1]). if self.background:; self.axes.clear(); self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.plot_axes(); self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7). self.axes.grid(False); self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self.sphere_alpha); # wireframe; self.axes.plot_wireframe(x, y, z, r",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:14336,Usability,clear,clear,14336,"alignment, verticalalignment.; ; """"""; if isinstance(state_or_vector, Qobj):; vec = [expect(sigmax(), state_or_vector),; expect(sigmay(), state_or_vector),; expect(sigmaz(), state_or_vector)]; elif isinstance(state_or_vector, (list, ndarray, tuple)) \; and len(state_or_vector) == 3:; vec = state_or_vector; else:; raise Exception(""Position needs to be specified by a qubit "" +; ""state or a 3D vector.""); self.annotations.append({'position': vec,; 'text': text,; 'opts': kwargs}). [docs] def make_sphere(self):; """"""; Plots Bloch sphere and data sets.; """"""; self.render(self.fig, self.axes). [docs] def render(self, fig=None, axes=None):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if self._rendered:; self.axes.clear(). self._rendered = True. # Figure instance for Bloch sphere plot; if not fig:; self.fig = plt.figure(figsize=self.figsize). if not axes:; self.axes = Axes3D(self.fig, azim=self.view[0], elev=self.view[1]). if self.background:; self.axes.clear(); self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.plot_axes(); self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7). self.axes.grid(False); self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self.sphere_alpha); # wireframe; self.axes.plot_wireframe(x, y, z, rstride=5, cstride=5,; color=self.frame_color,; alpha=self.frame_alpha); # equator; self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='z',; lw=self.frame_width, color=self.frame_color); self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='x',",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch.html:17614,Usability,simpl,simple,17614,"f.xlpos[0], 0, self.xlabel[0], **opts); self.axes.text(0, -self.xlpos[1], 0, self.xlabel[1], **opts). self.axes.text(self.ylpos[0], 0, 0, self.ylabel[0], **opts); self.axes.text(self.ylpos[1], 0, 0, self.ylabel[1], **opts). self.axes.text(0, 0, self.zlpos[0], self.zlabel[0], **opts); self.axes.text(0, 0, self.zlpos[1], self.zlabel[1], **opts). for a in (self.axes.w_xaxis.get_ticklines() +; self.axes.w_xaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.w_yaxis.get_ticklines() +; self.axes.w_yaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.w_zaxis.get_ticklines() +; self.axes.w_zaxis.get_ticklabels()):; a.set_visible(False). def plot_vectors(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.vectors)):. xs3d = self.vectors[k][1] * array([0, 1]); ys3d = -self.vectors[k][0] * array([0, 1]); zs3d = self.vectors[k][2] * array([0, 1]). color = self.vector_color[mod(k, len(self.vector_color))]. if self.vector_style == '':; # simple line style; self.axes.plot(xs3d, ys3d, zs3d,; zs=0, zdir='z', label='Z',; lw=self.vector_width, color=color); else:; # decorated style, with arrow heads; a = Arrow3D(xs3d, ys3d, zs3d,; mutation_scale=self.vector_mutation,; lw=self.vector_width,; arrowstyle=self.vector_style,; color=color). self.axes.add_artist(a). def plot_points(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.points)):; num = len(self.points[k][0]); dist = [sqrt(self.points[k][0][j] ** 2 +; self.points[k][1][j] ** 2 +; self.points[k][2][j] ** 2) for j in range(num)]; if any(abs(dist - dist[0]) / dist[0] > 1e-12):; # combine arrays so that they can be sorted together; zipped = list(zip(dist, range(num))); zipped.sort() # sort rates from lowest to highest; dist, indperm = zip(*zipped); indperm = array(indperm); else:; indperm = arange(num); if self.point_style[k] == 's':; self.axes.scatter(; real(self.points[k][1][indperm]),; - real(self.points[k][0][indperm]),; real(self.points",MatchSource.WIKI,docs/4.3/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17007,Availability,error,error,17007,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:2208,Deployability,integrat,integrate,2208,"RS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; from functools import partial; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.operators import qdiags; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10275,Deployability,integrat,integrator,10275,"r the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progre",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10341,Deployability,integrat,integrate,10341,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10819,Deployability,update,update,10819,"0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:11259,Deployability,integrat,integrate,11259,"; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else: ; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15539,Deployability,integrat,integrate,15539,"None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.appe",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:16932,Deployability,update,update,16932,"e, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_f",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:16995,Deployability,integrat,integration,16995,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17628,Deployability,integrat,integrate,17628,"ps); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:18184,Deployability,update,updated,18184,"ps); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:2208,Integrability,integrat,integrate,2208,"RS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; from functools import partial; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.operators import qdiags; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4055,Integrability,depend,dependent,4055,"tip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ---",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4188,Integrability,depend,dependent,4188,"tip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ---",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4362,Integrability,depend,dependence,4362,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4522,Integrability,depend,dependence,4522,"e, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : li",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4743,Integrability,depend,dependence,4743,"l as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:5040,Integrability,depend,dependence,5040,"lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms.; ; sec_cutoff : float {0.1}; Cutoff for secular approximation.; ; tol : float {qutip.setttings.atol}; Tolerance used for removing small values after ; basis transformation.; ; spectra_cb : list; DEPRECIATED. D",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:7207,Integrability,depend,dependent,7207,":`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:7531,Integrability,depend,dependence,7531,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10275,Integrability,integrat,integrator,10275,"r the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progre",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10341,Integrability,integrat,integrate,10341,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:11259,Integrability,integrat,integrate,11259,"; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None, ; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):; ; if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]; ; H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []; ; if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else: ; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15539,Integrability,integrat,integrate,15539,"None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.appe",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:16995,Integrability,integrat,integration,16995,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17628,Integrability,integrat,integrate,17628,"ps); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:2504,Modifiability,config,config,2504,"IRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; from functools import partial; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.operators import qdiags; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3634,Modifiability,coupling,coupling,3634," from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.superoperator import liouvillian; from qutip.interpolate import Cubic_Spline; from qutip.cy.spconvert import arr_coo2fast; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3833,Modifiability,coupling,coupling,3833," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:3975,Modifiability,variab,variable,3975," TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4243,Modifiability,variab,variable,4243,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4307,Modifiability,variab,variables,4307,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:4390,Modifiability,variab,variable,4390,"e(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:5794,Modifiability,coupling,coupling,5794,"ely.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms.; ; sec_cutoff : float {0.1}; Cutoff for secular approximation.; ; tol : float {qutip.setttings.atol}; Tolerance used for removing small values after ; basis transformation.; ; spectra_cb : list; DEPRECIATED. Do not use.; ; options : :class:`qutip.solver.Options`; Options for the solver.; ; progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):;",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:7481,Modifiability,config,config,7481,"fied by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # ----------------------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:7506,Modifiability,config,config,7506,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:7567,Modifiability,config,config,7567,"llows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); ; # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; if n_str == 0:; ; R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output; ; elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops, ; c_ops=c_ops, args=args, use_secular=use_secular, ; sec_cutoff=sec_cutoff,; tol=tol, options=options, ; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose, ; _prep_time=_prep_time); ; return output; ; else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield m",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:13074,Modifiability,coupling,coupling,13074,"append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'); ; ; for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:13623,Modifiability,coupling,coupling,13623,".'); ; coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'); ; coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; ; for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(co",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14493,Modifiability,config,config,14493,"isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vecto",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14551,Modifiability,config,config,14551,"[1][nn+1].coeffs); spline_count[1] += 1; ; else:; raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.inte",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14598,Modifiability,config,config,14598,"raise Exception('Invalid bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:14623,Modifiability,config,config,14623," bath-coupling specification.'); ; ; string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_s",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15004,Modifiability,config,config,15004,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15011,Modifiability,config,config,15011,".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_va",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15253,Modifiability,config,config,15253,"olver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):;",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15303,Modifiability,config,config,15303,"r(value)); parameter_string = "","".join(string_list); ; if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15389,Modifiability,config,config,15389,"se:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; ou",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:15553,Modifiability,config,config,15553,"fig.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17816,Modifiability,config,config,17816,"ps); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17867,Modifiability,config,config,17867,"ps); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:2156,Deployability,continuous,continuous,2156,"re without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; """"""; Given a basis set of operators :math:`\\{a\\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \\langle a_m a_n \\rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """""". if rho is None:; # return array of operators; return np.array([[op1 * op2 for op1 in b",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8635,Deployability,update,updated,8635,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:2167,Modifiability,variab,variable,2167,"re without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; """"""; Given a basis set of operators :math:`\\{a\\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \\langle a_m a_n \\rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """""". if rho is None:; # return array of operators; return np.array([[op1 * op2 for op1 in b",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:7783,Testability,log,logarithmic,7783,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8112,Testability,log,logarithmic,8112,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8461,Testability,log,lognu,8461,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8473,Testability,log,log,8473,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8486,Testability,log,logneg,8486,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8502,Testability,log,lognu,8502,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html:8517,Testability,log,logneg,8517,"perator for mode 1. a2 : Qobj; Field operator for mode 2. R : ndarray; The quadrature correlation matrix. rho : Qobj; Density matrix for which to calculate the covariance matrix. Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:4793,Availability,error,errors,4793,"; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `tlist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state den",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:7025,Availability,error,errors,7025,"ke; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :m",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:9289,Availability,error,errors,9289,"tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Ini",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:11422,Availability,error,errors,11422,"ed as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\\tau) =; \\frac{\\langle A^\\dagger(\\tau)A(0)\\rangle}; {\\sqrt{\\",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:13522,Availability,error,errors,13522,"egression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}.",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:15605,Availability,error,errors,15605,"solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>; e^{-",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:20238,Availability,error,errors,20238,"or two-time correlation function:. .. math::. \lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate; :math:`\lim_{t \\to \\infty} \left<A(t)B(t+\\tau)\\right>` instead of; :math:`\lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qob",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:22476,Availability,error,errors,22476,"s. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:24624,Availability,error,errors,24624,"----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2.; ; .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along two time axes using the quantum regression theorem ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:27076,Availability,error,errors,27076," state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correlati",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:36673,Availability,error,errors,36673,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\r",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40395,Availability,error,errors,40395,"ce(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41378,Availability,error,errors,41378,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:42017,Deployability,update,updated,42017,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:17707,Energy Efficiency,power,power,17707,"s spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y); ; # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:18210,Energy Efficiency,power,power,18210,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y); ; # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", revers",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:3745,Integrability,depend,dependent,3745,"te import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:4210,Integrability,depend,dependent,4210,"PI; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `tlist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0]",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:5727,Integrability,depend,dependent,5727,"ively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `tlist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str; cho",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:6461,Integrability,depend,dependent,6461,"he two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.sta",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:8375,Integrability,depend,dependent,8375,"es; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:8838,Integrability,depend,dependent,8838,"s). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):;",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:10239,Integrability,depend,dependent,10239,"t,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Option",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:10971,Integrability,depend,dependent,10971,"ng the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solv",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:12681,Integrability,depend,dependent,12681,"s `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\\tau) =; \\frac{\\langle A^\\dagger(\\tau)A(0)\\rangle}; {\\sqrt{\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order cohe",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:13146,Integrability,depend,dependent,13146,"correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\\tau) =; \\frac{\\langle A^\\dagger(\\tau)A(0)\\rangle}; {\\sqrt{\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:14702,Integrability,depend,dependent,14702,"# first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2,",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:15167,Integrability,depend,dependent,15167,"docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_o",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:21193,Integrability,depend,dependent,21193,"00]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for ma",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:21929,Integrability,depend,dependent,21929,"two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use corr",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:23690,Integrability,depend,dependent,23690,") and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_ep",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:24153,Integrability,depend,dependent,24153,"orrelation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2.; ; .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:25877,Integrability,depend,dependent,25877,"ecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Op",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:26605,Integrability,depend,dependent,26605,"using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:38715,Integrability,depend,dependence,38715,". tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-li",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:38991,Integrability,depend,dependent,38991,")). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:39335,Integrability,depend,dependence,39335,". def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_forma",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:39612,Integrability,depend,dependence,39612,"ady been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:39727,Integrability,depend,dependence,39727,"same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian tim",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:39940,Integrability,depend,dependent,39940," in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. fo",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40046,Integrability,depend,dependence,40046,"# constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regressio",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40227,Integrability,depend,dependence,40227,"ce(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40333,Integrability,depend,dependence,40333,"ce(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40576,Integrability,depend,dependence,40576,"ce(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; r",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40738,Integrability,depend,dependence,40738,"ce(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; r",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:40896,Integrability,depend,dependent,40896,": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41021,Integrability,depend,dependence,41021,"e dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . B",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41206,Integrability,depend,dependence,41206,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41316,Integrability,depend,dependence,41316,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41563,Integrability,depend,dependence,41563,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:41740,Integrability,depend,dependence,41740,"orem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:2909,Modifiability,config,config,2909,"SE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:31043,Modifiability,config,config,31043,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:31081,Modifiability,config,config,31081,"ver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:32406,Modifiability,config,config,32406,", tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0]",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:32444,Modifiability,config,config,32444,"if solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.z",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:32749,Modifiability,config,config,32749,"tions()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); solES_t = ode2es(L, rho0). # evaluate the correlation function; for t_idx in range(len(tlist)):; rho_t = esval(solES_t, [tlist[t_idx]]); solES_tau = ode2es(L, c_op * rho_t * a_op); corr_mat[t_idx, :] = esval(expect(b_op, solES_tau), taulist). return corr_mat. de",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:32787,Modifiability,config,config,32787,"function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); solES_t = ode2es(L, rho0). # evaluate the correlation function; for t_idx in range(len(tlist)):; rho_t = esval(solES_t, [tlist[t_idx]]); solES_tau = ode2es(L, c_op * rho_t * a_op); corr_mat[t_idx, :] = esval(expect(b_op, solES_tau), taulist). return corr_mat. def _spectrum_es(H, wlist,",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:35513,Modifiability,config,config,35513,"c(cov_es, wlist). return spectrum. # Monte Carlo solvers. def _correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:35551,Modifiability,config,config,35551,"c_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.d",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:36026,Modifiability,evolve,evolve,36026," +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:36823,Modifiability,evolve,evolve,36823,"nstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:37369,Modifiability,config,config,37369,"tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # au",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:37407,Modifiability,config,config,37407,"erwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:38472,Modifiability,variab,variable,38472,"ear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; e",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:36633,Performance,load,loaded,36633,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add; ; if t_idx == 1:; options.rhs_reuse = True; ; if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\r",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/correlation.html:38955,Testability,test,test,38955,")). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = ",MatchSource.WIKI,docs/4.3/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8121,Deployability,update,update,8121,"bes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8138,Deployability,update,update,8138,"distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8511,Deployability,update,update,8511,"int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. f",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8528,Deployability,update,update,8528," (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8973,Deployability,update,update,8973,"[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate ",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:8999,Deployability,update,update,8999,"', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix; """""". X",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:11263,Deployability,update,update,11263,"(self.xvecs[1])), dtype=complex); M2 = np.zeros(; (N, N, len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) *",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:11287,Deployability,update,update,11287,"f.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), s",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:11915,Deployability,update,update,11915,"yval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:11939,Deployability,update,update,11939,"yval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:12679,Deployability,update,updated,12679,"yval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:6890,Energy Efficiency,reduce,reduced,6890,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:7450,Energy Efficiency,reduce,reduced-dimensionality,7450,"=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.x",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/distributions.html:3840,Integrability,depend,depending,3840,"cs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, style=""colormap"",; show_xlabel=True, show_ylabel=True):; """"""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""; n = len(self.xvecs); if n == 2:; if style == ""colormap"":; return self.visualize_2d_colormap(fig=fig, ax=ax,; figsize=figsize,; colorbar=colorbar,; cmap=cmap,; show_xlabel=show_xlabel,; show_ylabel=show_ylabel); else:; return self.visualize_2d_surface(fig=fi",MatchSource.WIKI,docs/4.3/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:4966,Availability,mask,mask,4966,"ho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:5059,Availability,mask,mask,5059,"st be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:9479,Deployability,update,updated,9479,": qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:8577,Energy Efficiency,power,power,8577,": qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:8817,Energy Efficiency,power,power,8817,": qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:2129,Performance,concurren,concurrence,2129,"om this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals =",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3641,Performance,concurren,concurrence,3641,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def nega",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3679,Performance,concurren,concurrence,3679,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def nega",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:4489,Safety,avoid,avoid,4489,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:2244,Testability,log,log,2244," HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). ",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:2680,Testability,log,logarithm,2680,"OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3069,Testability,log,logvals,3069,"_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3110,Testability,log,logvals,3110,"_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3120,Testability,log,log,3120,"_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:3214,Testability,log,logvals,3214,"ort e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.is",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:4722,Testability,log,logarithmic,4722,"; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:5293,Testability,log,logarithmic,5293,"rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; ",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:5781,Testability,log,logarithm,5781," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """,MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:6700,Testability,log,logarithm,6700,"t; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of l",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:7063,Testability,log,log,7063,"= 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:7253,Testability,log,log,7253,"); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. def _entropy_relative(rho, sigma, base=e, sparse=False):; """"""; ****NEEDS TO BE WORKED ON****. Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : qobj; First density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for co",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/entropy.html:7692,Testability,log,logarithm,7692,"st density matrix.; sigma : qobj; Second density matrix.; base : {e,2}; Base of logarithm. Returns; -------; rel_ent : float; Value of relative entropy. """"""; if rho.type != 'oper' or sigma.type != 'oper':; raise TypeError(""Inputs must be density matrices..""); # sigma terms; svals = sp_eigs(sigma.data, sigma.isherm, vecs=False, sparse=sparse); snzvals = svals[svals != 0]; if base == 2:; slogvals = log2(snzvals); elif base == e:; slogvals = log(snzvals); else:; raise ValueError(""Base must be 2 or e.""); # rho terms; rvals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); rnzvals = rvals[rvals != 0]; # calculate tr(rho*log sigma); rel_trace = float(real(sum(rnzvals * slogvals))); return -entropy_vn(rho, base, sparse) - rel_trace. [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero",MatchSource.WIKI,docs/4.3/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html
https://qutip.org/docs/4.3/modules/qutip/eseries.html:11324,Deployability,update,updated,11324,"_key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html
https://qutip.org/docs/4.3/modules/qutip/eseries.html:2274,Integrability,depend,dependent,2274,"CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=np.array([], dtype=object), s=np.array([])):. if isinstance(s, (int, float, complex)):; s = np.array([s]). if (not np.any(np.asarray(q, dtype=object))) and (len(s) == 0):; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif np.any(np.asarray(q, dtype=object)) and (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; s",MatchSource.WIKI,docs/4.3/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html
https://qutip.org/docs/4.3/modules/qutip/eseries.html:10414,Integrability,wrap,wrapper,10414,"_key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html
https://qutip.org/docs/4.3/modules/qutip/eseries.html:10436,Security,access,accessing,10436,"_key; break. if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray(total_ampl,; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/eseries.html
https://qutip.org/docs/4.3/modules/qutip/essolve.html:4898,Availability,error,error,4898," else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rh",MatchSource.WIKI,docs/4.3/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/essolve.html
https://qutip.org/docs/4.3/modules/qutip/essolve.html:5567,Availability,error,error,5567,"iven the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/essolve.html
https://qutip.org/docs/4.3/modules/qutip/essolve.html:6370,Deployability,update,updated,6370,"iven the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/essolve.html
https://qutip.org/docs/4.3/modules/qutip/essolve.html:2566,Integrability,depend,depending,2566,"CT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``",MatchSource.WIKI,docs/4.3/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/essolve.html
https://qutip.org/docs/4.3/modules/qutip/essolve.html:3578,Integrability,depend,dependent,3578,"pending on whether; # any collapse operators were given.; #; [docs]def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 :",MatchSource.WIKI,docs/4.3/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/essolve.html
https://qutip.org/docs/4.3/modules/qutip/expect.html:5575,Deployability,update,updated,5575,".array([_single_qobj_expect(oper, x) for x in state],; dtype=complex); else:; raise TypeError('Arguments must be quantum objects or eseries'). def _single_qobj_expect(oper, state):; """"""; Private function used by expect to calculate expectation values of Qobjs.; """"""; if isoper(oper):; if oper.dims[1] != state.dims[0]:; raise Exception('Operator and state do not have same tensor ' +; 'structure: %s and %s' %; (oper.dims[1], state.dims[0])). if state.type == 'oper':; # calculates expectation value via TR(op*rho); return cy_spmm_tr(oper.data, state.data,; oper.isherm and state.isherm). elif state.type == 'ket':; # calculates expectation value via <psi|op|psi>; return expect_csr_ket(oper.data, state.data,; oper.isherm); else:; raise TypeError('Invalid operand types'). def _single_eseries_expect(oper, state):; """"""; Private function used by expect to calculate expectation values for; eseries.; """""". out = eseries(). if isoper(state.ampl[0]):; out.rates = state.rates; out.ampl = np.array([expect(oper, a) for a in state.ampl]). else:; out.rates = np.array([]); out.ampl = np.array([]). for m in range(len(state.rates)):; op_m = state.ampl[m].data.conj().T * oper.data. for n in range(len(state.rates)):; a = op_m * state.ampl[n].data. if isinstance(a, sp.spmatrix):; a = a.todense(). out.rates = np.append(out.rates, state.rates[n] -; state.rates[m]); out.ampl = np.append(out.ampl, a). return out. [docs]def variance(oper, state):; """"""; Variance of an operator for the given state vector or density matrix. Parameters; ----------; oper : qobj; Operator for expectation value. state : qobj/list; A single or `list` of quantum states or density matrices.. Returns; -------; var : float; Variance of operator 'oper' for given state. """"""; return expect(oper ** 2, state) - expect(oper, state) ** 2. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/expect.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/expect.html
https://qutip.org/docs/4.3/modules/qutip/fileio.html:7881,Deployability,update,updated,7881,"f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html
https://qutip.org/docs/4.3/modules/qutip/fileio.html:6974,Performance,load,loaded,6974," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provide",MatchSource.WIKI,docs/4.3/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html
https://qutip.org/docs/4.3/modules/qutip/fileio.html:7188,Performance,load,load,7188,"f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html
https://qutip.org/docs/4.3/modules/qutip/fileio.html:7279,Performance,load,load,7279,"f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1') # return the object from the file; else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/fileio.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:21372,Deployability,integrat,integrator,21372,"nitial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:21436,Deployability,integrat,integrate,21436,"dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = f",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:22600,Deployability,integrat,integrate,22600,"opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); for m in range(0, n_expt_op):; output.expect[m][t_idx] = \; expect(e_ops[m], rho.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of fre",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:25766,Deployability,update,updated,25766,"for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # get w_th from args if it exists; if 'w_th' in args:; w_th = args['w_th']; else:; w_th = 0. # TODO: loop over input c_ops and spectra_cb, calculate one R for each set. # calculate the rate-matrices for the floquet-markov master equation; Delta, X, Gamma, Amat = floquet_master_equation_rates(; f_modes_0, f_energies, c_ops[0], H, T, args, spectra_cb[0],; w_th, kmax, f_modes_table_t). # the floquet-markov master equation tensor; R = floquet_master_equation_tensor(Amat, f_energies). return floquet_markov_mesolve(R, f_modes_0, rho0, tlist, e_ops,; f_modes_table=(f_modes_table_t, T),; options=options,; floquet_basis=floquet_basis). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:4483,Energy Efficiency,energy,energy,4483,"ort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:4732,Energy Efficiency,energy,energy,4732," float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:15539,Energy Efficiency,power,power,15539,"; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:23570,Energy Efficiency,power,power,23570,"o.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which co",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:24029,Energy Efficiency,energy,energy,24029,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:3637,Integrability,depend,dependent,3637,"obj import Qobj, isket; from qutip.superoperator import vec2mat_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs +",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:3767,Integrability,depend,dependence,3767,"utip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.args",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:3942,Integrability,depend,dependent,3942,"r; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:5509,Integrability,depend,dependent,5509,"al [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of t",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:5639,Integrability,depend,dependence,5639,"(eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:6601,Integrability,depend,dependent,6601,"ate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table o",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:6662,Integrability,depend,dependence,6662,"miltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floque",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:7485,Integrability,depend,dependence,7485,"j` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:7779,Integrability,depend,dependence,7779,"--. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # if debug: print ""t = %f -> t_wrap = %f @ %d of %d"" % (t, t_wrap, t_idx,; # N). return f_modes_table_t[t_idx]. def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:9471,Integrability,depend,dependent,9471,"t_idx,; # N). return f_modes_table_t[t_idx]. def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:9532,Integrability,depend,dependence,9532,"es(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:11159,Integrability,depend,dependent,11159,"et modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:11220,Integrability,depend,dependence,11220,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolv",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:12421,Integrability,depend,dependent,12421,"ates_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:12826,Integrability,depend,dependence,12826," of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:13437,Integrability,depend,dependent,13437," :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_ops, list):. output.num_expect = len(e_ops); expt_callback = False. if output.num_expect == 0:; output.states = []; else:; output.expect = []; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:15307,Integrability,depend,dependent,15307,"n enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:15368,Integrability,depend,dependence,15368,"es_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:21372,Integrability,integrat,integrator,21372,"nitial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:21436,Integrability,integrat,integrate,21436,"dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = f",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:22600,Integrability,integrat,integrate,22600,"opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); for m in range(0, n_expt_op):; output.expect[m][t_idx] = \; expect(e_ops[m], rho.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of fre",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:23686,Integrability,depend,dependence,23686,"--------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_sa",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:23863,Integrability,depend,dependent,23863," args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:3699,Modifiability,variab,variables,3699,"_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi ",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:5571,Modifiability,variab,variables,5571," += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:6728,Modifiability,variab,variables,6728,"es as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate t",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:9598,Modifiability,variab,variables,9598,"time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def fl",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:11286,Modifiability,variab,variables,11286,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Sol",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:12892,Modifiability,variab,variables,12892," : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:15434,Modifiability,variab,variables,15434,"s, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/floquet.html:18796,Usability,simpl,simple,18796,"on Bloch-Redfield form, or perhaps; # we can use the Lindblad form master equation with some rotating frame; # approximations? ...; #; for a in range(N):; for b in range(N):; if a != b and abs(A[a, b]) > 0.0:; # only relaxation terms included...; c_ops.append(sqrt(A[a, b]) * projection(N, a, b)). return c_ops. def floquet_master_equation_tensor(Alist, f_energies):; """"""; Construct a tensor that represents the master equation in the floquet; basis (with constant Hamiltonian and collapse operators). Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------. Alist : list; A list of Floquet-Markov master equation rate matrices. f_energies : array; The Floquet energies. Returns; -------. output : array. The Floquet-Markov master equation tensor `R`. """""". if isinstance(Alist, list):; # Alist can be a list of rate matrices corresponding; # to different operators that couple to the environment; N, M = np.shape(Alist[0]); else:; # or a simple rate matrix, in which case we put it in a list; Alist = [Alist]; N, M = np.shape(Alist[0]). Rdata_lil = scipy.sparse.lil_matrix((N * N, N * N), dtype=complex); for I in range(N * N):; a, b = vec2mat_index(N, I); for J in range(N * N):; c, d = vec2mat_index(N, J). R = -1.0j * (f_energies[a] - f_energies[b])*(a == c)*(b == d); Rdata_lil[I, J] = R. for A in Alist:; s1 = s2 = 0; for n in range(N):; s1 += A[a, n] * (n == c) * (n == d) - A[n, a] * \; (a == c) * (a == d); s2 += (A[n, a] + A[n, b]) * (a == c) * (b == d). dR = (a == b) * s1 - 0.5 * (1 - (a == b)) * s2. if dR != 0.0:; Rdata_lil[I, J] += dR. return Qobj(Rdata_lil, [[N, N], [N, N]], [N*N, N*N]). def floquet_master_equation_steadystate(H, A):; """"""; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation.; """"""; c_ops = floquet_collapse_operators(A); rho_ss = steadystate(H, c_ops); return rho_ss. def floquet_basis_transform(f_modes, f_energies, rho0):; """"""; Make a basis transform that takes rho0 from the f",MatchSource.WIKI,docs/4.3/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/floquet.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:9435,Deployability,update,updated,9435,"s that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """"""; ; nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float), ; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:2101,Integrability,rout,routines,2101," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search', ; 'reverse_cuthill_mckee', 'maximum_bipartite_matching', ; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]d",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:4797,Integrability,rout,routine,4797,"= A.shape[0]; start = int(start); order, levels = _breadth_first_search(A.indices, A.indptr, num_rows, start); # since maybe not all nodes are in search, check for unused entires in; # arrays; return order[order != -1], levels[levels != -1]. def column_permutation(A):; """"""; Finds the non-symmetric column permutation of A such that the columns ; are given in ascending order according to the number of nonzero entries.; This is sometimes useful for decreasing the fill-in of sparse LU ; factorization.; ; Parameters; ----------; A : csc_matrix; Input sparse CSC sparse matrix. Returns; -------; perm : array; Array of permuted row and column indices.; ; """"""; if not sp.isspmatrix_csc(A):; A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; ; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise T",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:5455,Integrability,rout,routine,5455," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; ; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'). nrows = A.shape[0]. if not sym:; A = A + A.transpose(). return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if; necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutati",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:5561,Integrability,rout,routines,5561," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; ; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'). nrows = A.shape[0]. if not sym:; A = A + A.transpose(). return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if; necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutati",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/graph.html:8283,Performance,perform,performing,8283,"s). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """"""; ; nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float), ; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. © Cop",MatchSource.WIKI,docs/4.3/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/graph.html
https://qutip.org/docs/4.3/modules/qutip/interpolate.html:4783,Deployability,update,updated,4783," normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/interpolate.html
https://qutip.org/docs/4.3/modules/qutip/interpolate.html:3697,Energy Efficiency,reduce,reduced,3697," the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.",MatchSource.WIKI,docs/4.3/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/interpolate.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:10860,Availability,avail,available,10860,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the ",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:4947,Deployability,update,update,4947,"""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_do",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:5510,Deployability,update,update,5510,"2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % p",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11335,Deployability,update,update,11335,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<vi",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11405,Deployability,update,update,11405," {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); re",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11969,Deployability,update,update,11969,"or each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:12068,Deployability,update,update,12068,"or each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:12553,Deployability,update,updated,12553,"or each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:6237,Energy Efficiency,schedul,scheduling,6237,",0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``cl",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:6666,Energy Efficiency,green,green,6666,"remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional addition",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:6883,Energy Efficiency,schedul,schedule,6883,"lf.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPy",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:7939,Energy Efficiency,schedul,scheduling,7939,"client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:8294,Energy Efficiency,schedul,scheduled,8294,"` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The `",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:10001,Energy Efficiency,schedul,scheduling,10001,"s_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanc",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:10356,Energy Efficiency,schedul,scheduled,10356,"oad-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progr",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:2275,Integrability,rout,routines,2275,"ING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:2330,Integrability,rout,routines,2330,"ING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:3267,Integrability,depend,dependencies,3267,"lities import _blas_info; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Addition",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:3597,Integrability,depend,dependencies,3597,"l__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % tim",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:7286,Performance,load,load-balanced,7286,"rray(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:7998,Performance,load,load-balanced,7998,"all the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:9295,Performance,load,load-balanced,9295,"hon engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` ",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:10060,Performance,load,load-balanced,10060,"for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs);",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11377,Safety,timeout,timeout,11377,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:4673,Usability,simpl,simple,4673,"/th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:4685,Usability,progress bar,progress bar,4685,"/th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", qutip.hardware_info.hardware_info()['cpus']),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:8410,Usability,progress bar,progress bar,8410,"ed. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:10472,Usability,progress bar,progress bar,10472,"The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_schedu",MatchSource.WIKI,docs/4.3/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:24922,Availability,toler,tolerance,24922," config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp =",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:25713,Availability,toler,tolerance,25713,"egrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:2196,Deployability,integrat,integrate,2196,"THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_exp",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:2256,Deployability,integrat,integrate,2256,""" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None;",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12967,Deployability,update,update,12967,"eeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:18343,Deployability,integrat,integrate,18343,"0, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_ou",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:18380,Deployability,integrat,integrate,18380,"ode = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:20887,Deployability,integrat,integrate,20887,"DE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:20924,Deployability,integrat,integrate,20924," ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.ze",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:24652,Deployability,integrat,integrate,24652,"tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:24703,Deployability,integrat,integrate,24703,"= 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:25235,Deployability,integrat,integrate,25235,"eset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:39943,Deployability,update,updated,39943,"const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12089,Energy Efficiency,reduce,reduced,12089," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:2196,Integrability,integrat,integrate,2196,"THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_exp",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:2256,Integrability,integrat,integrate,2256,""" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None;",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:3939,Integrability,depend,dependent,3939,"ngs. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:4045,Integrability,depend,dependent,4045,"ngs. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:4167,Integrability,depend,dependent,4167,"_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:4265,Integrability,depend,dependent,4265,"_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:4371,Integrability,depend,dependent,4371,"_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:4510,Integrability,depend,dependent,4510,"_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or ``list`` or ``array`` of collapse; operators. e_ops : array_like; single operator or ``list`` or ``array`` of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse o",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:5500,Integrability,depend,dependent,5500,"e-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or ``list`` or ``array`` of collapse; operators. e_ops : array_like; single operator or ``list`` or ``array`` of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8010,Integrability,depend,dependence,8010,"onfig.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8276,Integrability,depend,dependence,8276,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8358,Integrability,depend,dependence,8358,"tions.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # S",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13828,Integrability,depend,dependent,13828,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:18343,Integrability,integrat,integrate,18343,"0, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_ou",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:18380,Integrability,integrat,integrate,18380,"ode = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:20887,Integrability,integrat,integrate,20887,"DE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:20924,Integrability,integrat,integrate,20924," ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.ze",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:24652,Integrability,integrat,integrate,24652,"tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:24703,Integrability,integrat,integrate,24703,"= 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:25235,Integrability,integrat,integrate,25235,"eset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:26106,Integrability,depend,dependent,26106,"_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE.",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:27240,Integrability,depend,dependent,27240,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; conf",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:29585,Integrability,wrap,wrapper,29585," float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:30087,Integrability,depend,dependent,30087,"_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; confi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:32300,Integrability,depend,dependent,32300,"ps_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:32445,Integrability,depend,dependent,32445,"----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:32631,Integrability,depend,dependent,32631,"erms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-I",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:33364,Integrability,depend,dependent,33364," of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms;",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:33509,Integrability,depend,dependent,33509,"C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:33815,Integrability,depend,dependent,33815,"_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:34201,Integrability,depend,dependent,34201,"h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:34281,Integrability,depend,dependent,34281,"e operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:34472,Integrability,depend,dependent,34472,"ff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:34612,Integrability,depend,dependent,34612,"s]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectati",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:37832,Integrability,depend,dependent,37832," = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:38068,Integrability,depend,dependent,38068," + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:2691,Modifiability,config,config,2691,"FITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a stat",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:3098,Modifiability,variab,variables,3098,".integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:6664,Modifiability,config,config,6664,"ar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.s",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:6734,Modifiability,config,config,6734," the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.av",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:6878,Modifiability,config,config,6878,"s: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # se",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:6948,Modifiability,config,config,6948," map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = opti",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:6996,Modifiability,config,config,6996,"lass:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_ste",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7039,Modifiability,config,config,7039,"l results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to s",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7159,Modifiability,config,config,7159,"solver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7185,Modifiability,config,config,7185,"ect seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # ----------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7239,Modifiability,config,config,7239,"prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.td",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7383,Modifiability,config,config,7383,"ps, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.sof",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7457,Modifiability,config,config,7457,"for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7520,Modifiability,config,config,7520,"safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7555,Modifiability,config,config,7555,"_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.t",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7585,Modifiability,config,config,7585,"tions is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check fo",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7651,Modifiability,config,config,7651,"e:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7689,Modifiability,config,config,7689," map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure d",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7748,Modifiability,config,config,7748,".map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7813,Modifiability,config,config,7813,"0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if nece",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7855,Modifiability,config,config,7855,"tate must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:;",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7907,Modifiability,config,config,7907,"options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:7943,Modifiability,config,config,7943,"True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8227,Modifiability,config,config,8227,"ngs.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc =",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8251,Modifiability,config,config,8251,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8312,Modifiability,config,config,8312,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8550,Modifiability,config,config,8550,"tions.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # S",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8625,Modifiability,config,config,8625,"= psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not No",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8650,Modifiability,config,config,8650,"es; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8759,Modifiability,config,config,8759,"s = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.ps",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8832,Modifiability,config,config,8832,"array)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation value",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8940,Modifiability,config,config,8940,"ng constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:8985,Modifiability,config,config,8985,"s.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expec",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9070,Modifiability,config,config,9070,"s = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=obje",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9132,Modifiability,config,config,9132,"DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstan",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9165,Modifiability,config,config,9165,"--------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expec",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9227,Modifiability,config,config,9227,"_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9336,Modifiability,config,config,9336," # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].i",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9374,Modifiability,config,config,9374,"ndence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.r",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9541,Modifiability,config,config,9541,"ocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single traje",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9611,Modifiability,config,config,9611,"tors; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.exp",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9646,Modifiability,config,config,9646," 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect =",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9841,Modifiability,config,config,9841,"(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:9859,Modifiability,config,config,9859,"rgs for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:10083,Modifiability,config,config,10083,"in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # ------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:10696,Modifiability,config,config,10696,"rfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtyp",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:10730,Modifiability,config,config,10730,"elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_ou",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:10766,Modifiability,config,config,10766,"t.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:10795,Modifiability,config,config,10795,"tion values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 o",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11287,Modifiability,config,config,11287,"e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11302,Modifiability,config,config,11302,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11311,Modifiability,config,config,11311,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11332,Modifiability,variab,variables,11332,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11543,Modifiability,config,config,11543," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(ins",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11678,Modifiability,config,config,11678,"s; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, se",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11740,Modifiability,config,config,11740,"um; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11776,Modifiability,config,config,11776,"c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11797,Modifiability,config,config,11797,"= config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(s",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11851,Modifiability,config,config,11851,"_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to mo",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11868,Modifiability,config,config,11868,"h = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11914,Modifiability,config,config,11914,"put.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11957,Modifiability,config,config,11957,"te(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_k",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:11993,Modifiability,config,config,11993,"t. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs)",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12052,Modifiability,config,config,12052,"-----------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; sel",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12134,Modifiability,config,config,12134," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12174,Modifiability,config,config,12174,"---------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; t",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12194,Modifiability,config,config,12194,"""""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwa",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12220,Modifiability,config,config,12220," solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12243,Modifiability,config,config,12243,"lution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; s",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12321,Modifiability,config,config,12321,"nfig):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_op",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12383,Modifiability,config,config,12383,"y output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12418,Modifiability,config,config,12418,"lf.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12454,Modifiability,config,config,12454,"se_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12553,Modifiability,config,config,12553,"; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12578,Modifiability,config,config,12578,"ays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=o",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12604,Modifiability,config,config,12604,"lapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ----------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12630,Modifiability,config,config,12630,"operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12728,Modifiability,config,config,12728,"s(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12798,Modifiability,config,config,12798,"g.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ---------------------------------------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12891,Modifiability,config,config,12891,"pect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12930,Modifiability,config,config,12930,"up seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, confi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:12979,Modifiability,config,config,12979,"one:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13017,Modifiability,config,config,13017,"int(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and a",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13030,Modifiability,config,config,13030,"000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least on",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13052,Modifiability,config,config,13052,"fig.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13103,Modifiability,config,config,13103,"reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13147,Modifiability,config,config,13147,"n(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, conf",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13310,Modifiability,config,config,13310,"ength < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_p",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13336,Modifiability,config,config,13336,"seeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in conf",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13403,Modifiability,config,config,13403,"gth)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13893,Modifiability,config,config,13893,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13912,Modifiability,config,config,13912,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:13929,Modifiability,config,config,13929,"lf.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (con",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14093,Modifiability,config,config,14093,"g.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14128,Modifiability,config,config,14128,"g.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14144,Modifiability,config,config,14144,"nge(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; conf",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14158,Modifiability,config,config,14158,"j)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14196,Modifiability,config,config,14196,"args). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14217,Modifiability,config,config,14217,"sult in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14255,Modifiability,config,config,14255,"tate_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; con",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14278,Modifiability,config,config,14278,"_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14300,Modifiability,config,config,14300,"sult. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14336,Modifiability,config,config,14336," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14462,Modifiability,config,config,14462,"pect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_op",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14494,Modifiability,config,config,14494,"pect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_op",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14510,Modifiability,config,config,14510,"h_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14525,Modifiability,config,config,14525,"hich_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14569,Modifiability,config,config,14569,"_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14590,Modifiability,config,config,14590,"t). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE fo",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14622,Modifiability,config,config,14622,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14644,Modifiability,config,config,14644,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14665,Modifiability,config,config,14665,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14700,Modifiability,config,config,14700," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14756,Modifiability,config,config,14756,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14777,Modifiability,config,config,14777,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14815,Modifiability,config,config,14815,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14838,Modifiability,config,config,14838,"dent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14860,Modifiability,config,config,14860,"llapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:14897,Modifiability,config,config,14897,"t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15030,Modifiability,config,config,15030," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15062,Modifiability,config,config,15062,"collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data,",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15078,Modifiability,config,config,15078,"_cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term =",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15093,Modifiability,config,config,15093," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15139,Modifiability,config,config,15139,"ata,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15165,Modifiability,config,config,15165,"onfig.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, con",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15197,Modifiability,config,config,15197,"[np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15219,Modifiability,config,config,15219,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15240,Modifiability,config,config,15240,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15275,Modifiability,config,config,15275,"ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15331,Modifiability,config,config,15331," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15352,Modifiability,config,config,15352,"inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at reques",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15390,Modifiability,config,config,15390,"sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse ope",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15413,Modifiability,config,config,15413,"list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ---------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15435,Modifiability,config,config,15435,"iltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15471,Modifiability,config,config,15471,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15638,Modifiability,config,config,15638,"csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15671,Modifiability,config,config,15671,"h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expe",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15689,Modifiability,config,config,15689,"i); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15775,Modifiability,config,config,15775,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15828,Modifiability,config,config,15828,"mv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15843,Modifiability,config,config,15843,"ig.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(co",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15858,Modifiability,config,config,15858,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15946,Modifiability,config,config,15946,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:15979,Modifiability,config,config,15979,"_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16002,Modifiability,config,config,16002," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16088,Modifiability,config,config,16088," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16141,Modifiability,config,config,16141,"erm = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16156,Modifiability,config,config,16156,"](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16171,Modifiability,config,config,16171,"g.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16499,Modifiability,config,config,16499,"fig.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16754,Modifiability,config,config,16754,"onst_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_w",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16841,Modifiability,config,config,16841,"config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:16860,Modifiability,config,config,16860," config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17113,Modifiability,config,config,17113,"_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=o",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17136,Modifiability,config,config,17136," spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17158,Modifiability,config,config,17158,", config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17180,Modifiability,config,config,17180,"g.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial con",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17194,Modifiability,config,config,17194,"urn h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_i",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17296,Modifiability,config,config,17296,"--------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_d",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17311,Modifiability,config,config,17311,"evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17330,Modifiability,config,config,17330,": return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, nu",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17422,Modifiability,config,config,17422,"------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.succ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17482,Modifiability,config,config,17482,"------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); ",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17539,Modifiability,config,config,17539,"imes tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(confi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17553,Modifiability,config,config,17553,"imes tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(confi",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
https://qutip.org/docs/4.3/modules/qutip/mcsolve.html:17583,Modifiability,config,config,17583,"; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = c",MatchSource.WIKI,docs/4.3/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mcsolve.html
